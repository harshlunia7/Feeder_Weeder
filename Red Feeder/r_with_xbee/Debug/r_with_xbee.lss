
r_with_xbee.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000356c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000c  00800060  0000356c  00003600  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000b1  0080006c  0080006c  0000360c  2**0
                  ALLOC
  3 .stab         000033e4  00000000  00000000  0000360c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009aa  00000000  00000000  000069f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000c0  00000000  00000000  000073a0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002a8d  00000000  00000000  00007460  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000043f  00000000  00000000  00009eed  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000daa  00000000  00000000  0000a32c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000009a4  00000000  00000000  0000b0d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000008fe  00000000  00000000  0000ba7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001c58  00000000  00000000  0000c37a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000108  00000000  00000000  0000dfd2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__ctors_end>
       4:	0c 94 fd 0a 	jmp	0x15fa	; 0x15fa <__vector_1>
       8:	0c 94 e6 0a 	jmp	0x15cc	; 0x15cc <__vector_2>
       c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      10:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      14:	0c 94 9c 0c 	jmp	0x1938	; 0x1938 <__vector_5>
      18:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      1c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      20:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      24:	0c 94 51 11 	jmp	0x22a2	; 0x22a2 <__vector_9>
      28:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      2c:	0c 94 24 0e 	jmp	0x1c48	; 0x1c48 <__vector_11>
      30:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      34:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      38:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      3c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      40:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      44:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      48:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      4c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      50:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      54:	07 63       	ori	r16, 0x37	; 55
      56:	42 36       	cpi	r20, 0x62	; 98
      58:	b7 9b       	sbis	0x16, 7	; 22
      5a:	d8 a7       	lds	r29, 0x78
      5c:	1a 39       	cpi	r17, 0x9A	; 154
      5e:	68 56       	subi	r22, 0x68	; 104
      60:	18 ae       	sts	0xb8, r17
      62:	ba ab       	sts	0x5a, r27
      64:	55 8c       	ldd	r5, Z+29	; 0x1d
      66:	1d 3c       	cpi	r17, 0xCD	; 205
      68:	b7 cc       	rjmp	.-1682   	; 0xfffff9d8 <__eeprom_end+0xff7ef9d8>
      6a:	57 63       	ori	r21, 0x37	; 55
      6c:	bd 6d       	ori	r27, 0xDD	; 221
      6e:	ed fd       	.word	0xfded	; ????
      70:	75 3e       	cpi	r23, 0xE5	; 229
      72:	f6 17       	cp	r31, r22
      74:	72 31       	cpi	r23, 0x12	; 18
      76:	bf 00       	.word	0x00bf	; ????
      78:	00 00       	nop
      7a:	80 3f       	cpi	r24, 0xF0	; 240
      7c:	08 00       	.word	0x0008	; ????
      7e:	00 00       	nop
      80:	be 92       	st	-X, r11
      82:	24 49       	sbci	r18, 0x94	; 148
      84:	12 3e       	cpi	r17, 0xE2	; 226
      86:	ab aa       	sts	0x9b, r26
      88:	aa 2a       	or	r10, r26
      8a:	be cd       	rjmp	.-1156   	; 0xfffffc08 <__eeprom_end+0xff7efc08>
      8c:	cc cc       	rjmp	.-1640   	; 0xfffffa26 <__eeprom_end+0xff7efa26>
      8e:	4c 3e       	cpi	r20, 0xEC	; 236
      90:	00 00       	nop
      92:	00 80       	ld	r0, Z
      94:	be ab       	sts	0x5e, r27
      96:	aa aa       	sts	0x9a, r26
      98:	aa 3e       	cpi	r26, 0xEA	; 234
      9a:	00 00       	nop
      9c:	00 00       	nop
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	00 00       	nop
      a6:	00 00       	nop
      a8:	00 08       	sbc	r0, r0
      aa:	41 78       	andi	r20, 0x81	; 129
      ac:	d3 bb       	out	0x13, r29	; 19
      ae:	43 87       	std	Z+11, r20	; 0x0b
      b0:	d1 13       	cpse	r29, r17
      b2:	3d 19       	sub	r19, r13
      b4:	0e 3c       	cpi	r16, 0xCE	; 206
      b6:	c3 bd       	out	0x23, r28	; 35
      b8:	42 82       	std	Z+2, r4	; 0x02
      ba:	ad 2b       	or	r26, r29
      bc:	3e 68       	ori	r19, 0x8E	; 142
      be:	ec 82       	std	Y+4, r14	; 0x04
      c0:	76 be       	out	0x36, r7	; 54
      c2:	d9 8f       	std	Y+25, r29	; 0x19
      c4:	e1 a9       	sts	0x41, r30
      c6:	3e 4c       	sbci	r19, 0xCE	; 206
      c8:	80 ef       	ldi	r24, 0xF0	; 240
      ca:	ff be       	out	0x3f, r15	; 63
      cc:	01 c4       	rjmp	.+2050   	; 0x8d0 <__stack+0x471>
      ce:	ff 7f       	andi	r31, 0xFF	; 255
      d0:	3f 00       	.word	0x003f	; ????
      d2:	00 00       	nop
	...

000000d6 <__ctors_end>:
      d6:	11 24       	eor	r1, r1
      d8:	1f be       	out	0x3f, r1	; 63
      da:	cf e5       	ldi	r28, 0x5F	; 95
      dc:	d4 e0       	ldi	r29, 0x04	; 4
      de:	de bf       	out	0x3e, r29	; 62
      e0:	cd bf       	out	0x3d, r28	; 61

000000e2 <__do_copy_data>:
      e2:	10 e0       	ldi	r17, 0x00	; 0
      e4:	a0 e6       	ldi	r26, 0x60	; 96
      e6:	b0 e0       	ldi	r27, 0x00	; 0
      e8:	ec e6       	ldi	r30, 0x6C	; 108
      ea:	f5 e3       	ldi	r31, 0x35	; 53
      ec:	02 c0       	rjmp	.+4      	; 0xf2 <__do_copy_data+0x10>
      ee:	05 90       	lpm	r0, Z+
      f0:	0d 92       	st	X+, r0
      f2:	ac 36       	cpi	r26, 0x6C	; 108
      f4:	b1 07       	cpc	r27, r17
      f6:	d9 f7       	brne	.-10     	; 0xee <__do_copy_data+0xc>

000000f8 <__do_clear_bss>:
      f8:	11 e0       	ldi	r17, 0x01	; 1
      fa:	ac e6       	ldi	r26, 0x6C	; 108
      fc:	b0 e0       	ldi	r27, 0x00	; 0
      fe:	01 c0       	rjmp	.+2      	; 0x102 <.do_clear_bss_start>

00000100 <.do_clear_bss_loop>:
     100:	1d 92       	st	X+, r1

00000102 <.do_clear_bss_start>:
     102:	ad 31       	cpi	r26, 0x1D	; 29
     104:	b1 07       	cpc	r27, r17
     106:	e1 f7       	brne	.-8      	; 0x100 <.do_clear_bss_loop>
     108:	0e 94 d2 13 	call	0x27a4	; 0x27a4 <main>
     10c:	0c 94 b4 1a 	jmp	0x3568	; 0x3568 <_exit>

00000110 <__bad_interrupt>:
     110:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000114 <velocity>:
  * Example Call: velocity(70,70)
  */ 

void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR1AH = 0x00;
     114:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = left_motor;
     116:	8a bd       	out	0x2a, r24	; 42
	OCR1BH = 0x00;
     118:	19 bc       	out	0x29, r1	; 41
	OCR1BL = right_motor;
     11a:	68 bd       	out	0x28, r22	; 40
}
     11c:	08 95       	ret

0000011e <update_curr_pos>:
  * Example Call: update_curr_pos()
  */

void update_curr_pos()
{
	if(orient==0)        curr_pos-=7;
     11e:	80 91 f8 00 	lds	r24, 0x00F8
     122:	90 91 f9 00 	lds	r25, 0x00F9
     126:	00 97       	sbiw	r24, 0x00	; 0
     128:	51 f4       	brne	.+20     	; 0x13e <update_curr_pos+0x20>
     12a:	80 91 b4 00 	lds	r24, 0x00B4
     12e:	90 91 b5 00 	lds	r25, 0x00B5
     132:	07 97       	sbiw	r24, 0x07	; 7
     134:	90 93 b5 00 	sts	0x00B5, r25
     138:	80 93 b4 00 	sts	0x00B4, r24
     13c:	08 95       	ret
	else if(orient==1)   curr_pos+=1;
     13e:	80 91 f8 00 	lds	r24, 0x00F8
     142:	90 91 f9 00 	lds	r25, 0x00F9
     146:	81 30       	cpi	r24, 0x01	; 1
     148:	91 05       	cpc	r25, r1
     14a:	51 f4       	brne	.+20     	; 0x160 <update_curr_pos+0x42>
     14c:	80 91 b4 00 	lds	r24, 0x00B4
     150:	90 91 b5 00 	lds	r25, 0x00B5
     154:	01 96       	adiw	r24, 0x01	; 1
     156:	90 93 b5 00 	sts	0x00B5, r25
     15a:	80 93 b4 00 	sts	0x00B4, r24
     15e:	08 95       	ret
	else if(orient==2)   curr_pos+=7;
     160:	80 91 f8 00 	lds	r24, 0x00F8
     164:	90 91 f9 00 	lds	r25, 0x00F9
     168:	82 30       	cpi	r24, 0x02	; 2
     16a:	91 05       	cpc	r25, r1
     16c:	51 f4       	brne	.+20     	; 0x182 <update_curr_pos+0x64>
     16e:	80 91 b4 00 	lds	r24, 0x00B4
     172:	90 91 b5 00 	lds	r25, 0x00B5
     176:	07 96       	adiw	r24, 0x07	; 7
     178:	90 93 b5 00 	sts	0x00B5, r25
     17c:	80 93 b4 00 	sts	0x00B4, r24
     180:	08 95       	ret
	else if(orient==3)   curr_pos-=1;
     182:	80 91 f8 00 	lds	r24, 0x00F8
     186:	90 91 f9 00 	lds	r25, 0x00F9
     18a:	83 30       	cpi	r24, 0x03	; 3
     18c:	91 05       	cpc	r25, r1
     18e:	49 f4       	brne	.+18     	; 0x1a2 <update_curr_pos+0x84>
     190:	80 91 b4 00 	lds	r24, 0x00B4
     194:	90 91 b5 00 	lds	r25, 0x00B5
     198:	01 97       	sbiw	r24, 0x01	; 1
     19a:	90 93 b5 00 	sts	0x00B5, r25
     19e:	80 93 b4 00 	sts	0x00B4, r24
     1a2:	08 95       	ret

000001a4 <all_bot_clear>:
  * Example Call: all_bot_clear()
  */

void all_bot_clear()
{
   home_bit[0]=0;
     1a4:	10 92 a5 00 	sts	0x00A5, r1
     1a8:	10 92 a4 00 	sts	0x00A4, r1
   home_bit[1]=0;
     1ac:	10 92 a7 00 	sts	0x00A7, r1
     1b0:	10 92 a6 00 	sts	0x00A6, r1
   home_bit[2]=0;	
     1b4:	10 92 a9 00 	sts	0x00A9, r1
     1b8:	10 92 a8 00 	sts	0x00A8, r1
}
     1bc:	08 95       	ret

000001be <all_xbee_clear>:
void all_xbee_clear()
{
	green_xbee_flag = 0;
     1be:	10 92 89 00 	sts	0x0089, r1
     1c2:	10 92 88 00 	sts	0x0088, r1
	blue_xbee_flag = 0;
     1c6:	10 92 8b 00 	sts	0x008B, r1
     1ca:	10 92 8a 00 	sts	0x008A, r1
}
     1ce:	08 95       	ret

000001d0 <shiftr>:
  * Logic: This function is used to shift the elements of initiial_home_run[] array to introduce the position behind the start position of the bot
  * Example Call: shiftr(26)
  */ 

void shiftr(int b)
{
     1d0:	cf 93       	push	r28
     1d2:	df 93       	push	r29
     1d4:	ec 01       	movw	r28, r24
    int i,n;
    i=node_count;
     1d6:	20 91 96 00 	lds	r18, 0x0096
     1da:	30 91 97 00 	lds	r19, 0x0097
    n=node_count-1;
     1de:	40 91 96 00 	lds	r20, 0x0096
     1e2:	50 91 97 00 	lds	r21, 0x0097
    while(i>0)
     1e6:	12 16       	cp	r1, r18
     1e8:	13 06       	cpc	r1, r19
     1ea:	c4 f4       	brge	.+48     	; 0x21c <shiftr+0x4c>

void shiftr(int b)
{
    int i,n;
    i=node_count;
    n=node_count-1;
     1ec:	41 50       	subi	r20, 0x01	; 1
     1ee:	50 40       	sbci	r21, 0x00	; 0
    while(i>0)
    {  
		initial_home_run[i] = initial_home_run[n] ;
     1f0:	ad eb       	ldi	r26, 0xBD	; 189
     1f2:	b0 e0       	ldi	r27, 0x00	; 0
     1f4:	fa 01       	movw	r30, r20
     1f6:	ee 0f       	add	r30, r30
     1f8:	ff 1f       	adc	r31, r31
     1fa:	ea 0f       	add	r30, r26
     1fc:	fb 1f       	adc	r31, r27
     1fe:	60 81       	ld	r22, Z
     200:	71 81       	ldd	r23, Z+1	; 0x01
     202:	c9 01       	movw	r24, r18
     204:	88 0f       	add	r24, r24
     206:	99 1f       	adc	r25, r25
     208:	8a 0f       	add	r24, r26
     20a:	9b 1f       	adc	r25, r27
     20c:	fc 01       	movw	r30, r24
     20e:	71 83       	std	Z+1, r23	; 0x01
     210:	60 83       	st	Z, r22
		--n;
     212:	41 50       	subi	r20, 0x01	; 1
     214:	50 40       	sbci	r21, 0x00	; 0
		--i;
     216:	21 50       	subi	r18, 0x01	; 1
     218:	30 40       	sbci	r19, 0x00	; 0
void shiftr(int b)
{
    int i,n;
    i=node_count;
    n=node_count-1;
    while(i>0)
     21a:	61 f7       	brne	.-40     	; 0x1f4 <shiftr+0x24>
    {  
		initial_home_run[i] = initial_home_run[n] ;
		--n;
		--i;
	}		
    initial_home_run[0]=b ;
     21c:	d0 93 be 00 	sts	0x00BE, r29
     220:	c0 93 bd 00 	sts	0x00BD, r28
}
     224:	df 91       	pop	r29
     226:	cf 91       	pop	r28
     228:	08 95       	ret

0000022a <just_forward>:

void just_forward()
{
	//stop();
	//_delay_ms(500);
	forward();
     22a:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <forward>
	velocity(27,27);
     22e:	8b e1       	ldi	r24, 0x1B	; 27
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	6b e1       	ldi	r22, 0x1B	; 27
     234:	70 e0       	ldi	r23, 0x00	; 0
     236:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     23a:	8f ef       	ldi	r24, 0xFF	; 255
     23c:	9f e3       	ldi	r25, 0x3F	; 63
     23e:	a4 e1       	ldi	r26, 0x14	; 20
     240:	81 50       	subi	r24, 0x01	; 1
     242:	90 40       	sbci	r25, 0x00	; 0
     244:	a0 40       	sbci	r26, 0x00	; 0
     246:	e1 f7       	brne	.-8      	; 0x240 <just_forward+0x16>
     248:	00 c0       	rjmp	.+0      	; 0x24a <just_forward+0x20>
     24a:	00 00       	nop
	_delay_ms(900);
	
}
     24c:	08 95       	ret

0000024e <turn_right>:
void turn_right()
{
	//stop();
	//_delay_ms(500);
	forward();
     24e:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <forward>
	velocity(27,27);
     252:	8b e1       	ldi	r24, 0x1B	; 27
     254:	90 e0       	ldi	r25, 0x00	; 0
     256:	6b e1       	ldi	r22, 0x1B	; 27
     258:	70 e0       	ldi	r23, 0x00	; 0
     25a:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>
     25e:	8f ef       	ldi	r24, 0xFF	; 255
     260:	9f e3       	ldi	r25, 0x3F	; 63
     262:	a4 e1       	ldi	r26, 0x14	; 20
     264:	81 50       	subi	r24, 0x01	; 1
     266:	90 40       	sbci	r25, 0x00	; 0
     268:	a0 40       	sbci	r26, 0x00	; 0
     26a:	e1 f7       	brne	.-8      	; 0x264 <turn_right+0x16>
     26c:	00 c0       	rjmp	.+0      	; 0x26e <turn_right+0x20>
     26e:	00 00       	nop
	_delay_ms(900);
	turn(1);
     270:	81 e0       	ldi	r24, 0x01	; 1
     272:	90 e0       	ldi	r25, 0x00	; 0
     274:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <turn>
}
     278:	08 95       	ret

0000027a <turn_left>:
}
void turn_left()
{
	//stop();
	//_delay_ms(500);
	forward();
     27a:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <forward>
	velocity(27,27);
     27e:	8b e1       	ldi	r24, 0x1B	; 27
     280:	90 e0       	ldi	r25, 0x00	; 0
     282:	6b e1       	ldi	r22, 0x1B	; 27
     284:	70 e0       	ldi	r23, 0x00	; 0
     286:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>
     28a:	8f ef       	ldi	r24, 0xFF	; 255
     28c:	9f e3       	ldi	r25, 0x3F	; 63
     28e:	a4 e1       	ldi	r26, 0x14	; 20
     290:	81 50       	subi	r24, 0x01	; 1
     292:	90 40       	sbci	r25, 0x00	; 0
     294:	a0 40       	sbci	r26, 0x00	; 0
     296:	e1 f7       	brne	.-8      	; 0x290 <turn_left+0x16>
     298:	00 c0       	rjmp	.+0      	; 0x29a <turn_left+0x20>
     29a:	00 00       	nop
	_delay_ms(900);
	//left();
	//_delay_ms(1700);
	turn(0);
     29c:	80 e0       	ldi	r24, 0x00	; 0
     29e:	90 e0       	ldi	r25, 0x00	; 0
     2a0:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <turn>
}
     2a4:	08 95       	ret

000002a6 <turn_reverse>:

void turn_reverse()
{
	//stop();
	//_delay_ms(500);
	forward();
     2a6:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <forward>
	velocity(29,30);
     2aa:	8d e1       	ldi	r24, 0x1D	; 29
     2ac:	90 e0       	ldi	r25, 0x00	; 0
     2ae:	6e e1       	ldi	r22, 0x1E	; 30
     2b0:	70 e0       	ldi	r23, 0x00	; 0
     2b2:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>
     2b6:	8f ef       	ldi	r24, 0xFF	; 255
     2b8:	9f ef       	ldi	r25, 0xFF	; 255
     2ba:	a8 e0       	ldi	r26, 0x08	; 8
     2bc:	81 50       	subi	r24, 0x01	; 1
     2be:	90 40       	sbci	r25, 0x00	; 0
     2c0:	a0 40       	sbci	r26, 0x00	; 0
     2c2:	e1 f7       	brne	.-8      	; 0x2bc <turn_reverse+0x16>
     2c4:	00 c0       	rjmp	.+0      	; 0x2c6 <turn_reverse+0x20>
     2c6:	00 00       	nop
	_delay_ms(400);
	//right();
	//_delay_ms(3450);
	turn(2);
     2c8:	82 e0       	ldi	r24, 0x02	; 2
     2ca:	90 e0       	ldi	r25, 0x00	; 0
     2cc:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <turn>
}
     2d0:	08 95       	ret

000002d2 <rgb_led_pin_config>:
  * Example Call: rgb_led_pin_config()
  */

void rgb_led_pin_config(void)
{
	DDRC = DDRC | 0x07;
     2d2:	84 b3       	in	r24, 0x14	; 20
     2d4:	87 60       	ori	r24, 0x07	; 7
     2d6:	84 bb       	out	0x14, r24	; 20
	PORTC = PORTC & 0xF8;
     2d8:	85 b3       	in	r24, 0x15	; 21
     2da:	88 7f       	andi	r24, 0xF8	; 248
     2dc:	85 bb       	out	0x15, r24	; 21
}
     2de:	08 95       	ret

000002e0 <color_sensor_pin_config>:
  * Example Call: color_sensor_pin_config()
  */ 

void color_sensor_pin_config(void)
{
	DDRC  = DDRC | 0xFF; // CONFIGURING PINC 4-7 PINS AS OUTPUT FOR S0,S1,S2,S3.
     2e0:	84 b3       	in	r24, 0x14	; 20
     2e2:	8f ef       	ldi	r24, 0xFF	; 255
     2e4:	84 bb       	out	0x14, r24	; 20
	PORTC = PORTC | 0x00;// INITIALLY SET TO ZERO AS IN FIREBIRD V CODE
     2e6:	85 b3       	in	r24, 0x15	; 21
     2e8:	85 bb       	out	0x15, r24	; 21
	DDRD= DDRD | 0x32; // PIND6 CONFIGURED AS OUT OF COLOR SENSOR WHILE OTHERS ARE KEPT AT THEIR DEFAULT VALUES
     2ea:	81 b3       	in	r24, 0x11	; 17
     2ec:	82 63       	ori	r24, 0x32	; 50
     2ee:	81 bb       	out	0x11, r24	; 17
}
     2f0:	08 95       	ret

000002f2 <adc_pin_config>:
  * Example Call: adc_pin_config()
  */

void adc_pin_config (void)
{
	DDRA = 0x00;   //set PORTA direction as input
     2f2:	1a ba       	out	0x1a, r1	; 26
	PORTA = 0x00;  //set PORTA pins floating
     2f4:	1b ba       	out	0x1b, r1	; 27
}
     2f6:	08 95       	ret

000002f8 <timer1_init>:
  * Example Call: timer1_init()
  */

void timer1_init(void)
{
	TCCR1B = 0x00; //stop
     2f8:	1e bc       	out	0x2e, r1	; 46
	TCNT1H = 0xFF; //setup
     2fa:	8f ef       	ldi	r24, 0xFF	; 255
     2fc:	8d bd       	out	0x2d, r24	; 45
	TCNT1L = 0x01;
     2fe:	91 e0       	ldi	r25, 0x01	; 1
     300:	9c bd       	out	0x2c, r25	; 44
	OCR1AH = 0x00;
     302:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0xFF;
     304:	8a bd       	out	0x2a, r24	; 42
	OCR1BH = 0x00;
     306:	19 bc       	out	0x29, r1	; 41
	OCR1BL = 0xFF;
     308:	88 bd       	out	0x28, r24	; 40
	ICR1H  = 0x00;
     30a:	17 bc       	out	0x27, r1	; 39
	ICR1L  = 0xFF;
     30c:	86 bd       	out	0x26, r24	; 38
	TCCR1A = 0xA1;
     30e:	81 ea       	ldi	r24, 0xA1	; 161
     310:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0x0D; //start Timer
     312:	8d e0       	ldi	r24, 0x0D	; 13
     314:	8e bd       	out	0x2e, r24	; 46
}
     316:	08 95       	ret

00000318 <set_servo>:
  * Example Call: set_servo()
  */ 

void set_servo()
{
	DDRD  = DDRD | 0X80;
     318:	8f 9a       	sbi	0x11, 7	; 17
	TCCR0 = 0X02;
     31a:	82 e0       	ldi	r24, 0x02	; 2
     31c:	83 bf       	out	0x33, r24	; 51
	TCNT0 = 0XEB;
     31e:	8b ee       	ldi	r24, 0xEB	; 235
     320:	82 bf       	out	0x32, r24	; 50
	TIMSK = 0X01;
     322:	81 e0       	ldi	r24, 0x01	; 1
     324:	89 bf       	out	0x39, r24	; 57
}
     326:	08 95       	ret

00000328 <adc_init>:
  * Example Call: adc_init()
  */

void adc_init()
{
	ADCSRA = 0x00;
     328:	16 b8       	out	0x06, r1	; 6
	ADMUX = 0x20;
     32a:	80 e2       	ldi	r24, 0x20	; 32
     32c:	87 b9       	out	0x07, r24	; 7
	ACSR = 0x80;
     32e:	80 e8       	ldi	r24, 0x80	; 128
     330:	88 b9       	out	0x08, r24	; 8
	ADCSRA = 0x86;
     332:	86 e8       	ldi	r24, 0x86	; 134
     334:	86 b9       	out	0x06, r24	; 6
}
     336:	08 95       	ret

00000338 <motion_pin_config>:
  * Example Call: motion_pin_config()
  */ 

void motion_pin_config (void)
{
	DDRB = DDRB | 0x0F;   //set direction of the PORTB3 to PORTB0 pins as output
     338:	87 b3       	in	r24, 0x17	; 23
     33a:	8f 60       	ori	r24, 0x0F	; 15
     33c:	87 bb       	out	0x17, r24	; 23
	PORTB = PORTB & 0xF0; // set initial value of the PORTB3 to PORTB0 pins to logic 0
     33e:	88 b3       	in	r24, 0x18	; 24
     340:	80 7f       	andi	r24, 0xF0	; 240
     342:	88 bb       	out	0x18, r24	; 24
	DDRD = DDRD | 0x30;   //Setting PD4 and PD5 pins as output for PWM generation
     344:	81 b3       	in	r24, 0x11	; 17
     346:	80 63       	ori	r24, 0x30	; 48
     348:	81 bb       	out	0x11, r24	; 17
	PORTD = PORTD | 0x30; //PD4 and PD5 pins are for velocity control using PWM
     34a:	82 b3       	in	r24, 0x12	; 18
     34c:	80 63       	ori	r24, 0x30	; 48
     34e:	82 bb       	out	0x12, r24	; 18
}
     350:	08 95       	ret

00000352 <uart0_init>:
  * Example Call: uart0_init()
  */

void uart0_init()
{
	UCSRB = 0x00; //disable while setting baud rate
     352:	1a b8       	out	0x0a, r1	; 10
	UCSRA = 0x00;
     354:	1b b8       	out	0x0b, r1	; 11
	UCSRC = 0x86;
     356:	86 e8       	ldi	r24, 0x86	; 134
     358:	80 bd       	out	0x20, r24	; 32
	UBRRL = 0x2F; //set baud rate lo  //67 is for 16MHz 9600 baudrate
     35a:	8f e2       	ldi	r24, 0x2F	; 47
     35c:	89 b9       	out	0x09, r24	; 9
	UBRRH = 0x00; //set baud rate hi
     35e:	10 bc       	out	0x20, r1	; 32
	UCSRB = 0x98;
     360:	88 e9       	ldi	r24, 0x98	; 152
     362:	8a b9       	out	0x0a, r24	; 10
}
     364:	08 95       	ret

00000366 <left_encoder_pin_config>:
* Example Call: left_encoder_pin_config()
*/

 void left_encoder_pin_config(void)
{
	DDRD = DDRD & 0xFB;
     366:	8a 98       	cbi	0x11, 2	; 17
	PORTD = PORTD | 0x04;
     368:	92 9a       	sbi	0x12, 2	; 18
}
     36a:	08 95       	ret

0000036c <right_encoder_pin_config>:
* Example Call: right_encoder_pin_config()
*/

void right_encoder_pin_config(void)
 {
	 DDRD = DDRD & 0xF7;
     36c:	8b 98       	cbi	0x11, 3	; 17
	 PORTD = PORTD | 0x08;
     36e:	93 9a       	sbi	0x12, 3	; 18
 }
     370:	08 95       	ret

00000372 <buzzer_pin_config>:
  * Example Call: buzzer_pin_config()
  */ 

void buzzer_pin_config (void)
{
	DDRC = DDRC | 0x08;		//Setting PORTC 3 as output
     372:	a3 9a       	sbi	0x14, 3	; 20
	PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
     374:	ab 98       	cbi	0x15, 3	; 21
}
     376:	08 95       	ret

00000378 <right_position_encoder_interrupt_init>:
* Example Call: right_position_encoder_interrupt_init()
*/

void right_position_encoder_interrupt_init(void)
{
	MCUCR = MCUCR | 0x08;
     378:	85 b7       	in	r24, 0x35	; 53
     37a:	88 60       	ori	r24, 0x08	; 8
     37c:	85 bf       	out	0x35, r24	; 53
	GICR = GICR | 0x80;
     37e:	8b b7       	in	r24, 0x3b	; 59
     380:	80 68       	ori	r24, 0x80	; 128
     382:	8b bf       	out	0x3b, r24	; 59
}
     384:	08 95       	ret

00000386 <left_position_encoder_interrupt_init>:
* Example Call: right_position_encoder_interrupt_init()
*/

void left_position_encoder_interrupt_init(void)
{
	MCUCR = MCUCR | 0x02;
     386:	85 b7       	in	r24, 0x35	; 53
     388:	82 60       	ori	r24, 0x02	; 2
     38a:	85 bf       	out	0x35, r24	; 53
	GICR = GICR | 0x40;
     38c:	8b b7       	in	r24, 0x3b	; 59
     38e:	80 64       	ori	r24, 0x40	; 64
     390:	8b bf       	out	0x3b, r24	; 59
}
     392:	08 95       	ret

00000394 <lcd_port_config>:

void lcd_port_config (void)
{
	DDRC = DDRC | 0xF7;    //all the LCD pin's direction set as output
     394:	84 b3       	in	r24, 0x14	; 20
     396:	87 6f       	ori	r24, 0xF7	; 247
     398:	84 bb       	out	0x14, r24	; 20
	PORTC = PORTC & 0x80;  // all the LCD pins are set to logic 0 except PORTC 7
     39a:	85 b3       	in	r24, 0x15	; 21
     39c:	80 78       	andi	r24, 0x80	; 128
     39e:	85 bb       	out	0x15, r24	; 21
}
     3a0:	08 95       	ret

000003a2 <port_init>:
  * Example Call: port_init()
  */

void port_init(void)
{
	 motion_pin_config();
     3a2:	0e 94 9c 01 	call	0x338	; 0x338 <motion_pin_config>
	 buzzer_pin_config();
     3a6:	0e 94 b9 01 	call	0x372	; 0x372 <buzzer_pin_config>
	 uart0_init();
     3aa:	0e 94 a9 01 	call	0x352	; 0x352 <uart0_init>
	 left_encoder_pin_config();
     3ae:	0e 94 b3 01 	call	0x366	; 0x366 <left_encoder_pin_config>
	 right_encoder_pin_config();
     3b2:	0e 94 b6 01 	call	0x36c	; 0x36c <right_encoder_pin_config>
	 adc_pin_config();
     3b6:	0e 94 79 01 	call	0x2f2	; 0x2f2 <adc_pin_config>
	 color_sensor_pin_config();
     3ba:	0e 94 70 01 	call	0x2e0	; 0x2e0 <color_sensor_pin_config>
	 rgb_led_pin_config();
     3be:	0e 94 69 01 	call	0x2d2	; 0x2d2 <rgb_led_pin_config>
}
     3c2:	08 95       	ret

000003c4 <init_devices>:
  * Example Call: init_devices()
  */ 

void init_devices (void)
{
	cli(); //Clears the global interrupts
     3c4:	f8 94       	cli
	port_init();
     3c6:	0e 94 d1 01 	call	0x3a2	; 0x3a2 <port_init>
	timer1_init();
     3ca:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <timer1_init>
	adc_init();
     3ce:	0e 94 94 01 	call	0x328	; 0x328 <adc_init>
	left_position_encoder_interrupt_init();
     3d2:	0e 94 c3 01 	call	0x386	; 0x386 <left_position_encoder_interrupt_init>
	right_position_encoder_interrupt_init();
     3d6:	0e 94 bc 01 	call	0x378	; 0x378 <right_position_encoder_interrupt_init>
	set_servo();
     3da:	0e 94 8c 01 	call	0x318	; 0x318 <set_servo>
	sei(); //Enables the global interrupts
     3de:	78 94       	sei
}
     3e0:	08 95       	ret

000003e2 <ADC_Conversion>:
  */

unsigned char ADC_Conversion(unsigned char Ch)
{
	unsigned char a;
	Ch = Ch & 0x07;
     3e2:	87 70       	andi	r24, 0x07	; 7
	ADMUX= 0x20| Ch;
     3e4:	80 62       	ori	r24, 0x20	; 32
     3e6:	87 b9       	out	0x07, r24	; 7
	ADCSRA = ADCSRA | 0x40;	//Set start conversion bit
     3e8:	36 9a       	sbi	0x06, 6	; 6
	while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
     3ea:	34 9b       	sbis	0x06, 4	; 6
     3ec:	fe cf       	rjmp	.-4      	; 0x3ea <ADC_Conversion+0x8>
	a=ADCH;
     3ee:	85 b1       	in	r24, 0x05	; 5
	ADCSRA = ADCSRA|0x10;      //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     3f0:	34 9a       	sbi	0x06, 4	; 6
	return a;
}
     3f2:	08 95       	ret

000003f4 <buzzer_on>:
  */

void buzzer_on (void)
{
	unsigned char port_restore = 0;
	port_restore = PINC;
     3f4:	83 b3       	in	r24, 0x13	; 19
	port_restore = port_restore | 0x08;
     3f6:	88 60       	ori	r24, 0x08	; 8
	PORTC = port_restore;
     3f8:	85 bb       	out	0x15, r24	; 21
}
     3fa:	08 95       	ret

000003fc <buzzer_off>:
  */

void buzzer_off (void)
{
	unsigned char port_restore = 0;
	port_restore = PINC;
     3fc:	83 b3       	in	r24, 0x13	; 19
	port_restore = port_restore & 0xF7;
     3fe:	87 7f       	andi	r24, 0xF7	; 247
	PORTC = port_restore;
     400:	85 bb       	out	0x15, r24	; 21
}
     402:	08 95       	ret

00000404 <buzz>:
  * Example Call: buzz()
  */

void buzz()
{
	buzzer_on();
     404:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <buzzer_on>
     408:	8f ef       	ldi	r24, 0xFF	; 255
     40a:	9f e3       	ldi	r25, 0x3F	; 63
     40c:	a2 e0       	ldi	r26, 0x02	; 2
     40e:	81 50       	subi	r24, 0x01	; 1
     410:	90 40       	sbci	r25, 0x00	; 0
     412:	a0 40       	sbci	r26, 0x00	; 0
     414:	e1 f7       	brne	.-8      	; 0x40e <buzz+0xa>
     416:	00 c0       	rjmp	.+0      	; 0x418 <buzz+0x14>
     418:	00 00       	nop
	_delay_ms(100);
	buzzer_off();
     41a:	0e 94 fe 01 	call	0x3fc	; 0x3fc <buzzer_off>
}
     41e:	08 95       	ret

00000420 <run_home>:
  * Logic: This function is used for following the Dijkstra path sent over xbee by firebird V.
  * Example Call: run_home()
  */

void run_home()
{
     420:	2f 92       	push	r2
     422:	3f 92       	push	r3
     424:	4f 92       	push	r4
     426:	5f 92       	push	r5
     428:	6f 92       	push	r6
     42a:	7f 92       	push	r7
     42c:	8f 92       	push	r8
     42e:	9f 92       	push	r9
     430:	af 92       	push	r10
     432:	bf 92       	push	r11
     434:	cf 92       	push	r12
     436:	df 92       	push	r13
     438:	ef 92       	push	r14
     43a:	ff 92       	push	r15
     43c:	0f 93       	push	r16
     43e:	1f 93       	push	r17
     440:	cf 93       	push	r28
     442:	df 93       	push	r29
     444:	cd b7       	in	r28, 0x3d	; 61
     446:	de b7       	in	r29, 0x3e	; 62
     448:	28 97       	sbiw	r28, 0x08	; 8
     44a:	0f b6       	in	r0, 0x3f	; 63
     44c:	f8 94       	cli
     44e:	de bf       	out	0x3e, r29	; 62
     450:	0f be       	out	0x3f, r0	; 63
     452:	cd bf       	out	0x3d, r28	; 61
	int temp;
	if(orient==0)
     454:	80 91 f8 00 	lds	r24, 0x00F8
     458:	90 91 f9 00 	lds	r25, 0x00F9
     45c:	00 97       	sbiw	r24, 0x00	; 0
     45e:	39 f4       	brne	.+14     	; 0x46e <__stack+0xf>
	temp=initial_home_run[0]+7;
     460:	00 91 bd 00 	lds	r16, 0x00BD
     464:	10 91 be 00 	lds	r17, 0x00BE
     468:	09 5f       	subi	r16, 0xF9	; 249
     46a:	1f 4f       	sbci	r17, 0xFF	; 255
     46c:	29 c0       	rjmp	.+82     	; 0x4c0 <__stack+0x61>
	else if(orient==1)
     46e:	80 91 f8 00 	lds	r24, 0x00F8
     472:	90 91 f9 00 	lds	r25, 0x00F9
     476:	81 30       	cpi	r24, 0x01	; 1
     478:	91 05       	cpc	r25, r1
     47a:	39 f4       	brne	.+14     	; 0x48a <__stack+0x2b>
	temp=initial_home_run[0]-1;
     47c:	00 91 bd 00 	lds	r16, 0x00BD
     480:	10 91 be 00 	lds	r17, 0x00BE
     484:	01 50       	subi	r16, 0x01	; 1
     486:	10 40       	sbci	r17, 0x00	; 0
     488:	1b c0       	rjmp	.+54     	; 0x4c0 <__stack+0x61>
	else if(orient==2)
     48a:	80 91 f8 00 	lds	r24, 0x00F8
     48e:	90 91 f9 00 	lds	r25, 0x00F9
     492:	82 30       	cpi	r24, 0x02	; 2
     494:	91 05       	cpc	r25, r1
     496:	39 f4       	brne	.+14     	; 0x4a6 <__stack+0x47>
	temp=initial_home_run[0]-7;
     498:	00 91 bd 00 	lds	r16, 0x00BD
     49c:	10 91 be 00 	lds	r17, 0x00BE
     4a0:	07 50       	subi	r16, 0x07	; 7
     4a2:	10 40       	sbci	r17, 0x00	; 0
     4a4:	0d c0       	rjmp	.+26     	; 0x4c0 <__stack+0x61>
	else if(orient==3)
     4a6:	80 91 f8 00 	lds	r24, 0x00F8
     4aa:	90 91 f9 00 	lds	r25, 0x00F9
     4ae:	83 30       	cpi	r24, 0x03	; 3
     4b0:	91 05       	cpc	r25, r1
     4b2:	31 f4       	brne	.+12     	; 0x4c0 <__stack+0x61>
	temp=initial_home_run[0]+1;
     4b4:	00 91 bd 00 	lds	r16, 0x00BD
     4b8:	10 91 be 00 	lds	r17, 0x00BE
     4bc:	0f 5f       	subi	r16, 0xFF	; 255
     4be:	1f 4f       	sbci	r17, 0xFF	; 255
	
	shiftr(temp);
     4c0:	c8 01       	movw	r24, r16
     4c2:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <shiftr>
	curr_pos = temp;
     4c6:	10 93 b5 00 	sts	0x00B5, r17
     4ca:	00 93 b4 00 	sts	0x00B4, r16
	
	int prev,present,next,m;
	prev=initial_home_run[0];
     4ce:	20 91 bd 00 	lds	r18, 0x00BD
     4d2:	30 91 be 00 	lds	r19, 0x00BE
     4d6:	3e 83       	std	Y+6, r19	; 0x06
     4d8:	2d 83       	std	Y+5, r18	; 0x05
	present=initial_home_run[1];
     4da:	40 91 bf 00 	lds	r20, 0x00BF
     4de:	50 91 c0 00 	lds	r21, 0x00C0
     4e2:	5c 83       	std	Y+4, r21	; 0x04
     4e4:	4b 83       	std	Y+3, r20	; 0x03
	next=initial_home_run[2];
     4e6:	80 91 c1 00 	lds	r24, 0x00C1
     4ea:	90 91 c2 00 	lds	r25, 0x00C2
     4ee:	9a 83       	std	Y+2, r25	; 0x02
     4f0:	89 83       	std	Y+1, r24	; 0x01
	m=1;
     4f2:	66 24       	eor	r6, r6
     4f4:	77 24       	eor	r7, r7
     4f6:	63 94       	inc	r6
		present=initial_home_run[m];
		next=initial_home_run[m+1];
	}
	
	*/
	while(initial_home_run[m]!=99)
     4f8:	0f 2e       	mov	r0, r31
     4fa:	fd eb       	ldi	r31, 0xBD	; 189
     4fc:	4f 2e       	mov	r4, r31
     4fe:	f0 e0       	ldi	r31, 0x00	; 0
     500:	5f 2e       	mov	r5, r31
     502:	f0 2d       	mov	r31, r0
		if (rightMotorSpeed < 0) rightMotorSpeed = 0;
		if (leftMotorSpeed < 0) leftMotorSpeed = 0;
		

		forward();
		velocity(leftMotorSpeed,rightMotorSpeed);
     504:	22 24       	eor	r2, r2
     506:	33 24       	eor	r3, r3
		present=initial_home_run[m];
		next=initial_home_run[m+1];
	}
	
	*/
	while(initial_home_run[m]!=99)
     508:	c6 c1       	rjmp	.+908    	; 0x896 <__stack+0x437>
	{
		Left_white_line = ADC_Conversion(3);
     50a:	83 e0       	ldi	r24, 0x03	; 3
     50c:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     510:	80 93 79 00 	sts	0x0079, r24
		Center_white_line = ADC_Conversion(4);
     514:	84 e0       	ldi	r24, 0x04	; 4
     516:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     51a:	80 93 78 00 	sts	0x0078, r24
		Right_white_line = ADC_Conversion(5);
     51e:	85 e0       	ldi	r24, 0x05	; 5
     520:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     524:	80 93 77 00 	sts	0x0077, r24
		error = Right_white_line - Left_white_line;
     528:	90 e0       	ldi	r25, 0x00	; 0
     52a:	20 91 79 00 	lds	r18, 0x0079
     52e:	82 1b       	sub	r24, r18
     530:	91 09       	sbc	r25, r1
     532:	90 93 13 01 	sts	0x0113, r25
     536:	80 93 12 01 	sts	0x0112, r24
		int motorSpeed = Kp * error + Kd * (error - lastError);
     53a:	60 91 12 01 	lds	r22, 0x0112
     53e:	70 91 13 01 	lds	r23, 0x0113
     542:	c0 90 67 00 	lds	r12, 0x0067
     546:	d0 90 68 00 	lds	r13, 0x0068
     54a:	e0 90 69 00 	lds	r14, 0x0069
     54e:	f0 90 6a 00 	lds	r15, 0x006A
     552:	a0 91 12 01 	lds	r26, 0x0112
     556:	b0 91 13 01 	lds	r27, 0x0113
     55a:	b8 87       	std	Y+8, r27	; 0x08
     55c:	af 83       	std	Y+7, r26	; 0x07
     55e:	00 91 7a 00 	lds	r16, 0x007A
     562:	10 91 7b 00 	lds	r17, 0x007B
     566:	80 90 63 00 	lds	r8, 0x0063
     56a:	90 90 64 00 	lds	r9, 0x0064
     56e:	a0 90 65 00 	lds	r10, 0x0065
     572:	b0 90 66 00 	lds	r11, 0x0066
     576:	88 27       	eor	r24, r24
     578:	77 fd       	sbrc	r23, 7
     57a:	80 95       	com	r24
     57c:	98 2f       	mov	r25, r24
     57e:	0e 94 39 18 	call	0x3072	; 0x3072 <__floatsisf>
     582:	a7 01       	movw	r20, r14
     584:	96 01       	movw	r18, r12
     586:	0e 94 c5 18 	call	0x318a	; 0x318a <__mulsf3>
     58a:	6b 01       	movw	r12, r22
     58c:	7c 01       	movw	r14, r24
     58e:	6f 81       	ldd	r22, Y+7	; 0x07
     590:	78 85       	ldd	r23, Y+8	; 0x08
     592:	60 1b       	sub	r22, r16
     594:	71 0b       	sbc	r23, r17
     596:	88 27       	eor	r24, r24
     598:	77 fd       	sbrc	r23, 7
     59a:	80 95       	com	r24
     59c:	98 2f       	mov	r25, r24
     59e:	0e 94 39 18 	call	0x3072	; 0x3072 <__floatsisf>
     5a2:	a5 01       	movw	r20, r10
     5a4:	94 01       	movw	r18, r8
     5a6:	0e 94 c5 18 	call	0x318a	; 0x318a <__mulsf3>
     5aa:	9b 01       	movw	r18, r22
     5ac:	ac 01       	movw	r20, r24
     5ae:	c7 01       	movw	r24, r14
     5b0:	b6 01       	movw	r22, r12
     5b2:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <__addsf3>
     5b6:	0e 94 06 18 	call	0x300c	; 0x300c <__fixsfsi>
     5ba:	dc 01       	movw	r26, r24
     5bc:	cb 01       	movw	r24, r22
		lastError = error;
     5be:	20 91 12 01 	lds	r18, 0x0112
     5c2:	30 91 13 01 	lds	r19, 0x0113
     5c6:	30 93 7b 00 	sts	0x007B, r19
     5ca:	20 93 7a 00 	sts	0x007A, r18
		int rightMotorSpeed = rightBaseSpeed - motorSpeed;
     5ce:	00 91 62 00 	lds	r16, 0x0062
     5d2:	10 e0       	ldi	r17, 0x00	; 0
		int leftMotorSpeed = leftBaseSpeed + motorSpeed;
     5d4:	20 91 61 00 	lds	r18, 0x0061
     5d8:	6c 01       	movw	r12, r24
     5da:	c2 0e       	add	r12, r18
     5dc:	d1 1c       	adc	r13, r1
     5de:	08 1b       	sub	r16, r24
     5e0:	19 0b       	sbc	r17, r25
     5e2:	08 33       	cpi	r16, 0x38	; 56
     5e4:	11 05       	cpc	r17, r1
     5e6:	14 f0       	brlt	.+4      	; 0x5ec <__stack+0x18d>
     5e8:	07 e3       	ldi	r16, 0x37	; 55
     5ea:	10 e0       	ldi	r17, 0x00	; 0
     5ec:	b8 e3       	ldi	r27, 0x38	; 56
     5ee:	cb 16       	cp	r12, r27
     5f0:	d1 04       	cpc	r13, r1
     5f2:	2c f0       	brlt	.+10     	; 0x5fe <__stack+0x19f>
     5f4:	0f 2e       	mov	r0, r31
     5f6:	f7 e3       	ldi	r31, 0x37	; 55
     5f8:	cf 2e       	mov	r12, r31
     5fa:	dd 24       	eor	r13, r13
     5fc:	f0 2d       	mov	r31, r0
		if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
		if (rightMotorSpeed < 0) rightMotorSpeed = 0;
		if (leftMotorSpeed < 0) leftMotorSpeed = 0;
		

		forward();
     5fe:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <forward>
		velocity(leftMotorSpeed,rightMotorSpeed);
     602:	c6 01       	movw	r24, r12
     604:	99 23       	and	r25, r25
     606:	0c f4       	brge	.+2      	; 0x60a <__stack+0x1ab>
     608:	c1 01       	movw	r24, r2
     60a:	b8 01       	movw	r22, r16
     60c:	11 23       	and	r17, r17
     60e:	0c f4       	brge	.+2      	; 0x612 <__stack+0x1b3>
     610:	b1 01       	movw	r22, r2
     612:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>

		if(Center_white_line>100 && Left_white_line>100 && Right_white_line>100)
     616:	80 91 78 00 	lds	r24, 0x0078
     61a:	85 36       	cpi	r24, 0x65	; 101
     61c:	08 f4       	brcc	.+2      	; 0x620 <__stack+0x1c1>
     61e:	3b c1       	rjmp	.+630    	; 0x896 <__stack+0x437>
     620:	80 91 79 00 	lds	r24, 0x0079
     624:	85 36       	cpi	r24, 0x65	; 101
     626:	08 f4       	brcc	.+2      	; 0x62a <__stack+0x1cb>
     628:	36 c1       	rjmp	.+620    	; 0x896 <__stack+0x437>
     62a:	80 91 77 00 	lds	r24, 0x0077
     62e:	85 36       	cpi	r24, 0x65	; 101
     630:	08 f4       	brcc	.+2      	; 0x634 <__stack+0x1d5>
     632:	31 c1       	rjmp	.+610    	; 0x896 <__stack+0x437>
		{
			update_curr_pos();
     634:	0e 94 8f 00 	call	0x11e	; 0x11e <update_curr_pos>
			
			//velocity(40,40);
			//_delay_ms(300);
			
			stop();
     638:	0e 94 b9 0a 	call	0x1572	; 0x1572 <stop>
			buzz();
     63c:	0e 94 02 02 	call	0x404	; 0x404 <buzz>
			
			if(next==99)
     640:	e9 81       	ldd	r30, Y+1	; 0x01
     642:	fa 81       	ldd	r31, Y+2	; 0x02
     644:	e3 36       	cpi	r30, 0x63	; 99
     646:	f1 05       	cpc	r31, r1
     648:	09 f4       	brne	.+2      	; 0x64c <__stack+0x1ed>
     64a:	32 c1       	rjmp	.+612    	; 0x8b0 <__stack+0x451>
			{
				break;
			}
			
			if(next-present==1)
     64c:	cf 01       	movw	r24, r30
     64e:	2b 81       	ldd	r18, Y+3	; 0x03
     650:	3c 81       	ldd	r19, Y+4	; 0x04
     652:	82 1b       	sub	r24, r18
     654:	93 0b       	sbc	r25, r19
     656:	81 30       	cpi	r24, 0x01	; 1
     658:	91 05       	cpc	r25, r1
     65a:	09 f0       	breq	.+2      	; 0x65e <__stack+0x1ff>
     65c:	43 c0       	rjmp	.+134    	; 0x6e4 <__stack+0x285>
			{
				if(present-prev==1)
     65e:	89 01       	movw	r16, r18
     660:	4d 81       	ldd	r20, Y+5	; 0x05
     662:	5e 81       	ldd	r21, Y+6	; 0x06
     664:	04 1b       	sub	r16, r20
     666:	15 0b       	sbc	r17, r21
     668:	01 30       	cpi	r16, 0x01	; 1
     66a:	11 05       	cpc	r17, r1
     66c:	19 f4       	brne	.+6      	; 0x674 <__stack+0x215>
				//forward();
				just_forward();
     66e:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
     672:	0d c0       	rjmp	.+26     	; 0x68e <__stack+0x22f>
				if(present-prev==7)
     674:	07 30       	cpi	r16, 0x07	; 7
     676:	11 05       	cpc	r17, r1
     678:	19 f4       	brne	.+6      	; 0x680 <__stack+0x221>
				//turn(0);
				turn_left();
     67a:	0e 94 3d 01 	call	0x27a	; 0x27a <turn_left>
     67e:	0d c0       	rjmp	.+26     	; 0x69a <__stack+0x23b>
				if(present-prev==-7)
     680:	5f ef       	ldi	r21, 0xFF	; 255
     682:	09 3f       	cpi	r16, 0xF9	; 249
     684:	15 07       	cpc	r17, r21
     686:	19 f4       	brne	.+6      	; 0x68e <__stack+0x22f>
				//turn(1);
				turn_right();
     688:	0e 94 27 01 	call	0x24e	; 0x24e <turn_right>
     68c:	06 c0       	rjmp	.+12     	; 0x69a <__stack+0x23b>
				if(present-prev==-1)
     68e:	8f ef       	ldi	r24, 0xFF	; 255
     690:	0f 3f       	cpi	r16, 0xFF	; 255
     692:	18 07       	cpc	r17, r24
     694:	11 f4       	brne	.+4      	; 0x69a <__stack+0x23b>
				{
					//turn(1);
					//turn(1);
					turn_reverse();
     696:	0e 94 53 01 	call	0x2a6	; 0x2a6 <turn_reverse>
				}
				
				m++;
     69a:	93 01       	movw	r18, r6
     69c:	2f 5f       	subi	r18, 0xFF	; 255
     69e:	3f 4f       	sbci	r19, 0xFF	; 255
				prev=initial_home_run[m-1];
     6a0:	f3 01       	movw	r30, r6
     6a2:	ee 0f       	add	r30, r30
     6a4:	ff 1f       	adc	r31, r31
     6a6:	e4 0d       	add	r30, r4
     6a8:	f5 1d       	adc	r31, r5
     6aa:	a0 81       	ld	r26, Z
     6ac:	b1 81       	ldd	r27, Z+1	; 0x01
     6ae:	be 83       	std	Y+6, r27	; 0x06
     6b0:	ad 83       	std	Y+5, r26	; 0x05
				present=initial_home_run[m];
     6b2:	c9 01       	movw	r24, r18
     6b4:	88 0f       	add	r24, r24
     6b6:	99 1f       	adc	r25, r25
     6b8:	84 0d       	add	r24, r4
     6ba:	95 1d       	adc	r25, r5
     6bc:	fc 01       	movw	r30, r24
     6be:	01 90       	ld	r0, Z+
     6c0:	f0 81       	ld	r31, Z
     6c2:	e0 2d       	mov	r30, r0
     6c4:	fc 83       	std	Y+4, r31	; 0x04
     6c6:	eb 83       	std	Y+3, r30	; 0x03
				next=initial_home_run[m+1];
     6c8:	c3 01       	movw	r24, r6
     6ca:	02 96       	adiw	r24, 0x02	; 2
     6cc:	88 0f       	add	r24, r24
     6ce:	99 1f       	adc	r25, r25
     6d0:	84 0d       	add	r24, r4
     6d2:	95 1d       	adc	r25, r5
     6d4:	dc 01       	movw	r26, r24
     6d6:	0d 90       	ld	r0, X+
     6d8:	bc 91       	ld	r27, X
     6da:	a0 2d       	mov	r26, r0
     6dc:	ba 83       	std	Y+2, r27	; 0x02
     6de:	a9 83       	std	Y+1, r26	; 0x01
					//turn(1);
					//turn(1);
					turn_reverse();
				}
				
				m++;
     6e0:	39 01       	movw	r6, r18
     6e2:	d9 c0       	rjmp	.+434    	; 0x896 <__stack+0x437>
				prev=initial_home_run[m-1];
				present=initial_home_run[m];
				next=initial_home_run[m+1];
			}
			
			else if(next-present==7)
     6e4:	87 30       	cpi	r24, 0x07	; 7
     6e6:	91 05       	cpc	r25, r1
     6e8:	09 f0       	breq	.+2      	; 0x6ec <__stack+0x28d>
     6ea:	44 c0       	rjmp	.+136    	; 0x774 <__stack+0x315>
			{
				if(present-prev==7)
     6ec:	0b 81       	ldd	r16, Y+3	; 0x03
     6ee:	1c 81       	ldd	r17, Y+4	; 0x04
     6f0:	ed 81       	ldd	r30, Y+5	; 0x05
     6f2:	fe 81       	ldd	r31, Y+6	; 0x06
     6f4:	0e 1b       	sub	r16, r30
     6f6:	1f 0b       	sbc	r17, r31
     6f8:	07 30       	cpi	r16, 0x07	; 7
     6fa:	11 05       	cpc	r17, r1
     6fc:	19 f4       	brne	.+6      	; 0x704 <__stack+0x2a5>
				//forward();
				just_forward();
     6fe:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
     702:	0d c0       	rjmp	.+26     	; 0x71e <__stack+0x2bf>
				if(present-prev==-1)
     704:	ff ef       	ldi	r31, 0xFF	; 255
     706:	0f 3f       	cpi	r16, 0xFF	; 255
     708:	1f 07       	cpc	r17, r31
     70a:	19 f4       	brne	.+6      	; 0x712 <__stack+0x2b3>
				//turn(0);
				turn_left();
     70c:	0e 94 3d 01 	call	0x27a	; 0x27a <turn_left>
     710:	0c c0       	rjmp	.+24     	; 0x72a <__stack+0x2cb>
				if(present-prev==1)
     712:	01 30       	cpi	r16, 0x01	; 1
     714:	11 05       	cpc	r17, r1
     716:	19 f4       	brne	.+6      	; 0x71e <__stack+0x2bf>
				//turn(1);
				turn_right();
     718:	0e 94 27 01 	call	0x24e	; 0x24e <turn_right>
     71c:	06 c0       	rjmp	.+12     	; 0x72a <__stack+0x2cb>
				if(present-prev==-7)
     71e:	2f ef       	ldi	r18, 0xFF	; 255
     720:	09 3f       	cpi	r16, 0xF9	; 249
     722:	12 07       	cpc	r17, r18
     724:	11 f4       	brne	.+4      	; 0x72a <__stack+0x2cb>
				{
					//turn(1);
					//turn(1);
					turn_reverse();
     726:	0e 94 53 01 	call	0x2a6	; 0x2a6 <turn_reverse>
				}
				
				m++;
     72a:	93 01       	movw	r18, r6
     72c:	2f 5f       	subi	r18, 0xFF	; 255
     72e:	3f 4f       	sbci	r19, 0xFF	; 255
				prev=initial_home_run[m-1];
     730:	f3 01       	movw	r30, r6
     732:	ee 0f       	add	r30, r30
     734:	ff 1f       	adc	r31, r31
     736:	e4 0d       	add	r30, r4
     738:	f5 1d       	adc	r31, r5
     73a:	40 81       	ld	r20, Z
     73c:	51 81       	ldd	r21, Z+1	; 0x01
     73e:	5e 83       	std	Y+6, r21	; 0x06
     740:	4d 83       	std	Y+5, r20	; 0x05
				present=initial_home_run[m];
     742:	c9 01       	movw	r24, r18
     744:	88 0f       	add	r24, r24
     746:	99 1f       	adc	r25, r25
     748:	84 0d       	add	r24, r4
     74a:	95 1d       	adc	r25, r5
     74c:	dc 01       	movw	r26, r24
     74e:	0d 90       	ld	r0, X+
     750:	bc 91       	ld	r27, X
     752:	a0 2d       	mov	r26, r0
     754:	bc 83       	std	Y+4, r27	; 0x04
     756:	ab 83       	std	Y+3, r26	; 0x03
				next=initial_home_run[m+1];
     758:	c3 01       	movw	r24, r6
     75a:	02 96       	adiw	r24, 0x02	; 2
     75c:	88 0f       	add	r24, r24
     75e:	99 1f       	adc	r25, r25
     760:	84 0d       	add	r24, r4
     762:	95 1d       	adc	r25, r5
     764:	fc 01       	movw	r30, r24
     766:	01 90       	ld	r0, Z+
     768:	f0 81       	ld	r31, Z
     76a:	e0 2d       	mov	r30, r0
     76c:	fa 83       	std	Y+2, r31	; 0x02
     76e:	e9 83       	std	Y+1, r30	; 0x01
					//turn(1);
					//turn(1);
					turn_reverse();
				}
				
				m++;
     770:	39 01       	movw	r6, r18
     772:	91 c0       	rjmp	.+290    	; 0x896 <__stack+0x437>
				prev=initial_home_run[m-1];
				present=initial_home_run[m];
				next=initial_home_run[m+1];
			}
			
			else if(next-present==-7)
     774:	ff ef       	ldi	r31, 0xFF	; 255
     776:	89 3f       	cpi	r24, 0xF9	; 249
     778:	9f 07       	cpc	r25, r31
     77a:	09 f0       	breq	.+2      	; 0x77e <__stack+0x31f>
     77c:	44 c0       	rjmp	.+136    	; 0x806 <__stack+0x3a7>
			{
				if(present-prev==-7)
     77e:	0b 81       	ldd	r16, Y+3	; 0x03
     780:	1c 81       	ldd	r17, Y+4	; 0x04
     782:	2d 81       	ldd	r18, Y+5	; 0x05
     784:	3e 81       	ldd	r19, Y+6	; 0x06
     786:	02 1b       	sub	r16, r18
     788:	13 0b       	sbc	r17, r19
     78a:	3f ef       	ldi	r19, 0xFF	; 255
     78c:	09 3f       	cpi	r16, 0xF9	; 249
     78e:	13 07       	cpc	r17, r19
     790:	19 f4       	brne	.+6      	; 0x798 <__stack+0x339>
				//forward();
				just_forward();
     792:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
     796:	0d c0       	rjmp	.+26     	; 0x7b2 <__stack+0x353>
				if(present-prev==1)
     798:	01 30       	cpi	r16, 0x01	; 1
     79a:	11 05       	cpc	r17, r1
     79c:	19 f4       	brne	.+6      	; 0x7a4 <__stack+0x345>
				//turn(0);
				turn_left();
     79e:	0e 94 3d 01 	call	0x27a	; 0x27a <turn_left>
     7a2:	0c c0       	rjmp	.+24     	; 0x7bc <__stack+0x35d>
				if(present-prev==-1)
     7a4:	4f ef       	ldi	r20, 0xFF	; 255
     7a6:	0f 3f       	cpi	r16, 0xFF	; 255
     7a8:	14 07       	cpc	r17, r20
     7aa:	19 f4       	brne	.+6      	; 0x7b2 <__stack+0x353>
				//turn(1);
				turn_right();
     7ac:	0e 94 27 01 	call	0x24e	; 0x24e <turn_right>
     7b0:	05 c0       	rjmp	.+10     	; 0x7bc <__stack+0x35d>
				if(present-prev==7)
     7b2:	07 30       	cpi	r16, 0x07	; 7
     7b4:	11 05       	cpc	r17, r1
     7b6:	11 f4       	brne	.+4      	; 0x7bc <__stack+0x35d>
				{
					//turn(1);
					//turn(1);
					turn_reverse();
     7b8:	0e 94 53 01 	call	0x2a6	; 0x2a6 <turn_reverse>
				}
				
				m=m+1;
     7bc:	93 01       	movw	r18, r6
     7be:	2f 5f       	subi	r18, 0xFF	; 255
     7c0:	3f 4f       	sbci	r19, 0xFF	; 255
				prev=initial_home_run[m-1];
     7c2:	f3 01       	movw	r30, r6
     7c4:	ee 0f       	add	r30, r30
     7c6:	ff 1f       	adc	r31, r31
     7c8:	e4 0d       	add	r30, r4
     7ca:	f5 1d       	adc	r31, r5
     7cc:	80 81       	ld	r24, Z
     7ce:	91 81       	ldd	r25, Z+1	; 0x01
     7d0:	9e 83       	std	Y+6, r25	; 0x06
     7d2:	8d 83       	std	Y+5, r24	; 0x05
				present=initial_home_run[m];
     7d4:	c9 01       	movw	r24, r18
     7d6:	88 0f       	add	r24, r24
     7d8:	99 1f       	adc	r25, r25
     7da:	84 0d       	add	r24, r4
     7dc:	95 1d       	adc	r25, r5
     7de:	dc 01       	movw	r26, r24
     7e0:	0d 90       	ld	r0, X+
     7e2:	bc 91       	ld	r27, X
     7e4:	a0 2d       	mov	r26, r0
     7e6:	bc 83       	std	Y+4, r27	; 0x04
     7e8:	ab 83       	std	Y+3, r26	; 0x03
				next=initial_home_run[m+1];
     7ea:	c3 01       	movw	r24, r6
     7ec:	02 96       	adiw	r24, 0x02	; 2
     7ee:	88 0f       	add	r24, r24
     7f0:	99 1f       	adc	r25, r25
     7f2:	84 0d       	add	r24, r4
     7f4:	95 1d       	adc	r25, r5
     7f6:	fc 01       	movw	r30, r24
     7f8:	01 90       	ld	r0, Z+
     7fa:	f0 81       	ld	r31, Z
     7fc:	e0 2d       	mov	r30, r0
     7fe:	fa 83       	std	Y+2, r31	; 0x02
     800:	e9 83       	std	Y+1, r30	; 0x01
					//turn(1);
					//turn(1);
					turn_reverse();
				}
				
				m=m+1;
     802:	39 01       	movw	r6, r18
     804:	48 c0       	rjmp	.+144    	; 0x896 <__stack+0x437>
				prev=initial_home_run[m-1];
				present=initial_home_run[m];
				next=initial_home_run[m+1];
			}
			
			else if(next-present==-1)
     806:	ff ef       	ldi	r31, 0xFF	; 255
     808:	8f 3f       	cpi	r24, 0xFF	; 255
     80a:	9f 07       	cpc	r25, r31
     80c:	09 f0       	breq	.+2      	; 0x810 <__stack+0x3b1>
     80e:	43 c0       	rjmp	.+134    	; 0x896 <__stack+0x437>
			{
				if(present-prev==-1)
     810:	0b 81       	ldd	r16, Y+3	; 0x03
     812:	1c 81       	ldd	r17, Y+4	; 0x04
     814:	2d 81       	ldd	r18, Y+5	; 0x05
     816:	3e 81       	ldd	r19, Y+6	; 0x06
     818:	02 1b       	sub	r16, r18
     81a:	13 0b       	sbc	r17, r19
     81c:	3f ef       	ldi	r19, 0xFF	; 255
     81e:	0f 3f       	cpi	r16, 0xFF	; 255
     820:	13 07       	cpc	r17, r19
     822:	19 f4       	brne	.+6      	; 0x82a <__stack+0x3cb>
				//forward();
				just_forward();
     824:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
     828:	0d c0       	rjmp	.+26     	; 0x844 <__stack+0x3e5>
				if(present-prev==-7)
     82a:	4f ef       	ldi	r20, 0xFF	; 255
     82c:	09 3f       	cpi	r16, 0xF9	; 249
     82e:	14 07       	cpc	r17, r20
     830:	19 f4       	brne	.+6      	; 0x838 <__stack+0x3d9>
				//turn(0);
				turn_left();
     832:	0e 94 3d 01 	call	0x27a	; 0x27a <turn_left>
     836:	0b c0       	rjmp	.+22     	; 0x84e <__stack+0x3ef>
				if(present-prev==7)
     838:	07 30       	cpi	r16, 0x07	; 7
     83a:	11 05       	cpc	r17, r1
     83c:	19 f4       	brne	.+6      	; 0x844 <__stack+0x3e5>
				//turn(1);
				turn_right();
     83e:	0e 94 27 01 	call	0x24e	; 0x24e <turn_right>
     842:	05 c0       	rjmp	.+10     	; 0x84e <__stack+0x3ef>
				if(present-prev==1)
     844:	01 30       	cpi	r16, 0x01	; 1
     846:	11 05       	cpc	r17, r1
     848:	11 f4       	brne	.+4      	; 0x84e <__stack+0x3ef>
				{
					//turn(1);
					//turn(1);
					turn_reverse();
     84a:	0e 94 53 01 	call	0x2a6	; 0x2a6 <turn_reverse>
				}

				m=m+1;
     84e:	93 01       	movw	r18, r6
     850:	2f 5f       	subi	r18, 0xFF	; 255
     852:	3f 4f       	sbci	r19, 0xFF	; 255
				prev=initial_home_run[m-1];
     854:	f3 01       	movw	r30, r6
     856:	ee 0f       	add	r30, r30
     858:	ff 1f       	adc	r31, r31
     85a:	e4 0d       	add	r30, r4
     85c:	f5 1d       	adc	r31, r5
     85e:	80 81       	ld	r24, Z
     860:	91 81       	ldd	r25, Z+1	; 0x01
     862:	9e 83       	std	Y+6, r25	; 0x06
     864:	8d 83       	std	Y+5, r24	; 0x05
				present=initial_home_run[m];
     866:	c9 01       	movw	r24, r18
     868:	88 0f       	add	r24, r24
     86a:	99 1f       	adc	r25, r25
     86c:	84 0d       	add	r24, r4
     86e:	95 1d       	adc	r25, r5
     870:	dc 01       	movw	r26, r24
     872:	0d 90       	ld	r0, X+
     874:	bc 91       	ld	r27, X
     876:	a0 2d       	mov	r26, r0
     878:	bc 83       	std	Y+4, r27	; 0x04
     87a:	ab 83       	std	Y+3, r26	; 0x03
				next=initial_home_run[m+1];
     87c:	c3 01       	movw	r24, r6
     87e:	02 96       	adiw	r24, 0x02	; 2
     880:	88 0f       	add	r24, r24
     882:	99 1f       	adc	r25, r25
     884:	84 0d       	add	r24, r4
     886:	95 1d       	adc	r25, r5
     888:	fc 01       	movw	r30, r24
     88a:	01 90       	ld	r0, Z+
     88c:	f0 81       	ld	r31, Z
     88e:	e0 2d       	mov	r30, r0
     890:	fa 83       	std	Y+2, r31	; 0x02
     892:	e9 83       	std	Y+1, r30	; 0x01
					//turn(1);
					//turn(1);
					turn_reverse();
				}

				m=m+1;
     894:	39 01       	movw	r6, r18
		present=initial_home_run[m];
		next=initial_home_run[m+1];
	}
	
	*/
	while(initial_home_run[m]!=99)
     896:	c3 01       	movw	r24, r6
     898:	88 0f       	add	r24, r24
     89a:	99 1f       	adc	r25, r25
     89c:	84 0d       	add	r24, r4
     89e:	95 1d       	adc	r25, r5
     8a0:	dc 01       	movw	r26, r24
     8a2:	8d 91       	ld	r24, X+
     8a4:	9c 91       	ld	r25, X
     8a6:	11 97       	sbiw	r26, 0x01	; 1
     8a8:	83 36       	cpi	r24, 0x63	; 99
     8aa:	91 05       	cpc	r25, r1
     8ac:	09 f0       	breq	.+2      	; 0x8b0 <__stack+0x451>
     8ae:	2d ce       	rjmp	.-934    	; 0x50a <__stack+0xab>
			//velocity(20,20);
			//_delay_ms(400);
		}
		//ir_check();
	}
	++event;
     8b0:	80 91 9c 00 	lds	r24, 0x009C
     8b4:	90 91 9d 00 	lds	r25, 0x009D
     8b8:	01 96       	adiw	r24, 0x01	; 1
     8ba:	90 93 9d 00 	sts	0x009D, r25
     8be:	80 93 9c 00 	sts	0x009C, r24
	ensure_orient(3);
     8c2:	83 e0       	ldi	r24, 0x03	; 3
     8c4:	90 e0       	ldi	r25, 0x00	; 0
     8c6:	0e 94 bd 0a 	call	0x157a	; 0x157a <ensure_orient>
	UDR= 0x40;
     8ca:	80 e4       	ldi	r24, 0x40	; 64
     8cc:	8c b9       	out	0x0c, r24	; 12
     8ce:	2f ef       	ldi	r18, 0xFF	; 255
     8d0:	3f e3       	ldi	r19, 0x3F	; 63
     8d2:	42 e0       	ldi	r20, 0x02	; 2
     8d4:	21 50       	subi	r18, 0x01	; 1
     8d6:	30 40       	sbci	r19, 0x00	; 0
     8d8:	40 40       	sbci	r20, 0x00	; 0
     8da:	e1 f7       	brne	.-8      	; 0x8d4 <__stack+0x475>
     8dc:	00 c0       	rjmp	.+0      	; 0x8de <__stack+0x47f>
     8de:	00 00       	nop
	_delay_ms(100);
	UDR = 0x40;
     8e0:	8c b9       	out	0x0c, r24	; 12
     8e2:	2f ef       	ldi	r18, 0xFF	; 255
     8e4:	3f e3       	ldi	r19, 0x3F	; 63
     8e6:	42 e0       	ldi	r20, 0x02	; 2
     8e8:	21 50       	subi	r18, 0x01	; 1
     8ea:	30 40       	sbci	r19, 0x00	; 0
     8ec:	40 40       	sbci	r20, 0x00	; 0
     8ee:	e1 f7       	brne	.-8      	; 0x8e8 <__stack+0x489>
     8f0:	00 c0       	rjmp	.+0      	; 0x8f2 <__stack+0x493>
     8f2:	00 00       	nop
	_delay_ms(100);
	UDR = 0x40;
     8f4:	8c b9       	out	0x0c, r24	; 12
	home_bit[0]=1;
     8f6:	81 e0       	ldi	r24, 0x01	; 1
     8f8:	90 e0       	ldi	r25, 0x00	; 0
     8fa:	90 93 a5 00 	sts	0x00A5, r25
     8fe:	80 93 a4 00 	sts	0x00A4, r24
	buzz();
     902:	0e 94 02 02 	call	0x404	; 0x404 <buzz>
}
     906:	28 96       	adiw	r28, 0x08	; 8
     908:	0f b6       	in	r0, 0x3f	; 63
     90a:	f8 94       	cli
     90c:	de bf       	out	0x3e, r29	; 62
     90e:	0f be       	out	0x3f, r0	; 63
     910:	cd bf       	out	0x3d, r28	; 61
     912:	df 91       	pop	r29
     914:	cf 91       	pop	r28
     916:	1f 91       	pop	r17
     918:	0f 91       	pop	r16
     91a:	ff 90       	pop	r15
     91c:	ef 90       	pop	r14
     91e:	df 90       	pop	r13
     920:	cf 90       	pop	r12
     922:	bf 90       	pop	r11
     924:	af 90       	pop	r10
     926:	9f 90       	pop	r9
     928:	8f 90       	pop	r8
     92a:	7f 90       	pop	r7
     92c:	6f 90       	pop	r6
     92e:	5f 90       	pop	r5
     930:	4f 90       	pop	r4
     932:	3f 90       	pop	r3
     934:	2f 90       	pop	r2
     936:	08 95       	ret

00000938 <turn_right_ensure>:
	//stop();
	//_delay_ms(500);
	//forward();
	//velocity(35,35);
	//_delay_ms(600);
	turn(1);
     938:	81 e0       	ldi	r24, 0x01	; 1
     93a:	90 e0       	ldi	r25, 0x00	; 0
     93c:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <turn>
}
     940:	08 95       	ret

00000942 <final_home_run>:
  * Logic: This function upon being called starts the robots final run for its parking at its respective home position, i.e., from node 13 to red home.
  * Example Call: final_home_run()
  */

void final_home_run(void)
{
     942:	6f 92       	push	r6
     944:	7f 92       	push	r7
     946:	8f 92       	push	r8
     948:	9f 92       	push	r9
     94a:	af 92       	push	r10
     94c:	bf 92       	push	r11
     94e:	cf 92       	push	r12
     950:	df 92       	push	r13
     952:	ef 92       	push	r14
     954:	ff 92       	push	r15
     956:	0f 93       	push	r16
     958:	1f 93       	push	r17
     95a:	cf 93       	push	r28
     95c:	df 93       	push	r29
		if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
		if (rightMotorSpeed < 0) rightMotorSpeed = 0;
		if (leftMotorSpeed < 0) leftMotorSpeed = 0;

		forward();
		velocity(leftMotorSpeed,rightMotorSpeed);
     95e:	66 24       	eor	r6, r6
     960:	77 24       	eor	r7, r7
  * Example Call: final_home_run()
  */

void final_home_run(void)
{
	while(curr_pos!=7)
     962:	9d c0       	rjmp	.+314    	; 0xa9e <final_home_run+0x15c>
	{
		Left_white_line = ADC_Conversion(3);
     964:	83 e0       	ldi	r24, 0x03	; 3
     966:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     96a:	80 93 79 00 	sts	0x0079, r24
		Center_white_line = ADC_Conversion(4);
     96e:	84 e0       	ldi	r24, 0x04	; 4
     970:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     974:	80 93 78 00 	sts	0x0078, r24
		Right_white_line = ADC_Conversion(5);
     978:	85 e0       	ldi	r24, 0x05	; 5
     97a:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     97e:	80 93 77 00 	sts	0x0077, r24
		error = Right_white_line - Left_white_line;
     982:	90 e0       	ldi	r25, 0x00	; 0
     984:	20 91 79 00 	lds	r18, 0x0079
     988:	82 1b       	sub	r24, r18
     98a:	91 09       	sbc	r25, r1
     98c:	90 93 13 01 	sts	0x0113, r25
     990:	80 93 12 01 	sts	0x0112, r24
		int motorSpeed = Kp * error + Kd * (error - lastError);
     994:	60 91 12 01 	lds	r22, 0x0112
     998:	70 91 13 01 	lds	r23, 0x0113
     99c:	c0 90 67 00 	lds	r12, 0x0067
     9a0:	d0 90 68 00 	lds	r13, 0x0068
     9a4:	e0 90 69 00 	lds	r14, 0x0069
     9a8:	f0 90 6a 00 	lds	r15, 0x006A
     9ac:	c0 91 12 01 	lds	r28, 0x0112
     9b0:	d0 91 13 01 	lds	r29, 0x0113
     9b4:	00 91 7a 00 	lds	r16, 0x007A
     9b8:	10 91 7b 00 	lds	r17, 0x007B
     9bc:	80 90 63 00 	lds	r8, 0x0063
     9c0:	90 90 64 00 	lds	r9, 0x0064
     9c4:	a0 90 65 00 	lds	r10, 0x0065
     9c8:	b0 90 66 00 	lds	r11, 0x0066
     9cc:	88 27       	eor	r24, r24
     9ce:	77 fd       	sbrc	r23, 7
     9d0:	80 95       	com	r24
     9d2:	98 2f       	mov	r25, r24
     9d4:	0e 94 39 18 	call	0x3072	; 0x3072 <__floatsisf>
     9d8:	a7 01       	movw	r20, r14
     9da:	96 01       	movw	r18, r12
     9dc:	0e 94 c5 18 	call	0x318a	; 0x318a <__mulsf3>
     9e0:	6b 01       	movw	r12, r22
     9e2:	7c 01       	movw	r14, r24
     9e4:	be 01       	movw	r22, r28
     9e6:	60 1b       	sub	r22, r16
     9e8:	71 0b       	sbc	r23, r17
     9ea:	88 27       	eor	r24, r24
     9ec:	77 fd       	sbrc	r23, 7
     9ee:	80 95       	com	r24
     9f0:	98 2f       	mov	r25, r24
     9f2:	0e 94 39 18 	call	0x3072	; 0x3072 <__floatsisf>
     9f6:	a5 01       	movw	r20, r10
     9f8:	94 01       	movw	r18, r8
     9fa:	0e 94 c5 18 	call	0x318a	; 0x318a <__mulsf3>
     9fe:	9b 01       	movw	r18, r22
     a00:	ac 01       	movw	r20, r24
     a02:	c7 01       	movw	r24, r14
     a04:	b6 01       	movw	r22, r12
     a06:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <__addsf3>
     a0a:	0e 94 06 18 	call	0x300c	; 0x300c <__fixsfsi>
		lastError = error;
     a0e:	80 91 12 01 	lds	r24, 0x0112
     a12:	90 91 13 01 	lds	r25, 0x0113
     a16:	90 93 7b 00 	sts	0x007B, r25
     a1a:	80 93 7a 00 	sts	0x007A, r24
		int rightMotorSpeed = rightBaseSpeed - motorSpeed;
     a1e:	00 91 62 00 	lds	r16, 0x0062
     a22:	10 e0       	ldi	r17, 0x00	; 0
		int leftMotorSpeed = leftBaseSpeed + motorSpeed;
     a24:	80 91 61 00 	lds	r24, 0x0061
     a28:	eb 01       	movw	r28, r22
     a2a:	c8 0f       	add	r28, r24
     a2c:	d1 1d       	adc	r29, r1
     a2e:	06 1b       	sub	r16, r22
     a30:	17 0b       	sbc	r17, r23
     a32:	08 33       	cpi	r16, 0x38	; 56
     a34:	11 05       	cpc	r17, r1
     a36:	14 f0       	brlt	.+4      	; 0xa3c <final_home_run+0xfa>
     a38:	07 e3       	ldi	r16, 0x37	; 55
     a3a:	10 e0       	ldi	r17, 0x00	; 0
     a3c:	c8 33       	cpi	r28, 0x38	; 56
     a3e:	d1 05       	cpc	r29, r1
     a40:	14 f0       	brlt	.+4      	; 0xa46 <final_home_run+0x104>
     a42:	c7 e3       	ldi	r28, 0x37	; 55
     a44:	d0 e0       	ldi	r29, 0x00	; 0
		if (rightMotorSpeed > rightMaxSpeed ) rightMotorSpeed = rightMaxSpeed;
		if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
		if (rightMotorSpeed < 0) rightMotorSpeed = 0;
		if (leftMotorSpeed < 0) leftMotorSpeed = 0;

		forward();
     a46:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <forward>
		velocity(leftMotorSpeed,rightMotorSpeed);
     a4a:	ce 01       	movw	r24, r28
     a4c:	dd 23       	and	r29, r29
     a4e:	0c f4       	brge	.+2      	; 0xa52 <final_home_run+0x110>
     a50:	c3 01       	movw	r24, r6
     a52:	b8 01       	movw	r22, r16
     a54:	11 23       	and	r17, r17
     a56:	0c f4       	brge	.+2      	; 0xa5a <final_home_run+0x118>
     a58:	b3 01       	movw	r22, r6
     a5a:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>

		if(Center_white_line>100 && Left_white_line>100 && Right_white_line>100)
     a5e:	80 91 78 00 	lds	r24, 0x0078
     a62:	85 36       	cpi	r24, 0x65	; 101
     a64:	e0 f0       	brcs	.+56     	; 0xa9e <final_home_run+0x15c>
     a66:	80 91 79 00 	lds	r24, 0x0079
     a6a:	85 36       	cpi	r24, 0x65	; 101
     a6c:	c0 f0       	brcs	.+48     	; 0xa9e <final_home_run+0x15c>
     a6e:	80 91 77 00 	lds	r24, 0x0077
     a72:	85 36       	cpi	r24, 0x65	; 101
     a74:	a0 f0       	brcs	.+40     	; 0xa9e <final_home_run+0x15c>
		{
			update_curr_pos();
     a76:	0e 94 8f 00 	call	0x11e	; 0x11e <update_curr_pos>
			
			//velocity(40,40);
			//_delay_ms(300);
			stop();
     a7a:	0e 94 b9 0a 	call	0x1572	; 0x1572 <stop>
			buzz(); 
     a7e:	0e 94 02 02 	call	0x404	; 0x404 <buzz>
			 
			 if(curr_pos==7)
     a82:	80 91 b4 00 	lds	r24, 0x00B4
     a86:	90 91 b5 00 	lds	r25, 0x00B5
     a8a:	87 30       	cpi	r24, 0x07	; 7
     a8c:	91 05       	cpc	r25, r1
     a8e:	29 f4       	brne	.+10     	; 0xa9a <final_home_run+0x158>
			 {
				 forward_mm(100);
     a90:	84 e6       	ldi	r24, 0x64	; 100
     a92:	90 e0       	ldi	r25, 0x00	; 0
     a94:	0e 94 5f 0b 	call	0x16be	; 0x16be <forward_mm>
     a98:	02 c0       	rjmp	.+4      	; 0xa9e <final_home_run+0x15c>
			 else
			 {
				 // forward();
				  //velocity(100,100);
				  //_delay_ms(300);
				  just_forward();
     a9a:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
  * Example Call: final_home_run()
  */

void final_home_run(void)
{
	while(curr_pos!=7)
     a9e:	80 91 b4 00 	lds	r24, 0x00B4
     aa2:	90 91 b5 00 	lds	r25, 0x00B5
     aa6:	87 30       	cpi	r24, 0x07	; 7
     aa8:	91 05       	cpc	r25, r1
     aaa:	09 f0       	breq	.+2      	; 0xaae <final_home_run+0x16c>
     aac:	5b cf       	rjmp	.-330    	; 0x964 <final_home_run+0x22>
				  //_delay_ms(300);
				  just_forward();
			 }
		}			
	}
}
     aae:	df 91       	pop	r29
     ab0:	cf 91       	pop	r28
     ab2:	1f 91       	pop	r17
     ab4:	0f 91       	pop	r16
     ab6:	ff 90       	pop	r15
     ab8:	ef 90       	pop	r14
     aba:	df 90       	pop	r13
     abc:	cf 90       	pop	r12
     abe:	bf 90       	pop	r11
     ac0:	af 90       	pop	r10
     ac2:	9f 90       	pop	r9
     ac4:	8f 90       	pop	r8
     ac6:	7f 90       	pop	r7
     ac8:	6f 90       	pop	r6
     aca:	08 95       	ret

00000acc <navigate_1>:
  * Logic: This function upon being called makes the robot traverse path for changing set1 to set2, i.e, from node 41 to node 13.
  * Example Call: navigate_1()
  */

void navigate_1(void)
{
     acc:	4f 92       	push	r4
     ace:	5f 92       	push	r5
     ad0:	6f 92       	push	r6
     ad2:	7f 92       	push	r7
     ad4:	8f 92       	push	r8
     ad6:	9f 92       	push	r9
     ad8:	af 92       	push	r10
     ada:	bf 92       	push	r11
     adc:	cf 92       	push	r12
     ade:	df 92       	push	r13
     ae0:	ef 92       	push	r14
     ae2:	ff 92       	push	r15
     ae4:	0f 93       	push	r16
     ae6:	1f 93       	push	r17
     ae8:	cf 93       	push	r28
     aea:	df 93       	push	r29
			if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
			if (rightMotorSpeed < 0) rightMotorSpeed = 0;
			if (leftMotorSpeed < 0) leftMotorSpeed = 0;

			forward();
			velocity(leftMotorSpeed,rightMotorSpeed);
     aec:	66 24       	eor	r6, r6
     aee:	77 24       	eor	r7, r7
					 if(curr_pos == 40)
					 {
						 all_xbee_clear();
					 }
				 
				 if((curr_pos== 40) | (curr_pos==12)) 
     af0:	55 24       	eor	r5, r5
     af2:	53 94       	inc	r5
     af4:	44 24       	eor	r4, r4
  * Example Call: navigate_1()
  */

void navigate_1(void)
{
	while(curr_pos != 13)
     af6:	bf c0       	rjmp	.+382    	; 0xc76 <navigate_1+0x1aa>
	{
		
		
			Left_white_line = ADC_Conversion(3);
     af8:	83 e0       	ldi	r24, 0x03	; 3
     afa:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     afe:	80 93 79 00 	sts	0x0079, r24
			Center_white_line = ADC_Conversion(4);
     b02:	84 e0       	ldi	r24, 0x04	; 4
     b04:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     b08:	80 93 78 00 	sts	0x0078, r24
			Right_white_line = ADC_Conversion(5);
     b0c:	85 e0       	ldi	r24, 0x05	; 5
     b0e:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     b12:	80 93 77 00 	sts	0x0077, r24
			error = Right_white_line - Left_white_line;
     b16:	90 e0       	ldi	r25, 0x00	; 0
     b18:	20 91 79 00 	lds	r18, 0x0079
     b1c:	82 1b       	sub	r24, r18
     b1e:	91 09       	sbc	r25, r1
     b20:	90 93 13 01 	sts	0x0113, r25
     b24:	80 93 12 01 	sts	0x0112, r24
			int motorSpeed = Kp * error + Kd * (error - lastError);
     b28:	60 91 12 01 	lds	r22, 0x0112
     b2c:	70 91 13 01 	lds	r23, 0x0113
     b30:	c0 90 67 00 	lds	r12, 0x0067
     b34:	d0 90 68 00 	lds	r13, 0x0068
     b38:	e0 90 69 00 	lds	r14, 0x0069
     b3c:	f0 90 6a 00 	lds	r15, 0x006A
     b40:	c0 91 12 01 	lds	r28, 0x0112
     b44:	d0 91 13 01 	lds	r29, 0x0113
     b48:	00 91 7a 00 	lds	r16, 0x007A
     b4c:	10 91 7b 00 	lds	r17, 0x007B
     b50:	80 90 63 00 	lds	r8, 0x0063
     b54:	90 90 64 00 	lds	r9, 0x0064
     b58:	a0 90 65 00 	lds	r10, 0x0065
     b5c:	b0 90 66 00 	lds	r11, 0x0066
     b60:	88 27       	eor	r24, r24
     b62:	77 fd       	sbrc	r23, 7
     b64:	80 95       	com	r24
     b66:	98 2f       	mov	r25, r24
     b68:	0e 94 39 18 	call	0x3072	; 0x3072 <__floatsisf>
     b6c:	a7 01       	movw	r20, r14
     b6e:	96 01       	movw	r18, r12
     b70:	0e 94 c5 18 	call	0x318a	; 0x318a <__mulsf3>
     b74:	6b 01       	movw	r12, r22
     b76:	7c 01       	movw	r14, r24
     b78:	be 01       	movw	r22, r28
     b7a:	60 1b       	sub	r22, r16
     b7c:	71 0b       	sbc	r23, r17
     b7e:	88 27       	eor	r24, r24
     b80:	77 fd       	sbrc	r23, 7
     b82:	80 95       	com	r24
     b84:	98 2f       	mov	r25, r24
     b86:	0e 94 39 18 	call	0x3072	; 0x3072 <__floatsisf>
     b8a:	a5 01       	movw	r20, r10
     b8c:	94 01       	movw	r18, r8
     b8e:	0e 94 c5 18 	call	0x318a	; 0x318a <__mulsf3>
     b92:	9b 01       	movw	r18, r22
     b94:	ac 01       	movw	r20, r24
     b96:	c7 01       	movw	r24, r14
     b98:	b6 01       	movw	r22, r12
     b9a:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <__addsf3>
     b9e:	0e 94 06 18 	call	0x300c	; 0x300c <__fixsfsi>
			lastError = error;
     ba2:	80 91 12 01 	lds	r24, 0x0112
     ba6:	90 91 13 01 	lds	r25, 0x0113
     baa:	90 93 7b 00 	sts	0x007B, r25
     bae:	80 93 7a 00 	sts	0x007A, r24
			int rightMotorSpeed = rightBaseSpeed - motorSpeed;
     bb2:	00 91 62 00 	lds	r16, 0x0062
     bb6:	10 e0       	ldi	r17, 0x00	; 0
			int leftMotorSpeed = leftBaseSpeed + motorSpeed;
     bb8:	80 91 61 00 	lds	r24, 0x0061
     bbc:	eb 01       	movw	r28, r22
     bbe:	c8 0f       	add	r28, r24
     bc0:	d1 1d       	adc	r29, r1
     bc2:	06 1b       	sub	r16, r22
     bc4:	17 0b       	sbc	r17, r23
     bc6:	08 33       	cpi	r16, 0x38	; 56
     bc8:	11 05       	cpc	r17, r1
     bca:	14 f0       	brlt	.+4      	; 0xbd0 <navigate_1+0x104>
     bcc:	07 e3       	ldi	r16, 0x37	; 55
     bce:	10 e0       	ldi	r17, 0x00	; 0
     bd0:	c8 33       	cpi	r28, 0x38	; 56
     bd2:	d1 05       	cpc	r29, r1
     bd4:	14 f0       	brlt	.+4      	; 0xbda <navigate_1+0x10e>
     bd6:	c7 e3       	ldi	r28, 0x37	; 55
     bd8:	d0 e0       	ldi	r29, 0x00	; 0
			if (rightMotorSpeed > rightMaxSpeed ) rightMotorSpeed = rightMaxSpeed;
			if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
			if (rightMotorSpeed < 0) rightMotorSpeed = 0;
			if (leftMotorSpeed < 0) leftMotorSpeed = 0;

			forward();
     bda:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <forward>
			velocity(leftMotorSpeed,rightMotorSpeed);
     bde:	ce 01       	movw	r24, r28
     be0:	dd 23       	and	r29, r29
     be2:	0c f4       	brge	.+2      	; 0xbe6 <navigate_1+0x11a>
     be4:	c3 01       	movw	r24, r6
     be6:	b8 01       	movw	r22, r16
     be8:	11 23       	and	r17, r17
     bea:	0c f4       	brge	.+2      	; 0xbee <navigate_1+0x122>
     bec:	b3 01       	movw	r22, r6
     bee:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>

			if(Center_white_line>100 && Left_white_line>100 && Right_white_line>100)
     bf2:	80 91 78 00 	lds	r24, 0x0078
     bf6:	85 36       	cpi	r24, 0x65	; 101
     bf8:	f0 f1       	brcs	.+124    	; 0xc76 <navigate_1+0x1aa>
     bfa:	80 91 79 00 	lds	r24, 0x0079
     bfe:	85 36       	cpi	r24, 0x65	; 101
     c00:	d0 f1       	brcs	.+116    	; 0xc76 <navigate_1+0x1aa>
     c02:	80 91 77 00 	lds	r24, 0x0077
     c06:	85 36       	cpi	r24, 0x65	; 101
     c08:	b0 f1       	brcs	.+108    	; 0xc76 <navigate_1+0x1aa>
			{
				update_curr_pos();
     c0a:	0e 94 8f 00 	call	0x11e	; 0x11e <update_curr_pos>
				
				//velocity(40,40);
				//_delay_ms(300);
				stop();
     c0e:	0e 94 b9 0a 	call	0x1572	; 0x1572 <stop>
				buzz();
     c12:	0e 94 02 02 	call	0x404	; 0x404 <buzz>
				
					 if(curr_pos == 40)
     c16:	80 91 b4 00 	lds	r24, 0x00B4
     c1a:	90 91 b5 00 	lds	r25, 0x00B5
     c1e:	88 32       	cpi	r24, 0x28	; 40
     c20:	91 05       	cpc	r25, r1
     c22:	11 f4       	brne	.+4      	; 0xc28 <navigate_1+0x15c>
					 {
						 all_xbee_clear();
     c24:	0e 94 df 00 	call	0x1be	; 0x1be <all_xbee_clear>
					 }
				 
				 if((curr_pos== 40) | (curr_pos==12)) 
     c28:	80 91 b4 00 	lds	r24, 0x00B4
     c2c:	90 91 b5 00 	lds	r25, 0x00B5
     c30:	20 91 b4 00 	lds	r18, 0x00B4
     c34:	30 91 b5 00 	lds	r19, 0x00B5
     c38:	45 2d       	mov	r20, r5
     c3a:	88 32       	cpi	r24, 0x28	; 40
     c3c:	91 05       	cpc	r25, r1
     c3e:	09 f0       	breq	.+2      	; 0xc42 <navigate_1+0x176>
     c40:	44 2d       	mov	r20, r4
     c42:	44 23       	and	r20, r20
     c44:	39 f4       	brne	.+14     	; 0xc54 <navigate_1+0x188>
     c46:	85 2d       	mov	r24, r5
     c48:	2c 30       	cpi	r18, 0x0C	; 12
     c4a:	31 05       	cpc	r19, r1
     c4c:	09 f0       	breq	.+2      	; 0xc50 <navigate_1+0x184>
     c4e:	84 2d       	mov	r24, r4
     c50:	88 23       	and	r24, r24
     c52:	19 f0       	breq	.+6      	; 0xc5a <navigate_1+0x18e>
				 //turn(1);
				 turn_right();
     c54:	0e 94 27 01 	call	0x24e	; 0x24e <turn_right>
     c58:	0e c0       	rjmp	.+28     	; 0xc76 <navigate_1+0x1aa>
				 else if(curr_pos==13)
     c5a:	80 91 b4 00 	lds	r24, 0x00B4
     c5e:	90 91 b5 00 	lds	r25, 0x00B5
     c62:	8d 30       	cpi	r24, 0x0D	; 13
     c64:	91 05       	cpc	r25, r1
     c66:	29 f4       	brne	.+10     	; 0xc72 <navigate_1+0x1a6>
				 {
					 ensure_orient(3);
     c68:	83 e0       	ldi	r24, 0x03	; 3
     c6a:	90 e0       	ldi	r25, 0x00	; 0
     c6c:	0e 94 bd 0a 	call	0x157a	; 0x157a <ensure_orient>
     c70:	02 c0       	rjmp	.+4      	; 0xc76 <navigate_1+0x1aa>
				 else
				 {
					 //forward();
					 //velocity(100,100);
					 //_delay_ms(300);
					 just_forward();
     c72:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
  * Example Call: navigate_1()
  */

void navigate_1(void)
{
	while(curr_pos != 13)
     c76:	80 91 b4 00 	lds	r24, 0x00B4
     c7a:	90 91 b5 00 	lds	r25, 0x00B5
     c7e:	8d 30       	cpi	r24, 0x0D	; 13
     c80:	91 05       	cpc	r25, r1
     c82:	09 f0       	breq	.+2      	; 0xc86 <navigate_1+0x1ba>
     c84:	39 cf       	rjmp	.-398    	; 0xaf8 <navigate_1+0x2c>
				 }		
							 			 					 
			 }				 
		
	}	       
}
     c86:	df 91       	pop	r29
     c88:	cf 91       	pop	r28
     c8a:	1f 91       	pop	r17
     c8c:	0f 91       	pop	r16
     c8e:	ff 90       	pop	r15
     c90:	ef 90       	pop	r14
     c92:	df 90       	pop	r13
     c94:	cf 90       	pop	r12
     c96:	bf 90       	pop	r11
     c98:	af 90       	pop	r10
     c9a:	9f 90       	pop	r9
     c9c:	8f 90       	pop	r8
     c9e:	7f 90       	pop	r7
     ca0:	6f 90       	pop	r6
     ca2:	5f 90       	pop	r5
     ca4:	4f 90       	pop	r4
     ca6:	08 95       	ret

00000ca8 <navigate_0>:
  * Logic: This function upon being called makes the robot traverse path for changing set0 to set1, i.e, from node 41 to node 13.
  * Example Call: navigate_0()
  */

void navigate_0()
{
     ca8:	5f 92       	push	r5
     caa:	6f 92       	push	r6
     cac:	7f 92       	push	r7
     cae:	8f 92       	push	r8
     cb0:	9f 92       	push	r9
     cb2:	af 92       	push	r10
     cb4:	bf 92       	push	r11
     cb6:	cf 92       	push	r12
     cb8:	df 92       	push	r13
     cba:	ef 92       	push	r14
     cbc:	ff 92       	push	r15
     cbe:	0f 93       	push	r16
     cc0:	1f 93       	push	r17
     cc2:	cf 93       	push	r28
     cc4:	df 93       	push	r29
		 if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
		 if (rightMotorSpeed < 0) rightMotorSpeed = 0;
		 if (leftMotorSpeed < 0) leftMotorSpeed = 0;

		 forward();
		 velocity(leftMotorSpeed,rightMotorSpeed);
     cc6:	66 24       	eor	r6, r6
     cc8:	77 24       	eor	r7, r7
			{
				ensure_orient(3);
				array_index = 0;
				set_cover=0;
				++set;
				xbee_com=-1;
     cca:	55 24       	eor	r5, r5
     ccc:	5a 94       	dec	r5
  * Example Call: navigate_0()
  */

void navigate_0()
{
	while(curr_pos != 41)
     cce:	bd c0       	rjmp	.+378    	; 0xe4a <navigate_0+0x1a2>
	{ 
		 Left_white_line = ADC_Conversion(3);
     cd0:	83 e0       	ldi	r24, 0x03	; 3
     cd2:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     cd6:	80 93 79 00 	sts	0x0079, r24
		 Center_white_line = ADC_Conversion(4);
     cda:	84 e0       	ldi	r24, 0x04	; 4
     cdc:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     ce0:	80 93 78 00 	sts	0x0078, r24
		 Right_white_line = ADC_Conversion(5);
     ce4:	85 e0       	ldi	r24, 0x05	; 5
     ce6:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     cea:	80 93 77 00 	sts	0x0077, r24
		 error = Right_white_line - Left_white_line;
     cee:	90 e0       	ldi	r25, 0x00	; 0
     cf0:	20 91 79 00 	lds	r18, 0x0079
     cf4:	82 1b       	sub	r24, r18
     cf6:	91 09       	sbc	r25, r1
     cf8:	90 93 13 01 	sts	0x0113, r25
     cfc:	80 93 12 01 	sts	0x0112, r24
		 int motorSpeed = Kp * error + Kd * (error - lastError);
     d00:	60 91 12 01 	lds	r22, 0x0112
     d04:	70 91 13 01 	lds	r23, 0x0113
     d08:	c0 90 67 00 	lds	r12, 0x0067
     d0c:	d0 90 68 00 	lds	r13, 0x0068
     d10:	e0 90 69 00 	lds	r14, 0x0069
     d14:	f0 90 6a 00 	lds	r15, 0x006A
     d18:	c0 91 12 01 	lds	r28, 0x0112
     d1c:	d0 91 13 01 	lds	r29, 0x0113
     d20:	00 91 7a 00 	lds	r16, 0x007A
     d24:	10 91 7b 00 	lds	r17, 0x007B
     d28:	80 90 63 00 	lds	r8, 0x0063
     d2c:	90 90 64 00 	lds	r9, 0x0064
     d30:	a0 90 65 00 	lds	r10, 0x0065
     d34:	b0 90 66 00 	lds	r11, 0x0066
     d38:	88 27       	eor	r24, r24
     d3a:	77 fd       	sbrc	r23, 7
     d3c:	80 95       	com	r24
     d3e:	98 2f       	mov	r25, r24
     d40:	0e 94 39 18 	call	0x3072	; 0x3072 <__floatsisf>
     d44:	a7 01       	movw	r20, r14
     d46:	96 01       	movw	r18, r12
     d48:	0e 94 c5 18 	call	0x318a	; 0x318a <__mulsf3>
     d4c:	6b 01       	movw	r12, r22
     d4e:	7c 01       	movw	r14, r24
     d50:	be 01       	movw	r22, r28
     d52:	60 1b       	sub	r22, r16
     d54:	71 0b       	sbc	r23, r17
     d56:	88 27       	eor	r24, r24
     d58:	77 fd       	sbrc	r23, 7
     d5a:	80 95       	com	r24
     d5c:	98 2f       	mov	r25, r24
     d5e:	0e 94 39 18 	call	0x3072	; 0x3072 <__floatsisf>
     d62:	a5 01       	movw	r20, r10
     d64:	94 01       	movw	r18, r8
     d66:	0e 94 c5 18 	call	0x318a	; 0x318a <__mulsf3>
     d6a:	9b 01       	movw	r18, r22
     d6c:	ac 01       	movw	r20, r24
     d6e:	c7 01       	movw	r24, r14
     d70:	b6 01       	movw	r22, r12
     d72:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <__addsf3>
     d76:	0e 94 06 18 	call	0x300c	; 0x300c <__fixsfsi>
		 lastError = error;
     d7a:	80 91 12 01 	lds	r24, 0x0112
     d7e:	90 91 13 01 	lds	r25, 0x0113
     d82:	90 93 7b 00 	sts	0x007B, r25
     d86:	80 93 7a 00 	sts	0x007A, r24
		 int rightMotorSpeed = rightBaseSpeed - motorSpeed;
     d8a:	00 91 62 00 	lds	r16, 0x0062
     d8e:	10 e0       	ldi	r17, 0x00	; 0
		 int leftMotorSpeed = leftBaseSpeed + motorSpeed;
     d90:	80 91 61 00 	lds	r24, 0x0061
     d94:	eb 01       	movw	r28, r22
     d96:	c8 0f       	add	r28, r24
     d98:	d1 1d       	adc	r29, r1
     d9a:	06 1b       	sub	r16, r22
     d9c:	17 0b       	sbc	r17, r23
     d9e:	08 33       	cpi	r16, 0x38	; 56
     da0:	11 05       	cpc	r17, r1
     da2:	14 f0       	brlt	.+4      	; 0xda8 <navigate_0+0x100>
     da4:	07 e3       	ldi	r16, 0x37	; 55
     da6:	10 e0       	ldi	r17, 0x00	; 0
     da8:	c8 33       	cpi	r28, 0x38	; 56
     daa:	d1 05       	cpc	r29, r1
     dac:	14 f0       	brlt	.+4      	; 0xdb2 <navigate_0+0x10a>
     dae:	c7 e3       	ldi	r28, 0x37	; 55
     db0:	d0 e0       	ldi	r29, 0x00	; 0
		 if (rightMotorSpeed > rightMaxSpeed ) rightMotorSpeed = rightMaxSpeed;
		 if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
		 if (rightMotorSpeed < 0) rightMotorSpeed = 0;
		 if (leftMotorSpeed < 0) leftMotorSpeed = 0;

		 forward();
     db2:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <forward>
		 velocity(leftMotorSpeed,rightMotorSpeed);
     db6:	ce 01       	movw	r24, r28
     db8:	dd 23       	and	r29, r29
     dba:	0c f4       	brge	.+2      	; 0xdbe <navigate_0+0x116>
     dbc:	c3 01       	movw	r24, r6
     dbe:	b8 01       	movw	r22, r16
     dc0:	11 23       	and	r17, r17
     dc2:	0c f4       	brge	.+2      	; 0xdc6 <navigate_0+0x11e>
     dc4:	b3 01       	movw	r22, r6
     dc6:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>

		 if(Center_white_line>100 && Left_white_line>100 && Right_white_line>100)
     dca:	80 91 78 00 	lds	r24, 0x0078
     dce:	85 36       	cpi	r24, 0x65	; 101
     dd0:	e0 f1       	brcs	.+120    	; 0xe4a <navigate_0+0x1a2>
     dd2:	80 91 79 00 	lds	r24, 0x0079
     dd6:	85 36       	cpi	r24, 0x65	; 101
     dd8:	c0 f1       	brcs	.+112    	; 0xe4a <navigate_0+0x1a2>
     dda:	80 91 77 00 	lds	r24, 0x0077
     dde:	85 36       	cpi	r24, 0x65	; 101
     de0:	a0 f1       	brcs	.+104    	; 0xe4a <navigate_0+0x1a2>
		 {
			  update_curr_pos();
     de2:	0e 94 8f 00 	call	0x11e	; 0x11e <update_curr_pos>
			  
			 // velocity(40,40);
			  //_delay_ms(300);
			  stop();
     de6:	0e 94 b9 0a 	call	0x1572	; 0x1572 <stop>
			  buzz();
     dea:	0e 94 02 02 	call	0x404	; 0x404 <buzz>
			if(curr_pos == 34)
     dee:	80 91 b4 00 	lds	r24, 0x00B4
     df2:	90 91 b5 00 	lds	r25, 0x00B5
     df6:	82 32       	cpi	r24, 0x22	; 34
     df8:	91 05       	cpc	r25, r1
     dfa:	11 f4       	brne	.+4      	; 0xe00 <navigate_0+0x158>
			{
				all_xbee_clear();
     dfc:	0e 94 df 00 	call	0x1be	; 0x1be <all_xbee_clear>
			}  
			if(curr_pos!=41)
     e00:	80 91 b4 00 	lds	r24, 0x00B4
     e04:	90 91 b5 00 	lds	r25, 0x00B5
     e08:	89 32       	cpi	r24, 0x29	; 41
     e0a:	91 05       	cpc	r25, r1
     e0c:	19 f0       	breq	.+6      	; 0xe14 <navigate_0+0x16c>
			{ 
				//forward();
				//velocity(100,100);
				//_delay_ms(300);
				just_forward();
     e0e:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
     e12:	1b c0       	rjmp	.+54     	; 0xe4a <navigate_0+0x1a2>
			}
			else
			{
				ensure_orient(3);
     e14:	83 e0       	ldi	r24, 0x03	; 3
     e16:	90 e0       	ldi	r25, 0x00	; 0
     e18:	0e 94 bd 0a 	call	0x157a	; 0x157a <ensure_orient>
				array_index = 0;
     e1c:	70 92 8d 00 	sts	0x008D, r7
     e20:	60 92 8c 00 	sts	0x008C, r6
				set_cover=0;
     e24:	70 92 9f 00 	sts	0x009F, r7
     e28:	60 92 9e 00 	sts	0x009E, r6
				++set;
     e2c:	80 91 a0 00 	lds	r24, 0x00A0
     e30:	90 91 a1 00 	lds	r25, 0x00A1
     e34:	01 96       	adiw	r24, 0x01	; 1
     e36:	90 93 a1 00 	sts	0x00A1, r25
     e3a:	80 93 a0 00 	sts	0x00A0, r24
				xbee_com=-1;
     e3e:	50 92 98 00 	sts	0x0098, r5
				event=0;
     e42:	70 92 9d 00 	sts	0x009D, r7
     e46:	60 92 9c 00 	sts	0x009C, r6
  * Example Call: navigate_0()
  */

void navigate_0()
{
	while(curr_pos != 41)
     e4a:	80 91 b4 00 	lds	r24, 0x00B4
     e4e:	90 91 b5 00 	lds	r25, 0x00B5
     e52:	89 32       	cpi	r24, 0x29	; 41
     e54:	91 05       	cpc	r25, r1
     e56:	09 f0       	breq	.+2      	; 0xe5a <navigate_0+0x1b2>
     e58:	3b cf       	rjmp	.-394    	; 0xcd0 <navigate_0+0x28>
				event=0;
		    }								
		  }
	    	 
     }		
}
     e5a:	df 91       	pop	r29
     e5c:	cf 91       	pop	r28
     e5e:	1f 91       	pop	r17
     e60:	0f 91       	pop	r16
     e62:	ff 90       	pop	r15
     e64:	ef 90       	pop	r14
     e66:	df 90       	pop	r13
     e68:	cf 90       	pop	r12
     e6a:	bf 90       	pop	r11
     e6c:	af 90       	pop	r10
     e6e:	9f 90       	pop	r9
     e70:	8f 90       	pop	r8
     e72:	7f 90       	pop	r7
     e74:	6f 90       	pop	r6
     e76:	5f 90       	pop	r5
     e78:	08 95       	ret

00000e7a <line_follow_till_2>:
           If their are no plants it will simply traverse the other end of the set and come back to the start of the start, i.e., node 13.
  * Example Call: line_follow_till_2()
  */ 

void line_follow_till_2(unsigned int req_pos)
{
     e7a:	3f 92       	push	r3
     e7c:	4f 92       	push	r4
     e7e:	5f 92       	push	r5
     e80:	6f 92       	push	r6
     e82:	7f 92       	push	r7
     e84:	8f 92       	push	r8
     e86:	9f 92       	push	r9
     e88:	af 92       	push	r10
     e8a:	bf 92       	push	r11
     e8c:	cf 92       	push	r12
     e8e:	df 92       	push	r13
     e90:	ef 92       	push	r14
     e92:	ff 92       	push	r15
     e94:	0f 93       	push	r16
     e96:	1f 93       	push	r17
     e98:	cf 93       	push	r28
     e9a:	df 93       	push	r29
     e9c:	3c 01       	movw	r6, r24
	if(((req_pos == 13) && (set_cover == 0)) || ((req_pos == 7) && (set_cover == 50)))
     e9e:	8d e0       	ldi	r24, 0x0D	; 13
     ea0:	68 16       	cp	r6, r24
     ea2:	71 04       	cpc	r7, r1
     ea4:	41 f4       	brne	.+16     	; 0xeb6 <line_follow_till_2+0x3c>
     ea6:	80 91 9e 00 	lds	r24, 0x009E
     eaa:	90 91 9f 00 	lds	r25, 0x009F
     eae:	00 97       	sbiw	r24, 0x00	; 0
     eb0:	09 f0       	breq	.+2      	; 0xeb4 <line_follow_till_2+0x3a>
     eb2:	33 c1       	rjmp	.+614    	; 0x111a <line_follow_till_2+0x2a0>
     eb4:	0d c0       	rjmp	.+26     	; 0xed0 <line_follow_till_2+0x56>
     eb6:	97 e0       	ldi	r25, 0x07	; 7
     eb8:	69 16       	cp	r6, r25
     eba:	71 04       	cpc	r7, r1
     ebc:	09 f0       	breq	.+2      	; 0xec0 <line_follow_till_2+0x46>
     ebe:	2d c1       	rjmp	.+602    	; 0x111a <line_follow_till_2+0x2a0>
     ec0:	80 91 9e 00 	lds	r24, 0x009E
     ec4:	90 91 9f 00 	lds	r25, 0x009F
     ec8:	82 33       	cpi	r24, 0x32	; 50
     eca:	91 05       	cpc	r25, r1
     ecc:	09 f0       	breq	.+2      	; 0xed0 <line_follow_till_2+0x56>
     ece:	25 c1       	rjmp	.+586    	; 0x111a <line_follow_till_2+0x2a0>
	{
		forward_mm(150);
     ed0:	86 e9       	ldi	r24, 0x96	; 150
     ed2:	90 e0       	ldi	r25, 0x00	; 0
     ed4:	0e 94 5f 0b 	call	0x16be	; 0x16be <forward_mm>
		event=1;
     ed8:	81 e0       	ldi	r24, 0x01	; 1
     eda:	90 e0       	ldi	r25, 0x00	; 0
     edc:	90 93 9d 00 	sts	0x009D, r25
     ee0:	80 93 9c 00 	sts	0x009C, r24
  */ 

void line_follow_till_2(unsigned int req_pos)
{
	if(((req_pos == 13) && (set_cover == 0)) || ((req_pos == 7) && (set_cover == 50)))
	{
     ee4:	27 c1       	rjmp	.+590    	; 0x1134 <line_follow_till_2+0x2ba>
	}
	else
	{
		while(curr_pos!=req_pos)
		{
			Left_white_line = ADC_Conversion(3);
     ee6:	83 e0       	ldi	r24, 0x03	; 3
     ee8:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     eec:	80 93 79 00 	sts	0x0079, r24
			Center_white_line = ADC_Conversion(4);
     ef0:	84 e0       	ldi	r24, 0x04	; 4
     ef2:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     ef6:	80 93 78 00 	sts	0x0078, r24
			Right_white_line = ADC_Conversion(5);
     efa:	85 e0       	ldi	r24, 0x05	; 5
     efc:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     f00:	80 93 77 00 	sts	0x0077, r24
			error = Right_white_line - Left_white_line;
     f04:	90 e0       	ldi	r25, 0x00	; 0
     f06:	20 91 79 00 	lds	r18, 0x0079
     f0a:	82 1b       	sub	r24, r18
     f0c:	91 09       	sbc	r25, r1
     f0e:	90 93 13 01 	sts	0x0113, r25
     f12:	80 93 12 01 	sts	0x0112, r24
			int motorSpeed = Kp * error + Kd * (error - lastError);
     f16:	60 91 12 01 	lds	r22, 0x0112
     f1a:	70 91 13 01 	lds	r23, 0x0113
     f1e:	c0 90 67 00 	lds	r12, 0x0067
     f22:	d0 90 68 00 	lds	r13, 0x0068
     f26:	e0 90 69 00 	lds	r14, 0x0069
     f2a:	f0 90 6a 00 	lds	r15, 0x006A
     f2e:	c0 91 12 01 	lds	r28, 0x0112
     f32:	d0 91 13 01 	lds	r29, 0x0113
     f36:	00 91 7a 00 	lds	r16, 0x007A
     f3a:	10 91 7b 00 	lds	r17, 0x007B
     f3e:	80 90 63 00 	lds	r8, 0x0063
     f42:	90 90 64 00 	lds	r9, 0x0064
     f46:	a0 90 65 00 	lds	r10, 0x0065
     f4a:	b0 90 66 00 	lds	r11, 0x0066
     f4e:	88 27       	eor	r24, r24
     f50:	77 fd       	sbrc	r23, 7
     f52:	80 95       	com	r24
     f54:	98 2f       	mov	r25, r24
     f56:	0e 94 39 18 	call	0x3072	; 0x3072 <__floatsisf>
     f5a:	a7 01       	movw	r20, r14
     f5c:	96 01       	movw	r18, r12
     f5e:	0e 94 c5 18 	call	0x318a	; 0x318a <__mulsf3>
     f62:	6b 01       	movw	r12, r22
     f64:	7c 01       	movw	r14, r24
     f66:	be 01       	movw	r22, r28
     f68:	60 1b       	sub	r22, r16
     f6a:	71 0b       	sbc	r23, r17
     f6c:	88 27       	eor	r24, r24
     f6e:	77 fd       	sbrc	r23, 7
     f70:	80 95       	com	r24
     f72:	98 2f       	mov	r25, r24
     f74:	0e 94 39 18 	call	0x3072	; 0x3072 <__floatsisf>
     f78:	a5 01       	movw	r20, r10
     f7a:	94 01       	movw	r18, r8
     f7c:	0e 94 c5 18 	call	0x318a	; 0x318a <__mulsf3>
     f80:	9b 01       	movw	r18, r22
     f82:	ac 01       	movw	r20, r24
     f84:	c7 01       	movw	r24, r14
     f86:	b6 01       	movw	r22, r12
     f88:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <__addsf3>
     f8c:	0e 94 06 18 	call	0x300c	; 0x300c <__fixsfsi>
     f90:	dc 01       	movw	r26, r24
     f92:	cb 01       	movw	r24, r22
			lastError = error;
     f94:	20 91 12 01 	lds	r18, 0x0112
     f98:	30 91 13 01 	lds	r19, 0x0113
     f9c:	30 93 7b 00 	sts	0x007B, r19
     fa0:	20 93 7a 00 	sts	0x007A, r18
			int rightMotorSpeed = rightBaseSpeed - motorSpeed;
     fa4:	00 91 62 00 	lds	r16, 0x0062
     fa8:	10 e0       	ldi	r17, 0x00	; 0
			int leftMotorSpeed = leftBaseSpeed + motorSpeed;
     faa:	20 91 61 00 	lds	r18, 0x0061
     fae:	ec 01       	movw	r28, r24
     fb0:	c2 0f       	add	r28, r18
     fb2:	d1 1d       	adc	r29, r1
     fb4:	08 1b       	sub	r16, r24
     fb6:	19 0b       	sbc	r17, r25
     fb8:	08 33       	cpi	r16, 0x38	; 56
     fba:	11 05       	cpc	r17, r1
     fbc:	14 f0       	brlt	.+4      	; 0xfc2 <line_follow_till_2+0x148>
     fbe:	07 e3       	ldi	r16, 0x37	; 55
     fc0:	10 e0       	ldi	r17, 0x00	; 0
     fc2:	c8 33       	cpi	r28, 0x38	; 56
     fc4:	d1 05       	cpc	r29, r1
     fc6:	14 f0       	brlt	.+4      	; 0xfcc <line_follow_till_2+0x152>
     fc8:	c7 e3       	ldi	r28, 0x37	; 55
     fca:	d0 e0       	ldi	r29, 0x00	; 0
			if (rightMotorSpeed > rightMaxSpeed ) rightMotorSpeed = rightMaxSpeed;
			if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
			if (rightMotorSpeed < 0) rightMotorSpeed = 0;
			if (leftMotorSpeed < 0) leftMotorSpeed = 0;

			forward();
     fcc:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <forward>
			velocity(leftMotorSpeed,rightMotorSpeed);
     fd0:	ce 01       	movw	r24, r28
     fd2:	dd 23       	and	r29, r29
     fd4:	0c f4       	brge	.+2      	; 0xfd8 <line_follow_till_2+0x15e>
     fd6:	c2 01       	movw	r24, r4
     fd8:	b8 01       	movw	r22, r16
     fda:	11 23       	and	r17, r17
     fdc:	0c f4       	brge	.+2      	; 0xfe0 <line_follow_till_2+0x166>
     fde:	b2 01       	movw	r22, r4
     fe0:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>

			if(Center_white_line>100 && Left_white_line>100 && Right_white_line>100)
     fe4:	80 91 78 00 	lds	r24, 0x0078
     fe8:	85 36       	cpi	r24, 0x65	; 101
     fea:	08 f4       	brcc	.+2      	; 0xfee <line_follow_till_2+0x174>
     fec:	9b c0       	rjmp	.+310    	; 0x1124 <line_follow_till_2+0x2aa>
     fee:	80 91 79 00 	lds	r24, 0x0079
     ff2:	85 36       	cpi	r24, 0x65	; 101
     ff4:	08 f4       	brcc	.+2      	; 0xff8 <line_follow_till_2+0x17e>
     ff6:	96 c0       	rjmp	.+300    	; 0x1124 <line_follow_till_2+0x2aa>
     ff8:	80 91 77 00 	lds	r24, 0x0077
     ffc:	85 36       	cpi	r24, 0x65	; 101
     ffe:	08 f4       	brcc	.+2      	; 0x1002 <line_follow_till_2+0x188>
    1000:	91 c0       	rjmp	.+290    	; 0x1124 <line_follow_till_2+0x2aa>
			{
				update_curr_pos();
    1002:	0e 94 8f 00 	call	0x11e	; 0x11e <update_curr_pos>
				//velocity(40,40);
				//_delay_ms(300);
				stop();
    1006:	0e 94 b9 0a 	call	0x1572	; 0x1572 <stop>
				buzz();
    100a:	0e 94 02 02 	call	0x404	; 0x404 <buzz>
				
				
				if((curr_pos==req_pos) && (curr_pos!=13) && (curr_pos!=7))
    100e:	80 91 b4 00 	lds	r24, 0x00B4
    1012:	90 91 b5 00 	lds	r25, 0x00B5
    1016:	86 15       	cp	r24, r6
    1018:	97 05       	cpc	r25, r7
    101a:	c9 f4       	brne	.+50     	; 0x104e <line_follow_till_2+0x1d4>
    101c:	80 91 b4 00 	lds	r24, 0x00B4
    1020:	90 91 b5 00 	lds	r25, 0x00B5
    1024:	8d 30       	cpi	r24, 0x0D	; 13
    1026:	91 05       	cpc	r25, r1
    1028:	91 f0       	breq	.+36     	; 0x104e <line_follow_till_2+0x1d4>
    102a:	80 91 b4 00 	lds	r24, 0x00B4
    102e:	90 91 b5 00 	lds	r25, 0x00B5
    1032:	87 30       	cpi	r24, 0x07	; 7
    1034:	91 05       	cpc	r25, r1
    1036:	59 f0       	breq	.+22     	; 0x104e <line_follow_till_2+0x1d4>
				{
					forward_mm(170);
    1038:	8a ea       	ldi	r24, 0xAA	; 170
    103a:	90 e0       	ldi	r25, 0x00	; 0
    103c:	0e 94 5f 0b 	call	0x16be	; 0x16be <forward_mm>
					event=1;
    1040:	a1 e0       	ldi	r26, 0x01	; 1
    1042:	b0 e0       	ldi	r27, 0x00	; 0
    1044:	b0 93 9d 00 	sts	0x009D, r27
    1048:	a0 93 9c 00 	sts	0x009C, r26
				stop();
				buzz();
				
				
				if((curr_pos==req_pos) && (curr_pos!=13) && (curr_pos!=7))
				{
    104c:	5c c0       	rjmp	.+184    	; 0x1106 <line_follow_till_2+0x28c>
					forward_mm(170);
					event=1;
				}
				else if((curr_pos==req_pos) && (curr_pos==7))
    104e:	80 91 b4 00 	lds	r24, 0x00B4
    1052:	90 91 b5 00 	lds	r25, 0x00B5
    1056:	86 15       	cp	r24, r6
    1058:	97 05       	cpc	r25, r7
    105a:	d1 f4       	brne	.+52     	; 0x1090 <line_follow_till_2+0x216>
    105c:	80 91 b4 00 	lds	r24, 0x00B4
    1060:	90 91 b5 00 	lds	r25, 0x00B5
    1064:	87 30       	cpi	r24, 0x07	; 7
    1066:	91 05       	cpc	r25, r1
    1068:	99 f4       	brne	.+38     	; 0x1090 <line_follow_till_2+0x216>
				{
					ensure_orient(1);
    106a:	81 e0       	ldi	r24, 0x01	; 1
    106c:	90 e0       	ldi	r25, 0x00	; 0
    106e:	0e 94 bd 0a 	call	0x157a	; 0x157a <ensure_orient>
					set_cover = 50;
    1072:	e2 e3       	ldi	r30, 0x32	; 50
    1074:	f0 e0       	ldi	r31, 0x00	; 0
    1076:	f0 93 9f 00 	sts	0x009F, r31
    107a:	e0 93 9e 00 	sts	0x009E, r30
					array_index = 0;
    107e:	50 92 8d 00 	sts	0x008D, r5
    1082:	40 92 8c 00 	sts	0x008C, r4
					event=0;
    1086:	50 92 9d 00 	sts	0x009D, r5
    108a:	40 92 9c 00 	sts	0x009C, r4
				{
					forward_mm(170);
					event=1;
				}
				else if((curr_pos==req_pos) && (curr_pos==7))
				{
    108e:	3b c0       	rjmp	.+118    	; 0x1106 <line_follow_till_2+0x28c>
					ensure_orient(1);
					set_cover = 50;
					array_index = 0;
					event=0;
				}
				else if((curr_pos==req_pos) && (curr_pos==13))
    1090:	80 91 b4 00 	lds	r24, 0x00B4
    1094:	90 91 b5 00 	lds	r25, 0x00B5
    1098:	86 15       	cp	r24, r6
    109a:	97 05       	cpc	r25, r7
    109c:	91 f5       	brne	.+100    	; 0x1102 <line_follow_till_2+0x288>
    109e:	80 91 b4 00 	lds	r24, 0x00B4
    10a2:	90 91 b5 00 	lds	r25, 0x00B5
    10a6:	8d 30       	cpi	r24, 0x0D	; 13
    10a8:	91 05       	cpc	r25, r1
    10aa:	59 f5       	brne	.+86     	; 0x1102 <line_follow_till_2+0x288>
				{
					ensure_orient(3);
    10ac:	83 e0       	ldi	r24, 0x03	; 3
    10ae:	90 e0       	ldi	r25, 0x00	; 0
    10b0:	0e 94 bd 0a 	call	0x157a	; 0x157a <ensure_orient>
					UDR = 0x40;
    10b4:	3c b8       	out	0x0c, r3	; 12
    10b6:	8f ef       	ldi	r24, 0xFF	; 255
    10b8:	9f e3       	ldi	r25, 0x3F	; 63
    10ba:	a2 e0       	ldi	r26, 0x02	; 2
    10bc:	81 50       	subi	r24, 0x01	; 1
    10be:	90 40       	sbci	r25, 0x00	; 0
    10c0:	a0 40       	sbci	r26, 0x00	; 0
    10c2:	e1 f7       	brne	.-8      	; 0x10bc <line_follow_till_2+0x242>
    10c4:	00 c0       	rjmp	.+0      	; 0x10c6 <line_follow_till_2+0x24c>
    10c6:	00 00       	nop
					_delay_ms(100);
					UDR = 0x40;
    10c8:	3c b8       	out	0x0c, r3	; 12
    10ca:	8f ef       	ldi	r24, 0xFF	; 255
    10cc:	9f e3       	ldi	r25, 0x3F	; 63
    10ce:	a2 e0       	ldi	r26, 0x02	; 2
    10d0:	81 50       	subi	r24, 0x01	; 1
    10d2:	90 40       	sbci	r25, 0x00	; 0
    10d4:	a0 40       	sbci	r26, 0x00	; 0
    10d6:	e1 f7       	brne	.-8      	; 0x10d0 <line_follow_till_2+0x256>
    10d8:	00 c0       	rjmp	.+0      	; 0x10da <line_follow_till_2+0x260>
    10da:	00 00       	nop
					_delay_ms(100);
					UDR = 0x40;
    10dc:	3c b8       	out	0x0c, r3	; 12
					home_bit[0]=1;
    10de:	e1 e0       	ldi	r30, 0x01	; 1
    10e0:	f0 e0       	ldi	r31, 0x00	; 0
    10e2:	a4 ea       	ldi	r26, 0xA4	; 164
    10e4:	b0 e0       	ldi	r27, 0x00	; 0
    10e6:	11 96       	adiw	r26, 0x01	; 1
    10e8:	fc 93       	st	X, r31
    10ea:	ee 93       	st	-X, r30
					event=2;
    10ec:	82 e0       	ldi	r24, 0x02	; 2
    10ee:	90 e0       	ldi	r25, 0x00	; 0
    10f0:	90 93 9d 00 	sts	0x009D, r25
    10f4:	80 93 9c 00 	sts	0x009C, r24
					start_flag = 1;
    10f8:	f0 93 18 01 	sts	0x0118, r31
    10fc:	e0 93 17 01 	sts	0x0117, r30
					set_cover = 50;
					array_index = 0;
					event=0;
				}
				else if((curr_pos==req_pos) && (curr_pos==13))
				{
    1100:	02 c0       	rjmp	.+4      	; 0x1106 <line_follow_till_2+0x28c>
				else
				{
					//forward();
					//velocity(100,100);
					//_delay_ms(300);
					just_forward();
    1102:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
				}
				if(curr_pos == 11)
    1106:	80 91 b4 00 	lds	r24, 0x00B4
    110a:	90 91 b5 00 	lds	r25, 0x00B5
    110e:	8b 30       	cpi	r24, 0x0B	; 11
    1110:	91 05       	cpc	r25, r1
    1112:	41 f4       	brne	.+16     	; 0x1124 <line_follow_till_2+0x2aa>
				{
					all_xbee_clear();
    1114:	0e 94 df 00 	call	0x1be	; 0x1be <all_xbee_clear>
    1118:	05 c0       	rjmp	.+10     	; 0x1124 <line_follow_till_2+0x2aa>
			if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
			if (rightMotorSpeed < 0) rightMotorSpeed = 0;
			if (leftMotorSpeed < 0) leftMotorSpeed = 0;

			forward();
			velocity(leftMotorSpeed,rightMotorSpeed);
    111a:	44 24       	eor	r4, r4
    111c:	55 24       	eor	r5, r5
					event=0;
				}
				else if((curr_pos==req_pos) && (curr_pos==13))
				{
					ensure_orient(3);
					UDR = 0x40;
    111e:	33 24       	eor	r3, r3
    1120:	68 94       	set
    1122:	36 f8       	bld	r3, 6
		forward_mm(150);
		event=1;
	}
	else
	{
		while(curr_pos!=req_pos)
    1124:	80 91 b4 00 	lds	r24, 0x00B4
    1128:	90 91 b5 00 	lds	r25, 0x00B5
    112c:	86 15       	cp	r24, r6
    112e:	97 05       	cpc	r25, r7
    1130:	09 f0       	breq	.+2      	; 0x1134 <line_follow_till_2+0x2ba>
    1132:	d9 ce       	rjmp	.-590    	; 0xee6 <line_follow_till_2+0x6c>
					all_xbee_clear();
				}
			}
		}
	}
}
    1134:	df 91       	pop	r29
    1136:	cf 91       	pop	r28
    1138:	1f 91       	pop	r17
    113a:	0f 91       	pop	r16
    113c:	ff 90       	pop	r15
    113e:	ef 90       	pop	r14
    1140:	df 90       	pop	r13
    1142:	cf 90       	pop	r12
    1144:	bf 90       	pop	r11
    1146:	af 90       	pop	r10
    1148:	9f 90       	pop	r9
    114a:	8f 90       	pop	r8
    114c:	7f 90       	pop	r7
    114e:	6f 90       	pop	r6
    1150:	5f 90       	pop	r5
    1152:	4f 90       	pop	r4
    1154:	3f 90       	pop	r3
    1156:	08 95       	ret

00001158 <line_follow_till_1>:
           If their are no plants it will simply traverse the other end of the set and come back to the start of the start, i.e., node 41.
  * Example Call: line_follow_till_1()
  */ 

void line_follow_till_1(unsigned int req_pos)
{
    1158:	3f 92       	push	r3
    115a:	4f 92       	push	r4
    115c:	5f 92       	push	r5
    115e:	6f 92       	push	r6
    1160:	7f 92       	push	r7
    1162:	8f 92       	push	r8
    1164:	9f 92       	push	r9
    1166:	af 92       	push	r10
    1168:	bf 92       	push	r11
    116a:	cf 92       	push	r12
    116c:	df 92       	push	r13
    116e:	ef 92       	push	r14
    1170:	ff 92       	push	r15
    1172:	0f 93       	push	r16
    1174:	1f 93       	push	r17
    1176:	cf 93       	push	r28
    1178:	df 93       	push	r29
    117a:	3c 01       	movw	r6, r24
	if(((req_pos == 41) && (set_cover == 0)) || ((req_pos == 35) && (set_cover == 50)))
    117c:	89 e2       	ldi	r24, 0x29	; 41
    117e:	68 16       	cp	r6, r24
    1180:	71 04       	cpc	r7, r1
    1182:	41 f4       	brne	.+16     	; 0x1194 <line_follow_till_1+0x3c>
    1184:	80 91 9e 00 	lds	r24, 0x009E
    1188:	90 91 9f 00 	lds	r25, 0x009F
    118c:	00 97       	sbiw	r24, 0x00	; 0
    118e:	09 f0       	breq	.+2      	; 0x1192 <line_follow_till_1+0x3a>
    1190:	33 c1       	rjmp	.+614    	; 0x13f8 <line_follow_till_1+0x2a0>
    1192:	0d c0       	rjmp	.+26     	; 0x11ae <line_follow_till_1+0x56>
    1194:	93 e2       	ldi	r25, 0x23	; 35
    1196:	69 16       	cp	r6, r25
    1198:	71 04       	cpc	r7, r1
    119a:	09 f0       	breq	.+2      	; 0x119e <line_follow_till_1+0x46>
    119c:	2d c1       	rjmp	.+602    	; 0x13f8 <line_follow_till_1+0x2a0>
    119e:	80 91 9e 00 	lds	r24, 0x009E
    11a2:	90 91 9f 00 	lds	r25, 0x009F
    11a6:	82 33       	cpi	r24, 0x32	; 50
    11a8:	91 05       	cpc	r25, r1
    11aa:	09 f0       	breq	.+2      	; 0x11ae <line_follow_till_1+0x56>
    11ac:	25 c1       	rjmp	.+586    	; 0x13f8 <line_follow_till_1+0x2a0>
	{
		forward_mm(150);
    11ae:	86 e9       	ldi	r24, 0x96	; 150
    11b0:	90 e0       	ldi	r25, 0x00	; 0
    11b2:	0e 94 5f 0b 	call	0x16be	; 0x16be <forward_mm>
		event=1;
    11b6:	81 e0       	ldi	r24, 0x01	; 1
    11b8:	90 e0       	ldi	r25, 0x00	; 0
    11ba:	90 93 9d 00 	sts	0x009D, r25
    11be:	80 93 9c 00 	sts	0x009C, r24
  */ 

void line_follow_till_1(unsigned int req_pos)
{
	if(((req_pos == 41) && (set_cover == 0)) || ((req_pos == 35) && (set_cover == 50)))
	{
    11c2:	27 c1       	rjmp	.+590    	; 0x1412 <line_follow_till_1+0x2ba>
	}
	else
	{
		while(curr_pos!=req_pos)
		{
			Left_white_line = ADC_Conversion(3);
    11c4:	83 e0       	ldi	r24, 0x03	; 3
    11c6:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    11ca:	80 93 79 00 	sts	0x0079, r24
			Center_white_line = ADC_Conversion(4);
    11ce:	84 e0       	ldi	r24, 0x04	; 4
    11d0:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    11d4:	80 93 78 00 	sts	0x0078, r24
			Right_white_line = ADC_Conversion(5);
    11d8:	85 e0       	ldi	r24, 0x05	; 5
    11da:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    11de:	80 93 77 00 	sts	0x0077, r24
			error = Right_white_line - Left_white_line;
    11e2:	90 e0       	ldi	r25, 0x00	; 0
    11e4:	20 91 79 00 	lds	r18, 0x0079
    11e8:	82 1b       	sub	r24, r18
    11ea:	91 09       	sbc	r25, r1
    11ec:	90 93 13 01 	sts	0x0113, r25
    11f0:	80 93 12 01 	sts	0x0112, r24
			int motorSpeed = Kp * error + Kd * (error - lastError);
    11f4:	60 91 12 01 	lds	r22, 0x0112
    11f8:	70 91 13 01 	lds	r23, 0x0113
    11fc:	c0 90 67 00 	lds	r12, 0x0067
    1200:	d0 90 68 00 	lds	r13, 0x0068
    1204:	e0 90 69 00 	lds	r14, 0x0069
    1208:	f0 90 6a 00 	lds	r15, 0x006A
    120c:	c0 91 12 01 	lds	r28, 0x0112
    1210:	d0 91 13 01 	lds	r29, 0x0113
    1214:	00 91 7a 00 	lds	r16, 0x007A
    1218:	10 91 7b 00 	lds	r17, 0x007B
    121c:	80 90 63 00 	lds	r8, 0x0063
    1220:	90 90 64 00 	lds	r9, 0x0064
    1224:	a0 90 65 00 	lds	r10, 0x0065
    1228:	b0 90 66 00 	lds	r11, 0x0066
    122c:	88 27       	eor	r24, r24
    122e:	77 fd       	sbrc	r23, 7
    1230:	80 95       	com	r24
    1232:	98 2f       	mov	r25, r24
    1234:	0e 94 39 18 	call	0x3072	; 0x3072 <__floatsisf>
    1238:	a7 01       	movw	r20, r14
    123a:	96 01       	movw	r18, r12
    123c:	0e 94 c5 18 	call	0x318a	; 0x318a <__mulsf3>
    1240:	6b 01       	movw	r12, r22
    1242:	7c 01       	movw	r14, r24
    1244:	be 01       	movw	r22, r28
    1246:	60 1b       	sub	r22, r16
    1248:	71 0b       	sbc	r23, r17
    124a:	88 27       	eor	r24, r24
    124c:	77 fd       	sbrc	r23, 7
    124e:	80 95       	com	r24
    1250:	98 2f       	mov	r25, r24
    1252:	0e 94 39 18 	call	0x3072	; 0x3072 <__floatsisf>
    1256:	a5 01       	movw	r20, r10
    1258:	94 01       	movw	r18, r8
    125a:	0e 94 c5 18 	call	0x318a	; 0x318a <__mulsf3>
    125e:	9b 01       	movw	r18, r22
    1260:	ac 01       	movw	r20, r24
    1262:	c7 01       	movw	r24, r14
    1264:	b6 01       	movw	r22, r12
    1266:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <__addsf3>
    126a:	0e 94 06 18 	call	0x300c	; 0x300c <__fixsfsi>
    126e:	dc 01       	movw	r26, r24
    1270:	cb 01       	movw	r24, r22
			lastError = error;
    1272:	20 91 12 01 	lds	r18, 0x0112
    1276:	30 91 13 01 	lds	r19, 0x0113
    127a:	30 93 7b 00 	sts	0x007B, r19
    127e:	20 93 7a 00 	sts	0x007A, r18
			int rightMotorSpeed = rightBaseSpeed - motorSpeed;
    1282:	00 91 62 00 	lds	r16, 0x0062
    1286:	10 e0       	ldi	r17, 0x00	; 0
			int leftMotorSpeed = leftBaseSpeed + motorSpeed;
    1288:	20 91 61 00 	lds	r18, 0x0061
    128c:	ec 01       	movw	r28, r24
    128e:	c2 0f       	add	r28, r18
    1290:	d1 1d       	adc	r29, r1
    1292:	08 1b       	sub	r16, r24
    1294:	19 0b       	sbc	r17, r25
    1296:	08 33       	cpi	r16, 0x38	; 56
    1298:	11 05       	cpc	r17, r1
    129a:	14 f0       	brlt	.+4      	; 0x12a0 <line_follow_till_1+0x148>
    129c:	07 e3       	ldi	r16, 0x37	; 55
    129e:	10 e0       	ldi	r17, 0x00	; 0
    12a0:	c8 33       	cpi	r28, 0x38	; 56
    12a2:	d1 05       	cpc	r29, r1
    12a4:	14 f0       	brlt	.+4      	; 0x12aa <line_follow_till_1+0x152>
    12a6:	c7 e3       	ldi	r28, 0x37	; 55
    12a8:	d0 e0       	ldi	r29, 0x00	; 0
			if (rightMotorSpeed > rightMaxSpeed ) rightMotorSpeed = rightMaxSpeed;
			if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
			if (rightMotorSpeed < 0) rightMotorSpeed = 0;
			if (leftMotorSpeed < 0) leftMotorSpeed = 0;

			forward();
    12aa:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <forward>
			velocity(leftMotorSpeed,rightMotorSpeed);
    12ae:	ce 01       	movw	r24, r28
    12b0:	dd 23       	and	r29, r29
    12b2:	0c f4       	brge	.+2      	; 0x12b6 <line_follow_till_1+0x15e>
    12b4:	c2 01       	movw	r24, r4
    12b6:	b8 01       	movw	r22, r16
    12b8:	11 23       	and	r17, r17
    12ba:	0c f4       	brge	.+2      	; 0x12be <line_follow_till_1+0x166>
    12bc:	b2 01       	movw	r22, r4
    12be:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>

			if(Center_white_line>100 && Left_white_line>100 && Right_white_line>100)
    12c2:	80 91 78 00 	lds	r24, 0x0078
    12c6:	85 36       	cpi	r24, 0x65	; 101
    12c8:	08 f4       	brcc	.+2      	; 0x12cc <line_follow_till_1+0x174>
    12ca:	9b c0       	rjmp	.+310    	; 0x1402 <line_follow_till_1+0x2aa>
    12cc:	80 91 79 00 	lds	r24, 0x0079
    12d0:	85 36       	cpi	r24, 0x65	; 101
    12d2:	08 f4       	brcc	.+2      	; 0x12d6 <line_follow_till_1+0x17e>
    12d4:	96 c0       	rjmp	.+300    	; 0x1402 <line_follow_till_1+0x2aa>
    12d6:	80 91 77 00 	lds	r24, 0x0077
    12da:	85 36       	cpi	r24, 0x65	; 101
    12dc:	08 f4       	brcc	.+2      	; 0x12e0 <line_follow_till_1+0x188>
    12de:	91 c0       	rjmp	.+290    	; 0x1402 <line_follow_till_1+0x2aa>
			{
				update_curr_pos();
    12e0:	0e 94 8f 00 	call	0x11e	; 0x11e <update_curr_pos>
				
				//velocity(40,40);
				//_delay_ms(300);
				stop();
    12e4:	0e 94 b9 0a 	call	0x1572	; 0x1572 <stop>
				buzz();
    12e8:	0e 94 02 02 	call	0x404	; 0x404 <buzz>
				
				
				if((curr_pos==req_pos) && (curr_pos!=41) && (curr_pos!=35))
    12ec:	80 91 b4 00 	lds	r24, 0x00B4
    12f0:	90 91 b5 00 	lds	r25, 0x00B5
    12f4:	86 15       	cp	r24, r6
    12f6:	97 05       	cpc	r25, r7
    12f8:	c9 f4       	brne	.+50     	; 0x132c <line_follow_till_1+0x1d4>
    12fa:	80 91 b4 00 	lds	r24, 0x00B4
    12fe:	90 91 b5 00 	lds	r25, 0x00B5
    1302:	89 32       	cpi	r24, 0x29	; 41
    1304:	91 05       	cpc	r25, r1
    1306:	91 f0       	breq	.+36     	; 0x132c <line_follow_till_1+0x1d4>
    1308:	80 91 b4 00 	lds	r24, 0x00B4
    130c:	90 91 b5 00 	lds	r25, 0x00B5
    1310:	83 32       	cpi	r24, 0x23	; 35
    1312:	91 05       	cpc	r25, r1
    1314:	59 f0       	breq	.+22     	; 0x132c <line_follow_till_1+0x1d4>
				{
					forward_mm(170);
    1316:	8a ea       	ldi	r24, 0xAA	; 170
    1318:	90 e0       	ldi	r25, 0x00	; 0
    131a:	0e 94 5f 0b 	call	0x16be	; 0x16be <forward_mm>
					event=1;
    131e:	a1 e0       	ldi	r26, 0x01	; 1
    1320:	b0 e0       	ldi	r27, 0x00	; 0
    1322:	b0 93 9d 00 	sts	0x009D, r27
    1326:	a0 93 9c 00 	sts	0x009C, r26
				stop();
				buzz();
				
				
				if((curr_pos==req_pos) && (curr_pos!=41) && (curr_pos!=35))
				{
    132a:	5c c0       	rjmp	.+184    	; 0x13e4 <line_follow_till_1+0x28c>
					forward_mm(170);
					event=1;
				}
				else if((curr_pos==req_pos) && (curr_pos==35))
    132c:	80 91 b4 00 	lds	r24, 0x00B4
    1330:	90 91 b5 00 	lds	r25, 0x00B5
    1334:	86 15       	cp	r24, r6
    1336:	97 05       	cpc	r25, r7
    1338:	d1 f4       	brne	.+52     	; 0x136e <line_follow_till_1+0x216>
    133a:	80 91 b4 00 	lds	r24, 0x00B4
    133e:	90 91 b5 00 	lds	r25, 0x00B5
    1342:	83 32       	cpi	r24, 0x23	; 35
    1344:	91 05       	cpc	r25, r1
    1346:	99 f4       	brne	.+38     	; 0x136e <line_follow_till_1+0x216>
				{
					ensure_orient(1);
    1348:	81 e0       	ldi	r24, 0x01	; 1
    134a:	90 e0       	ldi	r25, 0x00	; 0
    134c:	0e 94 bd 0a 	call	0x157a	; 0x157a <ensure_orient>
					event = 0;
    1350:	50 92 9d 00 	sts	0x009D, r5
    1354:	40 92 9c 00 	sts	0x009C, r4
					set_cover = 50;
    1358:	e2 e3       	ldi	r30, 0x32	; 50
    135a:	f0 e0       	ldi	r31, 0x00	; 0
    135c:	f0 93 9f 00 	sts	0x009F, r31
    1360:	e0 93 9e 00 	sts	0x009E, r30
					array_index = 0;
    1364:	50 92 8d 00 	sts	0x008D, r5
    1368:	40 92 8c 00 	sts	0x008C, r4
				{
					forward_mm(170);
					event=1;
				}
				else if((curr_pos==req_pos) && (curr_pos==35))
				{
    136c:	3b c0       	rjmp	.+118    	; 0x13e4 <line_follow_till_1+0x28c>
					ensure_orient(1);
					event = 0;
					set_cover = 50;
					array_index = 0;
				}
				else if((curr_pos==req_pos) && (curr_pos==41))
    136e:	80 91 b4 00 	lds	r24, 0x00B4
    1372:	90 91 b5 00 	lds	r25, 0x00B5
    1376:	86 15       	cp	r24, r6
    1378:	97 05       	cpc	r25, r7
    137a:	91 f5       	brne	.+100    	; 0x13e0 <line_follow_till_1+0x288>
    137c:	80 91 b4 00 	lds	r24, 0x00B4
    1380:	90 91 b5 00 	lds	r25, 0x00B5
    1384:	89 32       	cpi	r24, 0x29	; 41
    1386:	91 05       	cpc	r25, r1
    1388:	59 f5       	brne	.+86     	; 0x13e0 <line_follow_till_1+0x288>
				{
					ensure_orient(3);
    138a:	83 e0       	ldi	r24, 0x03	; 3
    138c:	90 e0       	ldi	r25, 0x00	; 0
    138e:	0e 94 bd 0a 	call	0x157a	; 0x157a <ensure_orient>
					UDR = 0x40;
    1392:	3c b8       	out	0x0c, r3	; 12
    1394:	8f ef       	ldi	r24, 0xFF	; 255
    1396:	9f e3       	ldi	r25, 0x3F	; 63
    1398:	a2 e0       	ldi	r26, 0x02	; 2
    139a:	81 50       	subi	r24, 0x01	; 1
    139c:	90 40       	sbci	r25, 0x00	; 0
    139e:	a0 40       	sbci	r26, 0x00	; 0
    13a0:	e1 f7       	brne	.-8      	; 0x139a <line_follow_till_1+0x242>
    13a2:	00 c0       	rjmp	.+0      	; 0x13a4 <line_follow_till_1+0x24c>
    13a4:	00 00       	nop
					_delay_ms(100);
					UDR = 0x40;
    13a6:	3c b8       	out	0x0c, r3	; 12
    13a8:	8f ef       	ldi	r24, 0xFF	; 255
    13aa:	9f e3       	ldi	r25, 0x3F	; 63
    13ac:	a2 e0       	ldi	r26, 0x02	; 2
    13ae:	81 50       	subi	r24, 0x01	; 1
    13b0:	90 40       	sbci	r25, 0x00	; 0
    13b2:	a0 40       	sbci	r26, 0x00	; 0
    13b4:	e1 f7       	brne	.-8      	; 0x13ae <line_follow_till_1+0x256>
    13b6:	00 c0       	rjmp	.+0      	; 0x13b8 <line_follow_till_1+0x260>
    13b8:	00 00       	nop
					_delay_ms(100);
					UDR = 0x40;
    13ba:	3c b8       	out	0x0c, r3	; 12
					home_bit[0]=1;
    13bc:	e1 e0       	ldi	r30, 0x01	; 1
    13be:	f0 e0       	ldi	r31, 0x00	; 0
    13c0:	a4 ea       	ldi	r26, 0xA4	; 164
    13c2:	b0 e0       	ldi	r27, 0x00	; 0
    13c4:	11 96       	adiw	r26, 0x01	; 1
    13c6:	fc 93       	st	X, r31
    13c8:	ee 93       	st	-X, r30
					event=2;
    13ca:	82 e0       	ldi	r24, 0x02	; 2
    13cc:	90 e0       	ldi	r25, 0x00	; 0
    13ce:	90 93 9d 00 	sts	0x009D, r25
    13d2:	80 93 9c 00 	sts	0x009C, r24
					start_flag = 1;
    13d6:	f0 93 18 01 	sts	0x0118, r31
    13da:	e0 93 17 01 	sts	0x0117, r30
					event = 0;
					set_cover = 50;
					array_index = 0;
				}
				else if((curr_pos==req_pos) && (curr_pos==41))
				{
    13de:	02 c0       	rjmp	.+4      	; 0x13e4 <line_follow_till_1+0x28c>
				else
				{
					//forward();
					//velocity(100,100);
					//_delay_ms(300);
					just_forward();
    13e0:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
				}
				if(curr_pos == 39)
    13e4:	80 91 b4 00 	lds	r24, 0x00B4
    13e8:	90 91 b5 00 	lds	r25, 0x00B5
    13ec:	87 32       	cpi	r24, 0x27	; 39
    13ee:	91 05       	cpc	r25, r1
    13f0:	41 f4       	brne	.+16     	; 0x1402 <line_follow_till_1+0x2aa>
				{
					all_xbee_clear();
    13f2:	0e 94 df 00 	call	0x1be	; 0x1be <all_xbee_clear>
    13f6:	05 c0       	rjmp	.+10     	; 0x1402 <line_follow_till_1+0x2aa>
			if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
			if (rightMotorSpeed < 0) rightMotorSpeed = 0;
			if (leftMotorSpeed < 0) leftMotorSpeed = 0;

			forward();
			velocity(leftMotorSpeed,rightMotorSpeed);
    13f8:	44 24       	eor	r4, r4
    13fa:	55 24       	eor	r5, r5
					array_index = 0;
				}
				else if((curr_pos==req_pos) && (curr_pos==41))
				{
					ensure_orient(3);
					UDR = 0x40;
    13fc:	33 24       	eor	r3, r3
    13fe:	68 94       	set
    1400:	36 f8       	bld	r3, 6
		forward_mm(150);
		event=1;
	}
	else
	{
		while(curr_pos!=req_pos)
    1402:	80 91 b4 00 	lds	r24, 0x00B4
    1406:	90 91 b5 00 	lds	r25, 0x00B5
    140a:	86 15       	cp	r24, r6
    140c:	97 05       	cpc	r25, r7
    140e:	09 f0       	breq	.+2      	; 0x1412 <line_follow_till_1+0x2ba>
    1410:	d9 ce       	rjmp	.-590    	; 0x11c4 <line_follow_till_1+0x6c>
				}
			}
		}
	}
	
}
    1412:	df 91       	pop	r29
    1414:	cf 91       	pop	r28
    1416:	1f 91       	pop	r17
    1418:	0f 91       	pop	r16
    141a:	ff 90       	pop	r15
    141c:	ef 90       	pop	r14
    141e:	df 90       	pop	r13
    1420:	cf 90       	pop	r12
    1422:	bf 90       	pop	r11
    1424:	af 90       	pop	r10
    1426:	9f 90       	pop	r9
    1428:	8f 90       	pop	r8
    142a:	7f 90       	pop	r7
    142c:	6f 90       	pop	r6
    142e:	5f 90       	pop	r5
    1430:	4f 90       	pop	r4
    1432:	3f 90       	pop	r3
    1434:	08 95       	ret

00001436 <just_line>:
		}
	}	 
}

void just_line()
{
    1436:	8f 92       	push	r8
    1438:	9f 92       	push	r9
    143a:	af 92       	push	r10
    143c:	bf 92       	push	r11
    143e:	cf 92       	push	r12
    1440:	df 92       	push	r13
    1442:	ef 92       	push	r14
    1444:	ff 92       	push	r15
    1446:	0f 93       	push	r16
    1448:	1f 93       	push	r17
    144a:	cf 93       	push	r28
    144c:	df 93       	push	r29
	Left_white_line = ADC_Conversion(3);
    144e:	83 e0       	ldi	r24, 0x03	; 3
    1450:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    1454:	80 93 79 00 	sts	0x0079, r24
	Center_white_line = ADC_Conversion(4);
    1458:	84 e0       	ldi	r24, 0x04	; 4
    145a:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    145e:	80 93 78 00 	sts	0x0078, r24
	Right_white_line = ADC_Conversion(5);
    1462:	85 e0       	ldi	r24, 0x05	; 5
    1464:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    1468:	80 93 77 00 	sts	0x0077, r24
	error = Right_white_line - Left_white_line;
    146c:	90 e0       	ldi	r25, 0x00	; 0
    146e:	20 91 79 00 	lds	r18, 0x0079
    1472:	82 1b       	sub	r24, r18
    1474:	91 09       	sbc	r25, r1
    1476:	90 93 13 01 	sts	0x0113, r25
    147a:	80 93 12 01 	sts	0x0112, r24
	int motorSpeed = Kp * error + Kd * (error - lastError);
    147e:	60 91 12 01 	lds	r22, 0x0112
    1482:	70 91 13 01 	lds	r23, 0x0113
    1486:	c0 90 67 00 	lds	r12, 0x0067
    148a:	d0 90 68 00 	lds	r13, 0x0068
    148e:	e0 90 69 00 	lds	r14, 0x0069
    1492:	f0 90 6a 00 	lds	r15, 0x006A
    1496:	c0 91 12 01 	lds	r28, 0x0112
    149a:	d0 91 13 01 	lds	r29, 0x0113
    149e:	00 91 7a 00 	lds	r16, 0x007A
    14a2:	10 91 7b 00 	lds	r17, 0x007B
    14a6:	80 90 63 00 	lds	r8, 0x0063
    14aa:	90 90 64 00 	lds	r9, 0x0064
    14ae:	a0 90 65 00 	lds	r10, 0x0065
    14b2:	b0 90 66 00 	lds	r11, 0x0066
    14b6:	88 27       	eor	r24, r24
    14b8:	77 fd       	sbrc	r23, 7
    14ba:	80 95       	com	r24
    14bc:	98 2f       	mov	r25, r24
    14be:	0e 94 39 18 	call	0x3072	; 0x3072 <__floatsisf>
    14c2:	a7 01       	movw	r20, r14
    14c4:	96 01       	movw	r18, r12
    14c6:	0e 94 c5 18 	call	0x318a	; 0x318a <__mulsf3>
    14ca:	6b 01       	movw	r12, r22
    14cc:	7c 01       	movw	r14, r24
    14ce:	be 01       	movw	r22, r28
    14d0:	60 1b       	sub	r22, r16
    14d2:	71 0b       	sbc	r23, r17
    14d4:	88 27       	eor	r24, r24
    14d6:	77 fd       	sbrc	r23, 7
    14d8:	80 95       	com	r24
    14da:	98 2f       	mov	r25, r24
    14dc:	0e 94 39 18 	call	0x3072	; 0x3072 <__floatsisf>
    14e0:	a5 01       	movw	r20, r10
    14e2:	94 01       	movw	r18, r8
    14e4:	0e 94 c5 18 	call	0x318a	; 0x318a <__mulsf3>
    14e8:	9b 01       	movw	r18, r22
    14ea:	ac 01       	movw	r20, r24
    14ec:	c7 01       	movw	r24, r14
    14ee:	b6 01       	movw	r22, r12
    14f0:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <__addsf3>
    14f4:	0e 94 06 18 	call	0x300c	; 0x300c <__fixsfsi>
	lastError = error;
    14f8:	80 91 12 01 	lds	r24, 0x0112
    14fc:	90 91 13 01 	lds	r25, 0x0113
    1500:	90 93 7b 00 	sts	0x007B, r25
    1504:	80 93 7a 00 	sts	0x007A, r24
	int rightMotorSpeed = rightBaseSpeed - motorSpeed;
    1508:	00 91 62 00 	lds	r16, 0x0062
    150c:	10 e0       	ldi	r17, 0x00	; 0
	int leftMotorSpeed = leftBaseSpeed + motorSpeed;
    150e:	80 91 61 00 	lds	r24, 0x0061
    1512:	eb 01       	movw	r28, r22
    1514:	c8 0f       	add	r28, r24
    1516:	d1 1d       	adc	r29, r1
    1518:	06 1b       	sub	r16, r22
    151a:	17 0b       	sbc	r17, r23
    151c:	08 33       	cpi	r16, 0x38	; 56
    151e:	11 05       	cpc	r17, r1
    1520:	14 f0       	brlt	.+4      	; 0x1526 <just_line+0xf0>
    1522:	07 e3       	ldi	r16, 0x37	; 55
    1524:	10 e0       	ldi	r17, 0x00	; 0
    1526:	c8 33       	cpi	r28, 0x38	; 56
    1528:	d1 05       	cpc	r29, r1
    152a:	14 f0       	brlt	.+4      	; 0x1530 <just_line+0xfa>
    152c:	c7 e3       	ldi	r28, 0x37	; 55
    152e:	d0 e0       	ldi	r29, 0x00	; 0
	if (rightMotorSpeed > rightMaxSpeed ) rightMotorSpeed = rightMaxSpeed;
	if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
	if (rightMotorSpeed < 0) rightMotorSpeed = 0;
	if (leftMotorSpeed < 0) leftMotorSpeed = 0;

	forward();
    1530:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <forward>
	velocity(leftMotorSpeed,rightMotorSpeed);
    1534:	ce 01       	movw	r24, r28
    1536:	dd 23       	and	r29, r29
    1538:	14 f4       	brge	.+4      	; 0x153e <just_line+0x108>
    153a:	80 e0       	ldi	r24, 0x00	; 0
    153c:	90 e0       	ldi	r25, 0x00	; 0
    153e:	b8 01       	movw	r22, r16
    1540:	11 23       	and	r17, r17
    1542:	14 f4       	brge	.+4      	; 0x1548 <just_line+0x112>
    1544:	60 e0       	ldi	r22, 0x00	; 0
    1546:	70 e0       	ldi	r23, 0x00	; 0
    1548:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>
}
    154c:	df 91       	pop	r29
    154e:	cf 91       	pop	r28
    1550:	1f 91       	pop	r17
    1552:	0f 91       	pop	r16
    1554:	ff 90       	pop	r15
    1556:	ef 90       	pop	r14
    1558:	df 90       	pop	r13
    155a:	cf 90       	pop	r12
    155c:	bf 90       	pop	r11
    155e:	af 90       	pop	r10
    1560:	9f 90       	pop	r9
    1562:	8f 90       	pop	r8
    1564:	08 95       	ret

00001566 <motion_set>:
void motion_set (unsigned char Direction)
{
	unsigned char PortBRestore = 0;

	Direction &= 0x0F; 			// removing upper nibbel as it is not needed
	PortBRestore = PORTB; 			// reading the PORTB's original status
    1566:	98 b3       	in	r25, 0x18	; 24
	PortBRestore &= 0xF0; 			// setting lower direction nibbel to 0
    1568:	90 7f       	andi	r25, 0xF0	; 240

void motion_set (unsigned char Direction)
{
	unsigned char PortBRestore = 0;

	Direction &= 0x0F; 			// removing upper nibbel as it is not needed
    156a:	8f 70       	andi	r24, 0x0F	; 15
	PortBRestore = PORTB; 			// reading the PORTB's original status
	PortBRestore &= 0xF0; 			// setting lower direction nibbel to 0
	PortBRestore |= Direction; 	// adding lower nibbel for direction command and restoring the PORTB status
    156c:	98 2b       	or	r25, r24
	PORTB = PortBRestore; 			// setting the command to the port
    156e:	98 bb       	out	0x18, r25	; 24
}
    1570:	08 95       	ret

00001572 <stop>:
  * Logic: This function sets up the motion pins of the bot so that the bot stops
  * Example Call: stop()
  */ 
void stop (void)
{
  motion_set(0x00);
    1572:	80 e0       	ldi	r24, 0x00	; 0
    1574:	0e 94 b3 0a 	call	0x1566	; 0x1566 <motion_set>
}
    1578:	08 95       	ret

0000157a <ensure_orient>:
  * Logic: This function is used for rotating the bot by 90 degrees right till the required orientation is achieved. 
  * Example Call: ensure_orient(0)
  */

void ensure_orient(unsigned int req_orient)
{
    157a:	ef 92       	push	r14
    157c:	ff 92       	push	r15
    157e:	0f 93       	push	r16
    1580:	1f 93       	push	r17
    1582:	cf 93       	push	r28
    1584:	df 93       	push	r29
    1586:	8c 01       	movw	r16, r24
	stop();
    1588:	0e 94 b9 0a 	call	0x1572	; 0x1572 <stop>
	int chethan=0;
    158c:	c0 e0       	ldi	r28, 0x00	; 0
    158e:	d0 e0       	ldi	r29, 0x00	; 0
	{
		if(chethan==0)
		{
			//turn(1);
			turn_right();
			chethan=1;
    1590:	ee 24       	eor	r14, r14
    1592:	ff 24       	eor	r15, r15
    1594:	e3 94       	inc	r14

void ensure_orient(unsigned int req_orient)
{
	stop();
	int chethan=0;
	while(req_orient!=orient)
    1596:	08 c0       	rjmp	.+16     	; 0x15a8 <ensure_orient+0x2e>
	{
		if(chethan==0)
    1598:	20 97       	sbiw	r28, 0x00	; 0
    159a:	21 f4       	brne	.+8      	; 0x15a4 <ensure_orient+0x2a>
		{
			//turn(1);
			turn_right();
    159c:	0e 94 27 01 	call	0x24e	; 0x24e <turn_right>
			chethan=1;
    15a0:	e7 01       	movw	r28, r14
    15a2:	02 c0       	rjmp	.+4      	; 0x15a8 <ensure_orient+0x2e>
		}
		else
		{
			
			turn_right_ensure();
    15a4:	0e 94 9c 04 	call	0x938	; 0x938 <turn_right_ensure>

void ensure_orient(unsigned int req_orient)
{
	stop();
	int chethan=0;
	while(req_orient!=orient)
    15a8:	80 91 f8 00 	lds	r24, 0x00F8
    15ac:	90 91 f9 00 	lds	r25, 0x00F9
    15b0:	08 17       	cp	r16, r24
    15b2:	19 07       	cpc	r17, r25
    15b4:	89 f7       	brne	.-30     	; 0x1598 <ensure_orient+0x1e>
		{
			
			turn_right_ensure();
		}
	}
}
    15b6:	df 91       	pop	r29
    15b8:	cf 91       	pop	r28
    15ba:	1f 91       	pop	r17
    15bc:	0f 91       	pop	r16
    15be:	ff 90       	pop	r15
    15c0:	ef 90       	pop	r14
    15c2:	08 95       	ret

000015c4 <forward>:
  * Example Call: forward()
  */ 

void forward (void)         //both wheels forward
{
	motion_set(0x06);
    15c4:	86 e0       	ldi	r24, 0x06	; 6
    15c6:	0e 94 b3 0a 	call	0x1566	; 0x1566 <motion_set>
}
    15ca:	08 95       	ret

000015cc <__vector_2>:
  * Logic: This interrupt service routine is called on receiving pulses from right position encoder.
  * Example Call: N.A
  */

ISR(INT1_vect)
{
    15cc:	1f 92       	push	r1
    15ce:	0f 92       	push	r0
    15d0:	0f b6       	in	r0, 0x3f	; 63
    15d2:	0f 92       	push	r0
    15d4:	11 24       	eor	r1, r1
    15d6:	8f 93       	push	r24
    15d8:	9f 93       	push	r25
	++shaft_count_right;
    15da:	80 91 80 00 	lds	r24, 0x0080
    15de:	90 91 81 00 	lds	r25, 0x0081
    15e2:	01 96       	adiw	r24, 0x01	; 1
    15e4:	90 93 81 00 	sts	0x0081, r25
    15e8:	80 93 80 00 	sts	0x0080, r24
}
    15ec:	9f 91       	pop	r25
    15ee:	8f 91       	pop	r24
    15f0:	0f 90       	pop	r0
    15f2:	0f be       	out	0x3f, r0	; 63
    15f4:	0f 90       	pop	r0
    15f6:	1f 90       	pop	r1
    15f8:	18 95       	reti

000015fa <__vector_1>:
  * Logic: This interrupt service routine is called on receiving pulses from left position encoder.
  * Example Call: N.A
  */

ISR(INT0_vect)
{
    15fa:	1f 92       	push	r1
    15fc:	0f 92       	push	r0
    15fe:	0f b6       	in	r0, 0x3f	; 63
    1600:	0f 92       	push	r0
    1602:	11 24       	eor	r1, r1
    1604:	8f 93       	push	r24
    1606:	9f 93       	push	r25
    1608:	af 93       	push	r26
    160a:	bf 93       	push	r27
	++shaft_count_left;
    160c:	80 91 7c 00 	lds	r24, 0x007C
    1610:	90 91 7d 00 	lds	r25, 0x007D
    1614:	a0 91 7e 00 	lds	r26, 0x007E
    1618:	b0 91 7f 00 	lds	r27, 0x007F
    161c:	01 96       	adiw	r24, 0x01	; 1
    161e:	a1 1d       	adc	r26, r1
    1620:	b1 1d       	adc	r27, r1
    1622:	80 93 7c 00 	sts	0x007C, r24
    1626:	90 93 7d 00 	sts	0x007D, r25
    162a:	a0 93 7e 00 	sts	0x007E, r26
    162e:	b0 93 7f 00 	sts	0x007F, r27
}
    1632:	bf 91       	pop	r27
    1634:	af 91       	pop	r26
    1636:	9f 91       	pop	r25
    1638:	8f 91       	pop	r24
    163a:	0f 90       	pop	r0
    163c:	0f be       	out	0x3f, r0	; 63
    163e:	0f 90       	pop	r0
    1640:	1f 90       	pop	r1
    1642:	18 95       	reti

00001644 <linear_distance_mm>:
void linear_distance_mm(unsigned int DistanceInMM)
{
 	req_shaft_count=0;
	req_shaft_count_int=0;

 	req_shaft_count = (float)(DistanceInMM / 12.92);
    1644:	bc 01       	movw	r22, r24
    1646:	80 e0       	ldi	r24, 0x00	; 0
    1648:	90 e0       	ldi	r25, 0x00	; 0
    164a:	0e 94 37 18 	call	0x306e	; 0x306e <__floatunsisf>
    164e:	22 e5       	ldi	r18, 0x52	; 82
    1650:	38 eb       	ldi	r19, 0xB8	; 184
    1652:	4e e4       	ldi	r20, 0x4E	; 78
    1654:	51 e4       	ldi	r21, 0x41	; 65
    1656:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__divsf3>
    165a:	26 2f       	mov	r18, r22
    165c:	37 2f       	mov	r19, r23
    165e:	f8 2f       	mov	r31, r24
    1660:	e9 2f       	mov	r30, r25
    1662:	46 2f       	mov	r20, r22
    1664:	57 2f       	mov	r21, r23
    1666:	68 2f       	mov	r22, r24
    1668:	79 2f       	mov	r23, r25
    166a:	40 93 84 00 	sts	0x0084, r20
    166e:	50 93 85 00 	sts	0x0085, r21
    1672:	60 93 86 00 	sts	0x0086, r22
    1676:	70 93 87 00 	sts	0x0087, r23
 	req_shaft_count_int = (unsigned long int)req_shaft_count;
    167a:	82 2f       	mov	r24, r18
    167c:	93 2f       	mov	r25, r19
    167e:	af 2f       	mov	r26, r31
    1680:	be 2f       	mov	r27, r30
    1682:	bc 01       	movw	r22, r24
    1684:	cd 01       	movw	r24, r26
    1686:	0e 94 0b 18 	call	0x3016	; 0x3016 <__fixunssfsi>
    168a:	dc 01       	movw	r26, r24
    168c:	cb 01       	movw	r24, r22
    168e:	90 93 83 00 	sts	0x0083, r25
    1692:	80 93 82 00 	sts	0x0082, r24

 	shaft_count_right=0;
    1696:	10 92 81 00 	sts	0x0081, r1
    169a:	10 92 80 00 	sts	0x0080, r1
 	while(1)
 	{
		 just_line();
    169e:	0e 94 1b 0a 	call	0x1436	; 0x1436 <just_line>
  		if(shaft_count_right > req_shaft_count_int)
    16a2:	20 91 80 00 	lds	r18, 0x0080
    16a6:	30 91 81 00 	lds	r19, 0x0081
    16aa:	80 91 82 00 	lds	r24, 0x0082
    16ae:	90 91 83 00 	lds	r25, 0x0083
    16b2:	82 17       	cp	r24, r18
    16b4:	93 07       	cpc	r25, r19
    16b6:	98 f7       	brcc	.-26     	; 0x169e <linear_distance_mm+0x5a>
  		{
  			break;
  		}
 	}
 	stop(); //Stop robot
    16b8:	0e 94 b9 0a 	call	0x1572	; 0x1572 <stop>
}
    16bc:	08 95       	ret

000016be <forward_mm>:
  * Logic: This function sets up the motion pins of the bot for forward movement and calls linear_distance_mm("distance in mm") function for the bot to move by a specific distance.
  * Example Call: forward_mm(100)
  */ 

void forward_mm(unsigned int DistanceInMM)
{
    16be:	cf 93       	push	r28
    16c0:	df 93       	push	r29
    16c2:	ec 01       	movw	r28, r24
 	forward();
    16c4:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <forward>
 	linear_distance_mm(DistanceInMM);
    16c8:	ce 01       	movw	r24, r28
    16ca:	0e 94 22 0b 	call	0x1644	; 0x1644 <linear_distance_mm>
}
    16ce:	df 91       	pop	r29
    16d0:	cf 91       	pop	r28
    16d2:	08 95       	ret

000016d4 <angle_rotate>:
  * Logic: This function is used for rotating the bot by a specific angle.
  * Example Call: angle_rotate(100)
  */

void angle_rotate(unsigned int deg)
{
    16d4:	1f 93       	push	r17
    16d6:	cf 93       	push	r28
    16d8:	df 93       	push	r29
	req_shaft_count=0;
	req_shaft_count_int=0;

	req_shaft_count=(float)(deg/12.85);
    16da:	bc 01       	movw	r22, r24
    16dc:	80 e0       	ldi	r24, 0x00	; 0
    16de:	90 e0       	ldi	r25, 0x00	; 0
    16e0:	0e 94 37 18 	call	0x306e	; 0x306e <__floatunsisf>
    16e4:	2a e9       	ldi	r18, 0x9A	; 154
    16e6:	39 e9       	ldi	r19, 0x99	; 153
    16e8:	4d e4       	ldi	r20, 0x4D	; 77
    16ea:	51 e4       	ldi	r21, 0x41	; 65
    16ec:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__divsf3>
    16f0:	26 2f       	mov	r18, r22
    16f2:	37 2f       	mov	r19, r23
    16f4:	f8 2f       	mov	r31, r24
    16f6:	e9 2f       	mov	r30, r25
    16f8:	46 2f       	mov	r20, r22
    16fa:	57 2f       	mov	r21, r23
    16fc:	68 2f       	mov	r22, r24
    16fe:	79 2f       	mov	r23, r25
    1700:	40 93 84 00 	sts	0x0084, r20
    1704:	50 93 85 00 	sts	0x0085, r21
    1708:	60 93 86 00 	sts	0x0086, r22
    170c:	70 93 87 00 	sts	0x0087, r23
	req_shaft_count_int=(unsigned long int)req_shaft_count;
    1710:	82 2f       	mov	r24, r18
    1712:	93 2f       	mov	r25, r19
    1714:	af 2f       	mov	r26, r31
    1716:	be 2f       	mov	r27, r30
    1718:	bc 01       	movw	r22, r24
    171a:	cd 01       	movw	r24, r26
    171c:	0e 94 0b 18 	call	0x3016	; 0x3016 <__fixunssfsi>
    1720:	dc 01       	movw	r26, r24
    1722:	cb 01       	movw	r24, r22
    1724:	fc 01       	movw	r30, r24
    1726:	90 93 83 00 	sts	0x0083, r25
    172a:	80 93 82 00 	sts	0x0082, r24
	shaft_count_left=0;
    172e:	10 92 7c 00 	sts	0x007C, r1
    1732:	10 92 7d 00 	sts	0x007D, r1
    1736:	10 92 7e 00 	sts	0x007E, r1
    173a:	10 92 7f 00 	sts	0x007F, r1
	shaft_count_right=0;
    173e:	10 92 81 00 	sts	0x0081, r1
    1742:	10 92 80 00 	sts	0x0080, r1

	while(1)
	{
		if((shaft_count_right >= req_shaft_count_int)|(shaft_count_left >= req_shaft_count_int))
    1746:	d1 e0       	ldi	r29, 0x01	; 1
    1748:	10 e0       	ldi	r17, 0x00	; 0
    174a:	ac 01       	movw	r20, r24
    174c:	60 e0       	ldi	r22, 0x00	; 0
    174e:	70 e0       	ldi	r23, 0x00	; 0
    1750:	20 91 80 00 	lds	r18, 0x0080
    1754:	30 91 81 00 	lds	r19, 0x0081
    1758:	80 91 7c 00 	lds	r24, 0x007C
    175c:	90 91 7d 00 	lds	r25, 0x007D
    1760:	a0 91 7e 00 	lds	r26, 0x007E
    1764:	b0 91 7f 00 	lds	r27, 0x007F
    1768:	cd 2f       	mov	r28, r29
    176a:	2e 17       	cp	r18, r30
    176c:	3f 07       	cpc	r19, r31
    176e:	08 f4       	brcc	.+2      	; 0x1772 <angle_rotate+0x9e>
    1770:	c1 2f       	mov	r28, r17
    1772:	cc 23       	and	r28, r28
    1774:	49 f4       	brne	.+18     	; 0x1788 <angle_rotate+0xb4>
    1776:	2d 2f       	mov	r18, r29
    1778:	84 17       	cp	r24, r20
    177a:	95 07       	cpc	r25, r21
    177c:	a6 07       	cpc	r26, r22
    177e:	b7 07       	cpc	r27, r23
    1780:	08 f4       	brcc	.+2      	; 0x1784 <angle_rotate+0xb0>
    1782:	21 2f       	mov	r18, r17
    1784:	22 23       	and	r18, r18
    1786:	21 f3       	breq	.-56     	; 0x1750 <angle_rotate+0x7c>
		break;
 	}
	stop();
    1788:	0e 94 b9 0a 	call	0x1572	; 0x1572 <stop>
}
    178c:	df 91       	pop	r29
    178e:	cf 91       	pop	r28
    1790:	1f 91       	pop	r17
    1792:	08 95       	ret

00001794 <back>:
  * Example Call: back()
  */ 

void back (void)
{
	motion_set(0x09);
    1794:	89 e0       	ldi	r24, 0x09	; 9
    1796:	0e 94 b3 0a 	call	0x1566	; 0x1566 <motion_set>
}
    179a:	08 95       	ret

0000179c <left>:
  * Logic: This function sets up the motion pins of the bot to set the bot so that it turns left
  * Example Call: left()
  */ 
void left (void) 
{
  motion_set(0x05);
    179c:	85 e0       	ldi	r24, 0x05	; 5
    179e:	0e 94 b3 0a 	call	0x1566	; 0x1566 <motion_set>
}
    17a2:	08 95       	ret

000017a4 <right>:
  * Logic: This function sets up the motion pins of the bot so that the bot turns right
  * Example Call: right()
  */ 
void right (void) 
{
  motion_set(0x0A);
    17a4:	8a e0       	ldi	r24, 0x0A	; 10
    17a6:	0e 94 b3 0a 	call	0x1566	; 0x1566 <motion_set>
}
    17aa:	08 95       	ret

000017ac <soft_left>:
  * Logic: This function sets up the motion pins of the bot so that the bot takes a soft left turn
  * Example Call: soft_left()
  */ 
void soft_left (void) //Left wheel stationary, Right wheel forward
{
 motion_set(0x04);
    17ac:	84 e0       	ldi	r24, 0x04	; 4
    17ae:	0e 94 b3 0a 	call	0x1566	; 0x1566 <motion_set>
}
    17b2:	08 95       	ret

000017b4 <soft_right>:
  * Logic: This function sets up the motion pins of the bot so that the bot takes a soft right turn
  * Example Call: soft_right()
  */ 
void soft_right (void) //Left wheel forward, Right wheel is stationary
{
 motion_set(0x02);
    17b4:	82 e0       	ldi	r24, 0x02	; 2
    17b6:	0e 94 b3 0a 	call	0x1566	; 0x1566 <motion_set>
}
    17ba:	08 95       	ret

000017bc <soft_left_2>:
  * Logic: This function sets up the motion pins of the bot so that the bot takes a soft left turn in the reverse direction
  * Example Call: soft_left_2()
  */ 
void soft_left_2 (void) //Left wheel backward, right wheel stationary
{
 motion_set(0x01);
    17bc:	81 e0       	ldi	r24, 0x01	; 1
    17be:	0e 94 b3 0a 	call	0x1566	; 0x1566 <motion_set>
}
    17c2:	08 95       	ret

000017c4 <soft_right_2>:
  * Logic: This function sets up the motion pins of the bot so that the bot takes a soft right turn in the reverse direction
  * Example Call: soft_right_2()
  */ 
void soft_right_2 (void) //Left wheel stationary, Right wheel backward
{
 motion_set(0x08);
    17c4:	88 e0       	ldi	r24, 0x08	; 8
    17c6:	0e 94 b3 0a 	call	0x1566	; 0x1566 <motion_set>
}
    17ca:	08 95       	ret

000017cc <left_degrees>:
  * Logic: This function is used for setting pins for left turn and rotating the bot by a specific angle.
  * Example Call: left_degrees(100)
  */

void left_degrees(unsigned int Degrees)
{
    17cc:	cf 93       	push	r28
    17ce:	df 93       	push	r29
    17d0:	ec 01       	movw	r28, r24
 	left();
    17d2:	0e 94 ce 0b 	call	0x179c	; 0x179c <left>
 	angle_rotate(Degrees);
    17d6:	ce 01       	movw	r24, r28
    17d8:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <angle_rotate>
}
    17dc:	df 91       	pop	r29
    17de:	cf 91       	pop	r28
    17e0:	08 95       	ret

000017e2 <right_degrees>:
  * Logic: This function is used for setting pins for right turn and rotating the bot by a specific angle.
  * Example Call: right_degrees(100)
  */

void right_degrees(unsigned int Degrees)
{
    17e2:	cf 93       	push	r28
    17e4:	df 93       	push	r29
    17e6:	ec 01       	movw	r28, r24

 	right();
    17e8:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <right>
 	angle_rotate(Degrees);
    17ec:	ce 01       	movw	r24, r28
    17ee:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <angle_rotate>
}
    17f2:	df 91       	pop	r29
    17f4:	cf 91       	pop	r28
    17f6:	08 95       	ret

000017f8 <turn>:
void turn(unsigned int direction)
{
	//0 for left
	//1 for right

	if(direction==0)
    17f8:	00 97       	sbiw	r24, 0x00	; 0
    17fa:	69 f5       	brne	.+90     	; 0x1856 <turn+0x5e>
	{
		left_degrees(70);
    17fc:	86 e4       	ldi	r24, 0x46	; 70
    17fe:	90 e0       	ldi	r25, 0x00	; 0
    1800:	0e 94 e6 0b 	call	0x17cc	; 0x17cc <left_degrees>
		Center_white_line = ADC_Conversion(4);	//Getting data of Center WL Sensor
    1804:	84 e0       	ldi	r24, 0x04	; 4
    1806:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    180a:	80 93 78 00 	sts	0x0078, r24
		while(Center_white_line < 85)
    180e:	85 35       	cpi	r24, 0x55	; 85
    1810:	48 f4       	brcc	.+18     	; 0x1824 <turn+0x2c>
		{
			left();
    1812:	0e 94 ce 0b 	call	0x179c	; 0x179c <left>
			Center_white_line = ADC_Conversion(4);
    1816:	84 e0       	ldi	r24, 0x04	; 4
    1818:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    181c:	80 93 78 00 	sts	0x0078, r24

	if(direction==0)
	{
		left_degrees(70);
		Center_white_line = ADC_Conversion(4);	//Getting data of Center WL Sensor
		while(Center_white_line < 85)
    1820:	85 35       	cpi	r24, 0x55	; 85
    1822:	b8 f3       	brcs	.-18     	; 0x1812 <turn+0x1a>
		{
			left();
			Center_white_line = ADC_Conversion(4);
		}
		stop();
    1824:	0e 94 b9 0a 	call	0x1572	; 0x1572 <stop>
		if(orient == 0) orient = 3;
    1828:	80 91 f8 00 	lds	r24, 0x00F8
    182c:	90 91 f9 00 	lds	r25, 0x00F9
    1830:	00 97       	sbiw	r24, 0x00	; 0
    1832:	39 f4       	brne	.+14     	; 0x1842 <turn+0x4a>
    1834:	83 e0       	ldi	r24, 0x03	; 3
    1836:	90 e0       	ldi	r25, 0x00	; 0
    1838:	90 93 f9 00 	sts	0x00F9, r25
    183c:	80 93 f8 00 	sts	0x00F8, r24
    1840:	08 95       	ret
		else
		--orient;
    1842:	80 91 f8 00 	lds	r24, 0x00F8
    1846:	90 91 f9 00 	lds	r25, 0x00F9
    184a:	01 97       	sbiw	r24, 0x01	; 1
    184c:	90 93 f9 00 	sts	0x00F9, r25
    1850:	80 93 f8 00 	sts	0x00F8, r24
    1854:	08 95       	ret
		
	}
	else if(direction==1)
    1856:	81 30       	cpi	r24, 0x01	; 1
    1858:	91 05       	cpc	r25, r1
    185a:	11 f5       	brne	.+68     	; 0x18a0 <turn+0xa8>
	{
		right_degrees(70);
    185c:	86 e4       	ldi	r24, 0x46	; 70
    185e:	90 e0       	ldi	r25, 0x00	; 0
    1860:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <right_degrees>
		Center_white_line = ADC_Conversion(4);	//Getting data of Center WL Sensor
    1864:	84 e0       	ldi	r24, 0x04	; 4
    1866:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    186a:	80 93 78 00 	sts	0x0078, r24
		while(Center_white_line < 85)
    186e:	85 35       	cpi	r24, 0x55	; 85
    1870:	48 f4       	brcc	.+18     	; 0x1884 <turn+0x8c>
		{
			right();
    1872:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <right>
			Center_white_line = ADC_Conversion(4);
    1876:	84 e0       	ldi	r24, 0x04	; 4
    1878:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    187c:	80 93 78 00 	sts	0x0078, r24
	}
	else if(direction==1)
	{
		right_degrees(70);
		Center_white_line = ADC_Conversion(4);	//Getting data of Center WL Sensor
		while(Center_white_line < 85)
    1880:	85 35       	cpi	r24, 0x55	; 85
    1882:	b8 f3       	brcs	.-18     	; 0x1872 <turn+0x7a>
		{
			right();
			Center_white_line = ADC_Conversion(4);
		}
		stop();
    1884:	0e 94 b9 0a 	call	0x1572	; 0x1572 <stop>
		orient = (orient + 1)%4;
    1888:	80 91 f8 00 	lds	r24, 0x00F8
    188c:	90 91 f9 00 	lds	r25, 0x00F9
    1890:	01 96       	adiw	r24, 0x01	; 1
    1892:	83 70       	andi	r24, 0x03	; 3
    1894:	90 70       	andi	r25, 0x00	; 0
    1896:	90 93 f9 00 	sts	0x00F9, r25
    189a:	80 93 f8 00 	sts	0x00F8, r24
    189e:	08 95       	ret
		
	}
	else if(direction==2)
    18a0:	82 30       	cpi	r24, 0x02	; 2
    18a2:	91 05       	cpc	r25, r1
    18a4:	09 f5       	brne	.+66     	; 0x18e8 <turn+0xf0>
	{
		right_degrees(170);
    18a6:	8a ea       	ldi	r24, 0xAA	; 170
    18a8:	90 e0       	ldi	r25, 0x00	; 0
    18aa:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <right_degrees>
		Center_white_line = ADC_Conversion(4);	//Getting data of Center WL Sensor
    18ae:	84 e0       	ldi	r24, 0x04	; 4
    18b0:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    18b4:	80 93 78 00 	sts	0x0078, r24
		while(Center_white_line < 85)
    18b8:	85 35       	cpi	r24, 0x55	; 85
    18ba:	48 f4       	brcc	.+18     	; 0x18ce <turn+0xd6>
		{
			right();
    18bc:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <right>
			Center_white_line = ADC_Conversion(4);
    18c0:	84 e0       	ldi	r24, 0x04	; 4
    18c2:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    18c6:	80 93 78 00 	sts	0x0078, r24
	}
	else if(direction==2)
	{
		right_degrees(170);
		Center_white_line = ADC_Conversion(4);	//Getting data of Center WL Sensor
		while(Center_white_line < 85)
    18ca:	85 35       	cpi	r24, 0x55	; 85
    18cc:	b8 f3       	brcs	.-18     	; 0x18bc <turn+0xc4>
		{
			right();
			Center_white_line = ADC_Conversion(4);
		}
		stop();
    18ce:	0e 94 b9 0a 	call	0x1572	; 0x1572 <stop>
		orient = (orient + 2)%4;
    18d2:	80 91 f8 00 	lds	r24, 0x00F8
    18d6:	90 91 f9 00 	lds	r25, 0x00F9
    18da:	02 96       	adiw	r24, 0x02	; 2
    18dc:	83 70       	andi	r24, 0x03	; 3
    18de:	90 70       	andi	r25, 0x00	; 0
    18e0:	90 93 f9 00 	sts	0x00F9, r25
    18e4:	80 93 f8 00 	sts	0x00F8, r24
    18e8:	08 95       	ret

000018ea <ir_check>:
  * Example Call: ir_check()
  */

void ir_check(void)
{
	Side_IR_Sensor = ADC_Conversion(1);    //Getting data of Side IR Proximity Sensor Sensor
    18ea:	81 e0       	ldi	r24, 0x01	; 1
    18ec:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    18f0:	80 93 73 00 	sts	0x0073, r24

	if((Side_IR_Sensor > IR_THRESHOLD_MIN) && (Side_IR_Sensor < IR_THRESHOLD_MAX))
    18f4:	85 56       	subi	r24, 0x65	; 101
    18f6:	84 30       	cpi	r24, 0x04	; 4
    18f8:	68 f4       	brcc	.+26     	; 0x1914 <ir_check+0x2a>
	{
		stop();
    18fa:	0e 94 b9 0a 	call	0x1572	; 0x1572 <stop>
    18fe:	8f ef       	ldi	r24, 0xFF	; 255
    1900:	9f ef       	ldi	r25, 0xFF	; 255
    1902:	a9 e5       	ldi	r26, 0x59	; 89
    1904:	81 50       	subi	r24, 0x01	; 1
    1906:	90 40       	sbci	r25, 0x00	; 0
    1908:	a0 40       	sbci	r26, 0x00	; 0
    190a:	e1 f7       	brne	.-8      	; 0x1904 <ir_check+0x1a>
    190c:	00 c0       	rjmp	.+0      	; 0x190e <ir_check+0x24>
    190e:	00 00       	nop
		_delay_ms(4000);
		forward();
    1910:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <forward>
    1914:	08 95       	ret

00001916 <timer1_init_color>:
  * Example Call: timer1_init_color()
  */ 

void timer1_init_color(void)
{
 TCCR1B = 0x00; //stop
    1916:	1e bc       	out	0x2e, r1	; 46
 TCNT1H = 0xE3; //setup
    1918:	83 ee       	ldi	r24, 0xE3	; 227
    191a:	8d bd       	out	0x2d, r24	; 45
 TCNT1L = 0xE1;
    191c:	81 ee       	ldi	r24, 0xE1	; 225
    191e:	8c bd       	out	0x2c, r24	; 44
 OCR1AH = 0x1C;
    1920:	9c e1       	ldi	r25, 0x1C	; 28
    1922:	9b bd       	out	0x2b, r25	; 43
 OCR1AL = 0x1F;
    1924:	8f e1       	ldi	r24, 0x1F	; 31
    1926:	8a bd       	out	0x2a, r24	; 42
 OCR1BH = 0x1C;
    1928:	99 bd       	out	0x29, r25	; 41
 OCR1BL = 0x1F;
    192a:	88 bd       	out	0x28, r24	; 40
 ICR1H  = 0x1C;
    192c:	97 bd       	out	0x27, r25	; 39
 ICR1L  = 0x1F;
    192e:	86 bd       	out	0x26, r24	; 38
 TCCR1A = 0x00;
    1930:	1f bc       	out	0x2f, r1	; 47
 TCCR1B = 0x05; //start Timer, INTERRUPT FOR COLOR SENSOR CONFIGURED FOR FALLING EDGE THROUGH BIT6 OF TCCR1B (ICES1 BIT)
    1932:	85 e0       	ldi	r24, 0x05	; 5
    1934:	8e bd       	out	0x2e, r24	; 46
}
    1936:	08 95       	ret

00001938 <__vector_5>:
  * Output: None
  * Logic: Increment the pulse count on receiving pulse from the color sensor
  */ 

ISR(TIMER1_CAPT_vect)// INPUT CAPTURE ROUTINE
{
    1938:	1f 92       	push	r1
    193a:	0f 92       	push	r0
    193c:	0f b6       	in	r0, 0x3f	; 63
    193e:	0f 92       	push	r0
    1940:	11 24       	eor	r1, r1
    1942:	8f 93       	push	r24
    1944:	9f 93       	push	r25
    1946:	af 93       	push	r26
    1948:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
    194a:	80 91 6f 00 	lds	r24, 0x006F
    194e:	90 91 70 00 	lds	r25, 0x0070
    1952:	a0 91 71 00 	lds	r26, 0x0071
    1956:	b0 91 72 00 	lds	r27, 0x0072
    195a:	01 96       	adiw	r24, 0x01	; 1
    195c:	a1 1d       	adc	r26, r1
    195e:	b1 1d       	adc	r27, r1
    1960:	80 93 6f 00 	sts	0x006F, r24
    1964:	90 93 70 00 	sts	0x0070, r25
    1968:	a0 93 71 00 	sts	0x0071, r26
    196c:	b0 93 72 00 	sts	0x0072, r27
}
    1970:	bf 91       	pop	r27
    1972:	af 91       	pop	r26
    1974:	9f 91       	pop	r25
    1976:	8f 91       	pop	r24
    1978:	0f 90       	pop	r0
    197a:	0f be       	out	0x3f, r0	; 63
    197c:	0f 90       	pop	r0
    197e:	1f 90       	pop	r1
    1980:	18 95       	reti

00001982 <filter_red>:
  */ 

void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTC = PORTC & 0xBF; //set S2 low
    1982:	ae 98       	cbi	0x15, 6	; 21
	PORTC = PORTC & 0x7F; //set S3 low
    1984:	af 98       	cbi	0x15, 7	; 21
}
    1986:	08 95       	ret

00001988 <filter_green>:
  */ 

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTC = PORTC | 0x40; //set S2 High
    1988:	ae 9a       	sbi	0x15, 6	; 21
	PORTC = PORTC | 0x80; //set S3 High
    198a:	af 9a       	sbi	0x15, 7	; 21
}
    198c:	08 95       	ret

0000198e <filter_blue>:
  */ 

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTC = PORTC & 0xBF; //set S2 low
    198e:	ae 98       	cbi	0x15, 6	; 21
	PORTC = PORTC | 0x80; //set S3 High
    1990:	af 9a       	sbi	0x15, 7	; 21
}
    1992:	08 95       	ret

00001994 <filter_clear>:
  */ 

void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	PORTC = PORTC | 0x40; //set S2 High
    1994:	ae 9a       	sbi	0x15, 6	; 21
	PORTC = PORTC & 0x7F; //set S3 Low
    1996:	af 98       	cbi	0x15, 7	; 21
}
    1998:	08 95       	ret

0000199a <color_sensor_scaling_20>:
  */

void color_sensor_scaling_20()		
{
	//Output Scaling 20% from datasheet
	PORTC = PORTC | 0x10; //set S0 high
    199a:	ac 9a       	sbi	0x15, 4	; 21
	PORTC = PORTC & 0xDF; //set S1 LOW
    199c:	ad 98       	cbi	0x15, 5	; 21
}
    199e:	08 95       	ret

000019a0 <color_sensor_scaling_2>:
  */

void color_sensor_scaling_2()	
{
	//Output Scaling 2% from datasheet
	PORTC = PORTC & 0xEF; //set S0 low
    19a0:	ac 98       	cbi	0x15, 4	; 21
	PORTC = PORTC | 0x20; //set S1 high
    19a2:	ad 9a       	sbi	0x15, 5	; 21
}
    19a4:	08 95       	ret

000019a6 <red_read>:
  */

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
    19a6:	0e 94 c1 0c 	call	0x1982	; 0x1982 <filter_red>
	pulse=0; //reset the count to 0
    19aa:	10 92 6f 00 	sts	0x006F, r1
    19ae:	10 92 70 00 	sts	0x0070, r1
    19b2:	10 92 71 00 	sts	0x0071, r1
    19b6:	10 92 72 00 	sts	0x0072, r1
    19ba:	8f ef       	ldi	r24, 0xFF	; 255
    19bc:	9f e3       	ldi	r25, 0x3F	; 63
    19be:	a2 e0       	ldi	r26, 0x02	; 2
    19c0:	81 50       	subi	r24, 0x01	; 1
    19c2:	90 40       	sbci	r25, 0x00	; 0
    19c4:	a0 40       	sbci	r26, 0x00	; 0
    19c6:	e1 f7       	brne	.-8      	; 0x19c0 <red_read+0x1a>
    19c8:	00 c0       	rjmp	.+0      	; 0x19ca <red_read+0x24>
    19ca:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
    19cc:	80 91 6f 00 	lds	r24, 0x006F
    19d0:	90 91 70 00 	lds	r25, 0x0070
    19d4:	a0 91 71 00 	lds	r26, 0x0071
    19d8:	b0 91 72 00 	lds	r27, 0x0072
    19dc:	80 93 e9 00 	sts	0x00E9, r24
    19e0:	90 93 ea 00 	sts	0x00EA, r25
    19e4:	a0 93 eb 00 	sts	0x00EB, r26
    19e8:	b0 93 ec 00 	sts	0x00EC, r27
}
    19ec:	08 95       	ret

000019ee <green_read>:
  */

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
    19ee:	0e 94 c4 0c 	call	0x1988	; 0x1988 <filter_green>
	pulse=0; //reset the count to 0
    19f2:	10 92 6f 00 	sts	0x006F, r1
    19f6:	10 92 70 00 	sts	0x0070, r1
    19fa:	10 92 71 00 	sts	0x0071, r1
    19fe:	10 92 72 00 	sts	0x0072, r1
    1a02:	8f ef       	ldi	r24, 0xFF	; 255
    1a04:	9f e3       	ldi	r25, 0x3F	; 63
    1a06:	a2 e0       	ldi	r26, 0x02	; 2
    1a08:	81 50       	subi	r24, 0x01	; 1
    1a0a:	90 40       	sbci	r25, 0x00	; 0
    1a0c:	a0 40       	sbci	r26, 0x00	; 0
    1a0e:	e1 f7       	brne	.-8      	; 0x1a08 <green_read+0x1a>
    1a10:	00 c0       	rjmp	.+0      	; 0x1a12 <green_read+0x24>
    1a12:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
    1a14:	80 91 6f 00 	lds	r24, 0x006F
    1a18:	90 91 70 00 	lds	r25, 0x0070
    1a1c:	a0 91 71 00 	lds	r26, 0x0071
    1a20:	b0 91 72 00 	lds	r27, 0x0072
    1a24:	80 93 e5 00 	sts	0x00E5, r24
    1a28:	90 93 e6 00 	sts	0x00E6, r25
    1a2c:	a0 93 e7 00 	sts	0x00E7, r26
    1a30:	b0 93 e8 00 	sts	0x00E8, r27
}
    1a34:	08 95       	ret

00001a36 <blue_read>:
  */ 

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
    1a36:	0e 94 c7 0c 	call	0x198e	; 0x198e <filter_blue>
	pulse=0; //reset the count to 0
    1a3a:	10 92 6f 00 	sts	0x006F, r1
    1a3e:	10 92 70 00 	sts	0x0070, r1
    1a42:	10 92 71 00 	sts	0x0071, r1
    1a46:	10 92 72 00 	sts	0x0072, r1
    1a4a:	8f ef       	ldi	r24, 0xFF	; 255
    1a4c:	9f e3       	ldi	r25, 0x3F	; 63
    1a4e:	a2 e0       	ldi	r26, 0x02	; 2
    1a50:	81 50       	subi	r24, 0x01	; 1
    1a52:	90 40       	sbci	r25, 0x00	; 0
    1a54:	a0 40       	sbci	r26, 0x00	; 0
    1a56:	e1 f7       	brne	.-8      	; 0x1a50 <blue_read+0x1a>
    1a58:	00 c0       	rjmp	.+0      	; 0x1a5a <blue_read+0x24>
    1a5a:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
    1a5c:	80 91 6f 00 	lds	r24, 0x006F
    1a60:	90 91 70 00 	lds	r25, 0x0070
    1a64:	a0 91 71 00 	lds	r26, 0x0071
    1a68:	b0 91 72 00 	lds	r27, 0x0072
    1a6c:	80 93 b7 00 	sts	0x00B7, r24
    1a70:	90 93 b8 00 	sts	0x00B8, r25
    1a74:	a0 93 b9 00 	sts	0x00B9, r26
    1a78:	b0 93 ba 00 	sts	0x00BA, r27
}
    1a7c:	08 95       	ret

00001a7e <init_color_sensor>:
  * Example Call: init_color_sensor()
  */ 

void init_color_sensor(void)
{
 cli();          //Clears the global interrupts
    1a7e:	f8 94       	cli
 timer1_init_color();
    1a80:	0e 94 8b 0c 	call	0x1916	; 0x1916 <timer1_init_color>
 TIMSK = TIMSK | 0x20;   //timer1 interrupt sources
    1a84:	89 b7       	in	r24, 0x39	; 57
    1a86:	80 62       	ori	r24, 0x20	; 32
    1a88:	89 bf       	out	0x39, r24	; 57
 sei();          //Enables the global interrupts
    1a8a:	78 94       	sei
 color_sensor_scaling_2();
    1a8c:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <color_sensor_scaling_2>
}
    1a90:	08 95       	ret

00001a92 <color_check>:
  * Example Call: color_check()
  */ 

void color_check(void)
{
	init_color_sensor();
    1a92:	0e 94 3f 0d 	call	0x1a7e	; 0x1a7e <init_color_sensor>
	
	red_read(); 
    1a96:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <red_read>
    1a9a:	8f ef       	ldi	r24, 0xFF	; 255
    1a9c:	9f e3       	ldi	r25, 0x3F	; 63
    1a9e:	ab e0       	ldi	r26, 0x0B	; 11
    1aa0:	81 50       	subi	r24, 0x01	; 1
    1aa2:	90 40       	sbci	r25, 0x00	; 0
    1aa4:	a0 40       	sbci	r26, 0x00	; 0
    1aa6:	e1 f7       	brne	.-8      	; 0x1aa0 <color_check+0xe>
    1aa8:	00 c0       	rjmp	.+0      	; 0x1aaa <color_check+0x18>
    1aaa:	00 00       	nop
	_delay_ms(500);
	green_read(); 
    1aac:	0e 94 f7 0c 	call	0x19ee	; 0x19ee <green_read>
    1ab0:	8f ef       	ldi	r24, 0xFF	; 255
    1ab2:	9f e3       	ldi	r25, 0x3F	; 63
    1ab4:	ab e0       	ldi	r26, 0x0B	; 11
    1ab6:	81 50       	subi	r24, 0x01	; 1
    1ab8:	90 40       	sbci	r25, 0x00	; 0
    1aba:	a0 40       	sbci	r26, 0x00	; 0
    1abc:	e1 f7       	brne	.-8      	; 0x1ab6 <color_check+0x24>
    1abe:	00 c0       	rjmp	.+0      	; 0x1ac0 <color_check+0x2e>
    1ac0:	00 00       	nop
	_delay_ms(500);
	blue_read(); 
    1ac2:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <blue_read>
    1ac6:	8f ef       	ldi	r24, 0xFF	; 255
    1ac8:	9f e3       	ldi	r25, 0x3F	; 63
    1aca:	ab e0       	ldi	r26, 0x0B	; 11
    1acc:	81 50       	subi	r24, 0x01	; 1
    1ace:	90 40       	sbci	r25, 0x00	; 0
    1ad0:	a0 40       	sbci	r26, 0x00	; 0
    1ad2:	e1 f7       	brne	.-8      	; 0x1acc <color_check+0x3a>
    1ad4:	00 c0       	rjmp	.+0      	; 0x1ad6 <color_check+0x44>
    1ad6:	00 00       	nop
	_delay_ms(500);
	
	cli();
    1ad8:	f8 94       	cli
	timer1_init();
    1ada:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <timer1_init>
	sei();
    1ade:	78 94       	sei
	
	if((red>green) && (red>blue))  color_result = 0;
    1ae0:	40 91 e9 00 	lds	r20, 0x00E9
    1ae4:	50 91 ea 00 	lds	r21, 0x00EA
    1ae8:	60 91 eb 00 	lds	r22, 0x00EB
    1aec:	70 91 ec 00 	lds	r23, 0x00EC
    1af0:	80 91 e5 00 	lds	r24, 0x00E5
    1af4:	90 91 e6 00 	lds	r25, 0x00E6
    1af8:	a0 91 e7 00 	lds	r26, 0x00E7
    1afc:	b0 91 e8 00 	lds	r27, 0x00E8
    1b00:	84 17       	cp	r24, r20
    1b02:	95 07       	cpc	r25, r21
    1b04:	a6 07       	cpc	r26, r22
    1b06:	b7 07       	cpc	r27, r23
    1b08:	d0 f4       	brcc	.+52     	; 0x1b3e <color_check+0xac>
    1b0a:	40 91 e9 00 	lds	r20, 0x00E9
    1b0e:	50 91 ea 00 	lds	r21, 0x00EA
    1b12:	60 91 eb 00 	lds	r22, 0x00EB
    1b16:	70 91 ec 00 	lds	r23, 0x00EC
    1b1a:	80 91 b7 00 	lds	r24, 0x00B7
    1b1e:	90 91 b8 00 	lds	r25, 0x00B8
    1b22:	a0 91 b9 00 	lds	r26, 0x00B9
    1b26:	b0 91 ba 00 	lds	r27, 0x00BA
    1b2a:	84 17       	cp	r24, r20
    1b2c:	95 07       	cpc	r25, r21
    1b2e:	a6 07       	cpc	r26, r22
    1b30:	b7 07       	cpc	r27, r23
    1b32:	28 f4       	brcc	.+10     	; 0x1b3e <color_check+0xac>
    1b34:	10 92 1a 01 	sts	0x011A, r1
    1b38:	10 92 19 01 	sts	0x0119, r1
    1b3c:	08 95       	ret
	else if(green>blue)            color_result = 1;
    1b3e:	40 91 e5 00 	lds	r20, 0x00E5
    1b42:	50 91 e6 00 	lds	r21, 0x00E6
    1b46:	60 91 e7 00 	lds	r22, 0x00E7
    1b4a:	70 91 e8 00 	lds	r23, 0x00E8
    1b4e:	80 91 b7 00 	lds	r24, 0x00B7
    1b52:	90 91 b8 00 	lds	r25, 0x00B8
    1b56:	a0 91 b9 00 	lds	r26, 0x00B9
    1b5a:	b0 91 ba 00 	lds	r27, 0x00BA
    1b5e:	84 17       	cp	r24, r20
    1b60:	95 07       	cpc	r25, r21
    1b62:	a6 07       	cpc	r26, r22
    1b64:	b7 07       	cpc	r27, r23
    1b66:	38 f4       	brcc	.+14     	; 0x1b76 <color_check+0xe4>
    1b68:	81 e0       	ldi	r24, 0x01	; 1
    1b6a:	90 e0       	ldi	r25, 0x00	; 0
    1b6c:	90 93 1a 01 	sts	0x011A, r25
    1b70:	80 93 19 01 	sts	0x0119, r24
    1b74:	08 95       	ret
	else                           color_result = 2;
    1b76:	82 e0       	ldi	r24, 0x02	; 2
    1b78:	90 e0       	ldi	r25, 0x00	; 0
    1b7a:	90 93 1a 01 	sts	0x011A, r25
    1b7e:	80 93 19 01 	sts	0x0119, r24
    1b82:	08 95       	ret

00001b84 <convert_rowcol_to_seq>:

unsigned int convert_rowcol_to_seq(unsigned char x1,unsigned char x2)
{
	unsigned int x;
	x=0;
	if((x1 == 0x02) || (x1 == '2'))
    1b84:	82 30       	cpi	r24, 0x02	; 2
    1b86:	c9 f0       	breq	.+50     	; 0x1bba <convert_rowcol_to_seq+0x36>
    1b88:	82 33       	cpi	r24, 0x32	; 50
    1b8a:	d1 f0       	breq	.+52     	; 0x1bc0 <convert_rowcol_to_seq+0x3c>
	{
		x+=7;
	}
	else if((x1 == 0x03) || (x1 == '3'))
    1b8c:	83 30       	cpi	r24, 0x03	; 3
    1b8e:	d9 f0       	breq	.+54     	; 0x1bc6 <convert_rowcol_to_seq+0x42>
    1b90:	83 33       	cpi	r24, 0x33	; 51
    1b92:	e1 f0       	breq	.+56     	; 0x1bcc <convert_rowcol_to_seq+0x48>
	{
		x+=14;
	}
	else if((x1 == 0x04) || (x1 == '4'))
    1b94:	84 30       	cpi	r24, 0x04	; 4
    1b96:	e9 f0       	breq	.+58     	; 0x1bd2 <convert_rowcol_to_seq+0x4e>
    1b98:	84 33       	cpi	r24, 0x34	; 52
    1b9a:	f1 f0       	breq	.+60     	; 0x1bd8 <convert_rowcol_to_seq+0x54>
	{
		x+=21;
	}
	else if((x1 == 0x05) || (x1 == '5'))
    1b9c:	85 30       	cpi	r24, 0x05	; 5
    1b9e:	f9 f0       	breq	.+62     	; 0x1bde <convert_rowcol_to_seq+0x5a>
    1ba0:	85 33       	cpi	r24, 0x35	; 53
    1ba2:	01 f1       	breq	.+64     	; 0x1be4 <convert_rowcol_to_seq+0x60>
	{
		x+=28;
	}
	else if((x1 == 0x06) || (x1 == '6'))
    1ba4:	86 30       	cpi	r24, 0x06	; 6
    1ba6:	09 f1       	breq	.+66     	; 0x1bea <convert_rowcol_to_seq+0x66>
    1ba8:	86 33       	cpi	r24, 0x36	; 54
    1baa:	11 f1       	breq	.+68     	; 0x1bf0 <convert_rowcol_to_seq+0x6c>
	{
		x+=35;
	}
	else if((x1 == 0x07) || (x1 == '7'))
    1bac:	87 30       	cpi	r24, 0x07	; 7
    1bae:	19 f1       	breq	.+70     	; 0x1bf6 <convert_rowcol_to_seq+0x72>
    1bb0:	87 33       	cpi	r24, 0x37	; 55
    1bb2:	21 f1       	breq	.+72     	; 0x1bfc <convert_rowcol_to_seq+0x78>
  */

unsigned int convert_rowcol_to_seq(unsigned char x1,unsigned char x2)
{
	unsigned int x;
	x=0;
    1bb4:	80 e0       	ldi	r24, 0x00	; 0
    1bb6:	90 e0       	ldi	r25, 0x00	; 0
    1bb8:	23 c0       	rjmp	.+70     	; 0x1c00 <convert_rowcol_to_seq+0x7c>
	if((x1 == 0x02) || (x1 == '2'))
	{
		x+=7;
    1bba:	87 e0       	ldi	r24, 0x07	; 7
    1bbc:	90 e0       	ldi	r25, 0x00	; 0
    1bbe:	20 c0       	rjmp	.+64     	; 0x1c00 <convert_rowcol_to_seq+0x7c>
    1bc0:	87 e0       	ldi	r24, 0x07	; 7
    1bc2:	90 e0       	ldi	r25, 0x00	; 0
    1bc4:	1d c0       	rjmp	.+58     	; 0x1c00 <convert_rowcol_to_seq+0x7c>
	}
	else if((x1 == 0x03) || (x1 == '3'))
	{
		x+=14;
    1bc6:	8e e0       	ldi	r24, 0x0E	; 14
    1bc8:	90 e0       	ldi	r25, 0x00	; 0
    1bca:	1a c0       	rjmp	.+52     	; 0x1c00 <convert_rowcol_to_seq+0x7c>
    1bcc:	8e e0       	ldi	r24, 0x0E	; 14
    1bce:	90 e0       	ldi	r25, 0x00	; 0
    1bd0:	17 c0       	rjmp	.+46     	; 0x1c00 <convert_rowcol_to_seq+0x7c>
	}
	else if((x1 == 0x04) || (x1 == '4'))
	{
		x+=21;
    1bd2:	85 e1       	ldi	r24, 0x15	; 21
    1bd4:	90 e0       	ldi	r25, 0x00	; 0
    1bd6:	14 c0       	rjmp	.+40     	; 0x1c00 <convert_rowcol_to_seq+0x7c>
    1bd8:	85 e1       	ldi	r24, 0x15	; 21
    1bda:	90 e0       	ldi	r25, 0x00	; 0
    1bdc:	11 c0       	rjmp	.+34     	; 0x1c00 <convert_rowcol_to_seq+0x7c>
	}
	else if((x1 == 0x05) || (x1 == '5'))
	{
		x+=28;
    1bde:	8c e1       	ldi	r24, 0x1C	; 28
    1be0:	90 e0       	ldi	r25, 0x00	; 0
    1be2:	0e c0       	rjmp	.+28     	; 0x1c00 <convert_rowcol_to_seq+0x7c>
    1be4:	8c e1       	ldi	r24, 0x1C	; 28
    1be6:	90 e0       	ldi	r25, 0x00	; 0
    1be8:	0b c0       	rjmp	.+22     	; 0x1c00 <convert_rowcol_to_seq+0x7c>
	}
	else if((x1 == 0x06) || (x1 == '6'))
	{
		x+=35;
    1bea:	83 e2       	ldi	r24, 0x23	; 35
    1bec:	90 e0       	ldi	r25, 0x00	; 0
    1bee:	08 c0       	rjmp	.+16     	; 0x1c00 <convert_rowcol_to_seq+0x7c>
    1bf0:	83 e2       	ldi	r24, 0x23	; 35
    1bf2:	90 e0       	ldi	r25, 0x00	; 0
    1bf4:	05 c0       	rjmp	.+10     	; 0x1c00 <convert_rowcol_to_seq+0x7c>
	}
	else if((x1 == 0x07) || (x1 == '7'))
	{
		x+=42;
    1bf6:	8a e2       	ldi	r24, 0x2A	; 42
    1bf8:	90 e0       	ldi	r25, 0x00	; 0
    1bfa:	02 c0       	rjmp	.+4      	; 0x1c00 <convert_rowcol_to_seq+0x7c>
    1bfc:	8a e2       	ldi	r24, 0x2A	; 42
    1bfe:	90 e0       	ldi	r25, 0x00	; 0
	}
	if((x2 == 0x10) || (x2 == 'B'))
    1c00:	60 31       	cpi	r22, 0x10	; 16
    1c02:	11 f0       	breq	.+4      	; 0x1c08 <convert_rowcol_to_seq+0x84>
    1c04:	62 34       	cpi	r22, 0x42	; 66
    1c06:	11 f4       	brne	.+4      	; 0x1c0c <convert_rowcol_to_seq+0x88>
	{
		x+=1;
    1c08:	01 96       	adiw	r24, 0x01	; 1
    1c0a:	08 95       	ret
	}
	else if((x2 == 0x18) || (x2 == 'C'))
    1c0c:	68 31       	cpi	r22, 0x18	; 24
    1c0e:	11 f0       	breq	.+4      	; 0x1c14 <convert_rowcol_to_seq+0x90>
    1c10:	63 34       	cpi	r22, 0x43	; 67
    1c12:	11 f4       	brne	.+4      	; 0x1c18 <convert_rowcol_to_seq+0x94>
	{
		x+=2;
    1c14:	02 96       	adiw	r24, 0x02	; 2
    1c16:	08 95       	ret
	}
	else if((x2 == 0x20) || (x2 == 'D'))
    1c18:	60 32       	cpi	r22, 0x20	; 32
    1c1a:	11 f0       	breq	.+4      	; 0x1c20 <convert_rowcol_to_seq+0x9c>
    1c1c:	64 34       	cpi	r22, 0x44	; 68
    1c1e:	11 f4       	brne	.+4      	; 0x1c24 <convert_rowcol_to_seq+0xa0>
	{
		x+=3;
    1c20:	03 96       	adiw	r24, 0x03	; 3
    1c22:	08 95       	ret
	}
	else if((x2 == 0x28) || (x2 == 'E'))
    1c24:	68 32       	cpi	r22, 0x28	; 40
    1c26:	11 f0       	breq	.+4      	; 0x1c2c <convert_rowcol_to_seq+0xa8>
    1c28:	65 34       	cpi	r22, 0x45	; 69
    1c2a:	11 f4       	brne	.+4      	; 0x1c30 <convert_rowcol_to_seq+0xac>
	{
		x+=4;
    1c2c:	04 96       	adiw	r24, 0x04	; 4
    1c2e:	08 95       	ret
	}
	else if((x2 == 0x30) || (x2 == 'F'))
    1c30:	60 33       	cpi	r22, 0x30	; 48
    1c32:	11 f0       	breq	.+4      	; 0x1c38 <convert_rowcol_to_seq+0xb4>
    1c34:	66 34       	cpi	r22, 0x46	; 70
    1c36:	11 f4       	brne	.+4      	; 0x1c3c <convert_rowcol_to_seq+0xb8>
	{
		x+=5;
    1c38:	05 96       	adiw	r24, 0x05	; 5
    1c3a:	08 95       	ret
	}
	else if((x2 == 0x38) || (x2 == 'G'))
    1c3c:	68 33       	cpi	r22, 0x38	; 56
    1c3e:	11 f0       	breq	.+4      	; 0x1c44 <convert_rowcol_to_seq+0xc0>
    1c40:	67 34       	cpi	r22, 0x47	; 71
    1c42:	09 f4       	brne	.+2      	; 0x1c46 <convert_rowcol_to_seq+0xc2>
	{
		x+=6;
    1c44:	06 96       	adiw	r24, 0x06	; 6
	}
	return x;
}
    1c46:	08 95       	ret

00001c48 <__vector_11>:
The above arrays are used by bot to traverse directly to the plant in the other two sets instead of scanning every plant location.

*/

ISR(USART_RXC_vect)
{
    1c48:	1f 92       	push	r1
    1c4a:	0f 92       	push	r0
    1c4c:	0f b6       	in	r0, 0x3f	; 63
    1c4e:	0f 92       	push	r0
    1c50:	11 24       	eor	r1, r1
    1c52:	2f 93       	push	r18
    1c54:	3f 93       	push	r19
    1c56:	4f 93       	push	r20
    1c58:	5f 93       	push	r21
    1c5a:	6f 93       	push	r22
    1c5c:	7f 93       	push	r23
    1c5e:	8f 93       	push	r24
    1c60:	9f 93       	push	r25
    1c62:	af 93       	push	r26
    1c64:	bf 93       	push	r27
    1c66:	cf 93       	push	r28
    1c68:	df 93       	push	r29
    1c6a:	ef 93       	push	r30
    1c6c:	ff 93       	push	r31
	data_rec = UDR;
    1c6e:	8c b1       	in	r24, 0x0c	; 12
    1c70:	80 93 16 01 	sts	0x0116, r24
	if((data_rec == 0x00) && (green_xbee_flag == 0))
    1c74:	80 91 16 01 	lds	r24, 0x0116
    1c78:	88 23       	and	r24, r24
    1c7a:	81 f4       	brne	.+32     	; 0x1c9c <__vector_11+0x54>
    1c7c:	80 91 88 00 	lds	r24, 0x0088
    1c80:	90 91 89 00 	lds	r25, 0x0089
    1c84:	00 97       	sbiw	r24, 0x00	; 0
    1c86:	51 f4       	brne	.+20     	; 0x1c9c <__vector_11+0x54>
	{
		home_bit[1]=1;
    1c88:	81 e0       	ldi	r24, 0x01	; 1
    1c8a:	90 e0       	ldi	r25, 0x00	; 0
    1c8c:	90 93 a7 00 	sts	0x00A7, r25
    1c90:	80 93 a6 00 	sts	0x00A6, r24
		green_xbee_flag = 1;
    1c94:	90 93 89 00 	sts	0x0089, r25
    1c98:	80 93 88 00 	sts	0x0088, r24
	}		
	if((data_rec == 0x80) && (blue_xbee_flag == 0))
    1c9c:	80 91 16 01 	lds	r24, 0x0116
    1ca0:	80 38       	cpi	r24, 0x80	; 128
    1ca2:	81 f4       	brne	.+32     	; 0x1cc4 <__vector_11+0x7c>
    1ca4:	80 91 8a 00 	lds	r24, 0x008A
    1ca8:	90 91 8b 00 	lds	r25, 0x008B
    1cac:	00 97       	sbiw	r24, 0x00	; 0
    1cae:	51 f4       	brne	.+20     	; 0x1cc4 <__vector_11+0x7c>
	{
		 home_bit[2]=1;
    1cb0:	81 e0       	ldi	r24, 0x01	; 1
    1cb2:	90 e0       	ldi	r25, 0x00	; 0
    1cb4:	90 93 a9 00 	sts	0x00A9, r25
    1cb8:	80 93 a8 00 	sts	0x00A8, r24
		 blue_xbee_flag = 1;
    1cbc:	90 93 8b 00 	sts	0x008B, r25
    1cc0:	80 93 8a 00 	sts	0x008A, r24
	}
	if(xbee_com==0)
    1cc4:	80 91 98 00 	lds	r24, 0x0098
    1cc8:	88 23       	and	r24, r24
    1cca:	81 f5       	brne	.+96     	; 0x1d2c <__vector_11+0xe4>
	{
		data_temp = data_rec & 0xC0;
    1ccc:	80 91 16 01 	lds	r24, 0x0116
    1cd0:	80 7c       	andi	r24, 0xC0	; 192
    1cd2:	80 93 15 01 	sts	0x0115, r24
		
		if(data_temp == 0x40)
    1cd6:	80 91 15 01 	lds	r24, 0x0115
    1cda:	80 34       	cpi	r24, 0x40	; 64
    1cdc:	09 f0       	breq	.+2      	; 0x1ce0 <__vector_11+0x98>
    1cde:	b0 c0       	rjmp	.+352    	; 0x1e40 <__vector_11+0x1f8>
		{ 
			data_temp_s1 = data_rec & 0x07;
    1ce0:	80 91 16 01 	lds	r24, 0x0116
    1ce4:	87 70       	andi	r24, 0x07	; 7
    1ce6:	80 93 06 01 	sts	0x0106, r24
			data_temp_s2 = data_rec & 0x38;
    1cea:	80 91 16 01 	lds	r24, 0x0116
    1cee:	88 73       	andi	r24, 0x38	; 56
    1cf0:	80 93 14 01 	sts	0x0114, r24
			initial_home_run[node_count]=convert_rowcol_to_seq(data_temp_s1,data_temp_s2);
    1cf4:	c0 91 96 00 	lds	r28, 0x0096
    1cf8:	d0 91 97 00 	lds	r29, 0x0097
    1cfc:	80 91 06 01 	lds	r24, 0x0106
    1d00:	60 91 14 01 	lds	r22, 0x0114
    1d04:	0e 94 c2 0d 	call	0x1b84	; 0x1b84 <convert_rowcol_to_seq>
    1d08:	28 2f       	mov	r18, r24
    1d0a:	39 2f       	mov	r19, r25
    1d0c:	cc 0f       	add	r28, r28
    1d0e:	dd 1f       	adc	r29, r29
    1d10:	c3 54       	subi	r28, 0x43	; 67
    1d12:	df 4f       	sbci	r29, 0xFF	; 255
    1d14:	39 83       	std	Y+1, r19	; 0x01
    1d16:	28 83       	st	Y, r18
			++node_count;
    1d18:	80 91 96 00 	lds	r24, 0x0096
    1d1c:	90 91 97 00 	lds	r25, 0x0097
    1d20:	01 96       	adiw	r24, 0x01	; 1
    1d22:	90 93 97 00 	sts	0x0097, r25
    1d26:	80 93 96 00 	sts	0x0096, r24
    1d2a:	8a c0       	rjmp	.+276    	; 0x1e40 <__vector_11+0x1f8>
		}
	}
	else if(xbee_com==1)
    1d2c:	80 91 98 00 	lds	r24, 0x0098
    1d30:	81 30       	cpi	r24, 0x01	; 1
    1d32:	09 f0       	breq	.+2      	; 0x1d36 <__vector_11+0xee>
    1d34:	85 c0       	rjmp	.+266    	; 0x1e40 <__vector_11+0x1f8>
	{
		data_temp = data_rec & 0xC0;
    1d36:	80 91 16 01 	lds	r24, 0x0116
    1d3a:	80 7c       	andi	r24, 0xC0	; 192
    1d3c:	80 93 15 01 	sts	0x0115, r24
		uint8_t temp;
		
		if(data_temp == 0x40)
    1d40:	80 91 15 01 	lds	r24, 0x0115
    1d44:	80 34       	cpi	r24, 0x40	; 64
    1d46:	09 f0       	breq	.+2      	; 0x1d4a <__vector_11+0x102>
    1d48:	7b c0       	rjmp	.+246    	; 0x1e40 <__vector_11+0x1f8>
		{
			buzz();
    1d4a:	0e 94 02 02 	call	0x404	; 0x404 <buzz>
			data_temp_s1 = data_rec & 0x07;
    1d4e:	80 91 16 01 	lds	r24, 0x0116
    1d52:	87 70       	andi	r24, 0x07	; 7
    1d54:	80 93 06 01 	sts	0x0106, r24
			data_temp_s2 = data_rec & 0x38;
    1d58:	80 91 16 01 	lds	r24, 0x0116
    1d5c:	88 73       	andi	r24, 0x38	; 56
    1d5e:	80 93 14 01 	sts	0x0114, r24
			temp=convert_rowcol_to_seq(data_temp_s1,data_temp_s2);
    1d62:	80 91 06 01 	lds	r24, 0x0106
    1d66:	60 91 14 01 	lds	r22, 0x0114
    1d6a:	0e 94 c2 0d 	call	0x1b84	; 0x1b84 <convert_rowcol_to_seq>
			if(set_cover==0)
    1d6e:	20 91 9e 00 	lds	r18, 0x009E
    1d72:	30 91 9f 00 	lds	r19, 0x009F
    1d76:	21 15       	cp	r18, r1
    1d78:	31 05       	cpc	r19, r1
    1d7a:	71 f5       	brne	.+92     	; 0x1dd8 <__vector_11+0x190>
			{
				if((temp>34) && (temp<42))
    1d7c:	98 2f       	mov	r25, r24
    1d7e:	93 52       	subi	r25, 0x23	; 35
    1d80:	97 30       	cpi	r25, 0x07	; 7
    1d82:	a8 f4       	brcc	.+42     	; 0x1dae <__vector_11+0x166>
				{
					right_plant_set1[right_plant_set1_count]=temp;
    1d84:	e0 91 94 00 	lds	r30, 0x0094
    1d88:	f0 91 95 00 	lds	r31, 0x0095
    1d8c:	90 e0       	ldi	r25, 0x00	; 0
    1d8e:	ee 0f       	add	r30, r30
    1d90:	ff 1f       	adc	r31, r31
    1d92:	e6 55       	subi	r30, 0x56	; 86
    1d94:	ff 4f       	sbci	r31, 0xFF	; 255
    1d96:	91 83       	std	Z+1, r25	; 0x01
    1d98:	80 83       	st	Z, r24
					++right_plant_set1_count;
    1d9a:	80 91 94 00 	lds	r24, 0x0094
    1d9e:	90 91 95 00 	lds	r25, 0x0095
    1da2:	01 96       	adiw	r24, 0x01	; 1
    1da4:	90 93 95 00 	sts	0x0095, r25
    1da8:	80 93 94 00 	sts	0x0094, r24
    1dac:	49 c0       	rjmp	.+146    	; 0x1e40 <__vector_11+0x1f8>
				}
				else
				{
					right_plant_set2[right_plant_set2_count]=temp;
    1dae:	e0 91 90 00 	lds	r30, 0x0090
    1db2:	f0 91 91 00 	lds	r31, 0x0091
    1db6:	90 e0       	ldi	r25, 0x00	; 0
    1db8:	ee 0f       	add	r30, r30
    1dba:	ff 1f       	adc	r31, r31
    1dbc:	e2 51       	subi	r30, 0x12	; 18
    1dbe:	ff 4f       	sbci	r31, 0xFF	; 255
    1dc0:	91 83       	std	Z+1, r25	; 0x01
    1dc2:	80 83       	st	Z, r24
					++right_plant_set2_count;
    1dc4:	80 91 90 00 	lds	r24, 0x0090
    1dc8:	90 91 91 00 	lds	r25, 0x0091
    1dcc:	01 96       	adiw	r24, 0x01	; 1
    1dce:	90 93 91 00 	sts	0x0091, r25
    1dd2:	80 93 90 00 	sts	0x0090, r24
    1dd6:	34 c0       	rjmp	.+104    	; 0x1e40 <__vector_11+0x1f8>
				}
			}
			else
			{
				if(set_cover==50)
    1dd8:	20 91 9e 00 	lds	r18, 0x009E
    1ddc:	30 91 9f 00 	lds	r19, 0x009F
    1de0:	22 33       	cpi	r18, 0x32	; 50
    1de2:	31 05       	cpc	r19, r1
    1de4:	69 f5       	brne	.+90     	; 0x1e40 <__vector_11+0x1f8>
				{
					if((temp>34) && (temp<42))
    1de6:	98 2f       	mov	r25, r24
    1de8:	93 52       	subi	r25, 0x23	; 35
    1dea:	97 30       	cpi	r25, 0x07	; 7
    1dec:	a8 f4       	brcc	.+42     	; 0x1e18 <__vector_11+0x1d0>
					{
						left_plant_set1[left_plant_set1_count]=temp;
    1dee:	e0 91 92 00 	lds	r30, 0x0092
    1df2:	f0 91 93 00 	lds	r31, 0x0093
    1df6:	90 e0       	ldi	r25, 0x00	; 0
    1df8:	ee 0f       	add	r30, r30
    1dfa:	ff 1f       	adc	r31, r31
    1dfc:	e4 50       	subi	r30, 0x04	; 4
    1dfe:	ff 4f       	sbci	r31, 0xFF	; 255
    1e00:	91 83       	std	Z+1, r25	; 0x01
    1e02:	80 83       	st	Z, r24
						++left_plant_set1_count;
    1e04:	80 91 92 00 	lds	r24, 0x0092
    1e08:	90 91 93 00 	lds	r25, 0x0093
    1e0c:	01 96       	adiw	r24, 0x01	; 1
    1e0e:	90 93 93 00 	sts	0x0093, r25
    1e12:	80 93 92 00 	sts	0x0092, r24
    1e16:	14 c0       	rjmp	.+40     	; 0x1e40 <__vector_11+0x1f8>
					}
					else
					{
						left_plant_set2[left_plant_set2_count]=temp;
    1e18:	e0 91 8e 00 	lds	r30, 0x008E
    1e1c:	f0 91 8f 00 	lds	r31, 0x008F
    1e20:	90 e0       	ldi	r25, 0x00	; 0
    1e22:	ee 0f       	add	r30, r30
    1e24:	ff 1f       	adc	r31, r31
    1e26:	e9 5f       	subi	r30, 0xF9	; 249
    1e28:	fe 4f       	sbci	r31, 0xFE	; 254
    1e2a:	91 83       	std	Z+1, r25	; 0x01
    1e2c:	80 83       	st	Z, r24
						++left_plant_set2_count;
    1e2e:	80 91 8e 00 	lds	r24, 0x008E
    1e32:	90 91 8f 00 	lds	r25, 0x008F
    1e36:	01 96       	adiw	r24, 0x01	; 1
    1e38:	90 93 8f 00 	sts	0x008F, r25
    1e3c:	80 93 8e 00 	sts	0x008E, r24
					}
				}
			}
		}
	}
}
    1e40:	ff 91       	pop	r31
    1e42:	ef 91       	pop	r30
    1e44:	df 91       	pop	r29
    1e46:	cf 91       	pop	r28
    1e48:	bf 91       	pop	r27
    1e4a:	af 91       	pop	r26
    1e4c:	9f 91       	pop	r25
    1e4e:	8f 91       	pop	r24
    1e50:	7f 91       	pop	r23
    1e52:	6f 91       	pop	r22
    1e54:	5f 91       	pop	r21
    1e56:	4f 91       	pop	r20
    1e58:	3f 91       	pop	r19
    1e5a:	2f 91       	pop	r18
    1e5c:	0f 90       	pop	r0
    1e5e:	0f be       	out	0x3f, r0	; 63
    1e60:	0f 90       	pop	r0
    1e62:	1f 90       	pop	r1
    1e64:	18 95       	reti

00001e66 <xbee_seq_node_transfer>:
  * Logic: This function sends the data containing the sequential node position to the respective bot over xbee.
  * Example Call: xbee_seq_node_transfer(22 , 0)
  */

void xbee_seq_node_transfer(unsigned int node_tx, unsigned int send_flag)
{
    1e66:	9c 01       	movw	r18, r24
    1e68:	fb 01       	movw	r30, r22
	    data = 0x00;
    1e6a:	10 92 99 00 	sts	0x0099, r1
		if(node_tx < 7)
    1e6e:	87 30       	cpi	r24, 0x07	; 7
    1e70:	91 05       	cpc	r25, r1
    1e72:	08 f0       	brcs	.+2      	; 0x1e76 <xbee_seq_node_transfer+0x10>
    1e74:	82 c0       	rjmp	.+260    	; 0x1f7a <xbee_seq_node_transfer+0x114>
		{
			flag_switch = 0;
    1e76:	10 92 9b 00 	sts	0x009B, r1
    1e7a:	10 92 9a 00 	sts	0x009A, r1
			switch(node_tx)
    1e7e:	83 30       	cpi	r24, 0x03	; 3
    1e80:	91 05       	cpc	r25, r1
    1e82:	e9 f1       	breq	.+122    	; 0x1efe <xbee_seq_node_transfer+0x98>
    1e84:	84 30       	cpi	r24, 0x04	; 4
    1e86:	91 05       	cpc	r25, r1
    1e88:	38 f4       	brcc	.+14     	; 0x1e98 <xbee_seq_node_transfer+0x32>
    1e8a:	81 30       	cpi	r24, 0x01	; 1
    1e8c:	91 05       	cpc	r25, r1
    1e8e:	c9 f0       	breq	.+50     	; 0x1ec2 <xbee_seq_node_transfer+0x5c>
    1e90:	82 30       	cpi	r24, 0x02	; 2
    1e92:	91 05       	cpc	r25, r1
    1e94:	28 f5       	brcc	.+74     	; 0x1ee0 <xbee_seq_node_transfer+0x7a>
    1e96:	0c c0       	rjmp	.+24     	; 0x1eb0 <xbee_seq_node_transfer+0x4a>
    1e98:	85 30       	cpi	r24, 0x05	; 5
    1e9a:	91 05       	cpc	r25, r1
    1e9c:	09 f4       	brne	.+2      	; 0x1ea0 <xbee_seq_node_transfer+0x3a>
    1e9e:	4d c0       	rjmp	.+154    	; 0x1f3a <xbee_seq_node_transfer+0xd4>
    1ea0:	85 30       	cpi	r24, 0x05	; 5
    1ea2:	91 05       	cpc	r25, r1
    1ea4:	d8 f1       	brcs	.+118    	; 0x1f1c <xbee_seq_node_transfer+0xb6>
    1ea6:	86 30       	cpi	r24, 0x06	; 6
    1ea8:	91 05       	cpc	r25, r1
    1eaa:	09 f0       	breq	.+2      	; 0x1eae <xbee_seq_node_transfer+0x48>
    1eac:	99 c1       	rjmp	.+818    	; 0x21e0 <xbee_seq_node_transfer+0x37a>
    1eae:	54 c0       	rjmp	.+168    	; 0x1f58 <xbee_seq_node_transfer+0xf2>
			{
				case 0: data = 0x09; flag_switch = 1;
    1eb0:	89 e0       	ldi	r24, 0x09	; 9
    1eb2:	80 93 99 00 	sts	0x0099, r24
    1eb6:	81 e0       	ldi	r24, 0x01	; 1
    1eb8:	90 e0       	ldi	r25, 0x00	; 0
    1eba:	90 93 9b 00 	sts	0x009B, r25
    1ebe:	80 93 9a 00 	sts	0x009A, r24
				case 1: if(flag_switch==0)
    1ec2:	80 91 9a 00 	lds	r24, 0x009A
    1ec6:	90 91 9b 00 	lds	r25, 0x009B
    1eca:	00 97       	sbiw	r24, 0x00	; 0
    1ecc:	49 f4       	brne	.+18     	; 0x1ee0 <xbee_seq_node_transfer+0x7a>
				{
					data = 0x11;
    1ece:	81 e1       	ldi	r24, 0x11	; 17
    1ed0:	80 93 99 00 	sts	0x0099, r24
					flag_switch=1;
    1ed4:	81 e0       	ldi	r24, 0x01	; 1
    1ed6:	90 e0       	ldi	r25, 0x00	; 0
    1ed8:	90 93 9b 00 	sts	0x009B, r25
    1edc:	80 93 9a 00 	sts	0x009A, r24
				}
				case 2:if(flag_switch==0)
    1ee0:	80 91 9a 00 	lds	r24, 0x009A
    1ee4:	90 91 9b 00 	lds	r25, 0x009B
    1ee8:	00 97       	sbiw	r24, 0x00	; 0
    1eea:	49 f4       	brne	.+18     	; 0x1efe <xbee_seq_node_transfer+0x98>
				{
					data = 0x19;
    1eec:	89 e1       	ldi	r24, 0x19	; 25
    1eee:	80 93 99 00 	sts	0x0099, r24
					flag_switch=1;
    1ef2:	81 e0       	ldi	r24, 0x01	; 1
    1ef4:	90 e0       	ldi	r25, 0x00	; 0
    1ef6:	90 93 9b 00 	sts	0x009B, r25
    1efa:	80 93 9a 00 	sts	0x009A, r24
				}
				case 3:if(flag_switch==0)
    1efe:	80 91 9a 00 	lds	r24, 0x009A
    1f02:	90 91 9b 00 	lds	r25, 0x009B
    1f06:	00 97       	sbiw	r24, 0x00	; 0
    1f08:	49 f4       	brne	.+18     	; 0x1f1c <xbee_seq_node_transfer+0xb6>
				{
					data = 0x21;
    1f0a:	81 e2       	ldi	r24, 0x21	; 33
    1f0c:	80 93 99 00 	sts	0x0099, r24
					flag_switch=1;
    1f10:	81 e0       	ldi	r24, 0x01	; 1
    1f12:	90 e0       	ldi	r25, 0x00	; 0
    1f14:	90 93 9b 00 	sts	0x009B, r25
    1f18:	80 93 9a 00 	sts	0x009A, r24
				}
				case 4:if(flag_switch==0)
    1f1c:	80 91 9a 00 	lds	r24, 0x009A
    1f20:	90 91 9b 00 	lds	r25, 0x009B
    1f24:	00 97       	sbiw	r24, 0x00	; 0
    1f26:	49 f4       	brne	.+18     	; 0x1f3a <xbee_seq_node_transfer+0xd4>
				{
					data = 0x29;
    1f28:	89 e2       	ldi	r24, 0x29	; 41
    1f2a:	80 93 99 00 	sts	0x0099, r24
					flag_switch=1;
    1f2e:	81 e0       	ldi	r24, 0x01	; 1
    1f30:	90 e0       	ldi	r25, 0x00	; 0
    1f32:	90 93 9b 00 	sts	0x009B, r25
    1f36:	80 93 9a 00 	sts	0x009A, r24
				}
				case 5:if(flag_switch==0)
    1f3a:	80 91 9a 00 	lds	r24, 0x009A
    1f3e:	90 91 9b 00 	lds	r25, 0x009B
    1f42:	00 97       	sbiw	r24, 0x00	; 0
    1f44:	49 f4       	brne	.+18     	; 0x1f58 <xbee_seq_node_transfer+0xf2>
				{
					data = 0x31;
    1f46:	81 e3       	ldi	r24, 0x31	; 49
    1f48:	80 93 99 00 	sts	0x0099, r24
					flag_switch=1;
    1f4c:	81 e0       	ldi	r24, 0x01	; 1
    1f4e:	90 e0       	ldi	r25, 0x00	; 0
    1f50:	90 93 9b 00 	sts	0x009B, r25
    1f54:	80 93 9a 00 	sts	0x009A, r24
				}
				case 6:if(flag_switch==0)
    1f58:	80 91 9a 00 	lds	r24, 0x009A
    1f5c:	90 91 9b 00 	lds	r25, 0x009B
    1f60:	00 97       	sbiw	r24, 0x00	; 0
    1f62:	09 f0       	breq	.+2      	; 0x1f66 <xbee_seq_node_transfer+0x100>
    1f64:	3d c1       	rjmp	.+634    	; 0x21e0 <xbee_seq_node_transfer+0x37a>
				{
					data = 0x39;
    1f66:	89 e3       	ldi	r24, 0x39	; 57
    1f68:	80 93 99 00 	sts	0x0099, r24
					flag_switch=1;
    1f6c:	81 e0       	ldi	r24, 0x01	; 1
    1f6e:	90 e0       	ldi	r25, 0x00	; 0
    1f70:	90 93 9b 00 	sts	0x009B, r25
    1f74:	80 93 9a 00 	sts	0x009A, r24
    1f78:	33 c1       	rjmp	.+614    	; 0x21e0 <xbee_seq_node_transfer+0x37a>
				}
			}
		}
		else
		{
			flag_switch=0;
    1f7a:	10 92 9b 00 	sts	0x009B, r1
    1f7e:	10 92 9a 00 	sts	0x009A, r1
			switch(node_tx%7)
    1f82:	67 e0       	ldi	r22, 0x07	; 7
    1f84:	70 e0       	ldi	r23, 0x00	; 0
    1f86:	0e 94 8d 1a 	call	0x351a	; 0x351a <__udivmodhi4>
    1f8a:	83 30       	cpi	r24, 0x03	; 3
    1f8c:	91 05       	cpc	r25, r1
    1f8e:	09 f4       	brne	.+2      	; 0x1f92 <xbee_seq_node_transfer+0x12c>
    1f90:	44 c0       	rjmp	.+136    	; 0x201a <xbee_seq_node_transfer+0x1b4>
    1f92:	84 30       	cpi	r24, 0x04	; 4
    1f94:	91 05       	cpc	r25, r1
    1f96:	38 f4       	brcc	.+14     	; 0x1fa6 <xbee_seq_node_transfer+0x140>
    1f98:	81 30       	cpi	r24, 0x01	; 1
    1f9a:	91 05       	cpc	r25, r1
    1f9c:	e1 f0       	breq	.+56     	; 0x1fd6 <xbee_seq_node_transfer+0x170>
    1f9e:	82 30       	cpi	r24, 0x02	; 2
    1fa0:	91 05       	cpc	r25, r1
    1fa2:	50 f5       	brcc	.+84     	; 0x1ff8 <xbee_seq_node_transfer+0x192>
    1fa4:	0d c0       	rjmp	.+26     	; 0x1fc0 <xbee_seq_node_transfer+0x15a>
    1fa6:	85 30       	cpi	r24, 0x05	; 5
    1fa8:	91 05       	cpc	r25, r1
    1faa:	09 f4       	brne	.+2      	; 0x1fae <xbee_seq_node_transfer+0x148>
    1fac:	58 c0       	rjmp	.+176    	; 0x205e <xbee_seq_node_transfer+0x1f8>
    1fae:	85 30       	cpi	r24, 0x05	; 5
    1fb0:	91 05       	cpc	r25, r1
    1fb2:	08 f4       	brcc	.+2      	; 0x1fb6 <xbee_seq_node_transfer+0x150>
    1fb4:	43 c0       	rjmp	.+134    	; 0x203c <xbee_seq_node_transfer+0x1d6>
    1fb6:	86 30       	cpi	r24, 0x06	; 6
    1fb8:	91 05       	cpc	r25, r1
    1fba:	09 f0       	breq	.+2      	; 0x1fbe <xbee_seq_node_transfer+0x158>
    1fbc:	72 c0       	rjmp	.+228    	; 0x20a2 <xbee_seq_node_transfer+0x23c>
    1fbe:	60 c0       	rjmp	.+192    	; 0x2080 <xbee_seq_node_transfer+0x21a>
			{
				case 0:data = data | 0x08; flag_switch=1;
    1fc0:	80 91 99 00 	lds	r24, 0x0099
    1fc4:	88 60       	ori	r24, 0x08	; 8
    1fc6:	80 93 99 00 	sts	0x0099, r24
    1fca:	81 e0       	ldi	r24, 0x01	; 1
    1fcc:	90 e0       	ldi	r25, 0x00	; 0
    1fce:	90 93 9b 00 	sts	0x009B, r25
    1fd2:	80 93 9a 00 	sts	0x009A, r24
				case 1:if(flag_switch==0)
    1fd6:	80 91 9a 00 	lds	r24, 0x009A
    1fda:	90 91 9b 00 	lds	r25, 0x009B
    1fde:	00 97       	sbiw	r24, 0x00	; 0
    1fe0:	59 f4       	brne	.+22     	; 0x1ff8 <xbee_seq_node_transfer+0x192>
				{
					data = data | 0x10;
    1fe2:	80 91 99 00 	lds	r24, 0x0099
    1fe6:	80 61       	ori	r24, 0x10	; 16
    1fe8:	80 93 99 00 	sts	0x0099, r24
					flag_switch=1;
    1fec:	81 e0       	ldi	r24, 0x01	; 1
    1fee:	90 e0       	ldi	r25, 0x00	; 0
    1ff0:	90 93 9b 00 	sts	0x009B, r25
    1ff4:	80 93 9a 00 	sts	0x009A, r24
				}
				case 2:if(flag_switch==0)
    1ff8:	80 91 9a 00 	lds	r24, 0x009A
    1ffc:	90 91 9b 00 	lds	r25, 0x009B
    2000:	00 97       	sbiw	r24, 0x00	; 0
    2002:	59 f4       	brne	.+22     	; 0x201a <xbee_seq_node_transfer+0x1b4>
				{
					data = data | 0x18;
    2004:	80 91 99 00 	lds	r24, 0x0099
    2008:	88 61       	ori	r24, 0x18	; 24
    200a:	80 93 99 00 	sts	0x0099, r24
					flag_switch=1;
    200e:	81 e0       	ldi	r24, 0x01	; 1
    2010:	90 e0       	ldi	r25, 0x00	; 0
    2012:	90 93 9b 00 	sts	0x009B, r25
    2016:	80 93 9a 00 	sts	0x009A, r24
				}
				case 3:if(flag_switch==0)
    201a:	80 91 9a 00 	lds	r24, 0x009A
    201e:	90 91 9b 00 	lds	r25, 0x009B
    2022:	00 97       	sbiw	r24, 0x00	; 0
    2024:	59 f4       	brne	.+22     	; 0x203c <xbee_seq_node_transfer+0x1d6>
				{
					data = data | 0x20;
    2026:	80 91 99 00 	lds	r24, 0x0099
    202a:	80 62       	ori	r24, 0x20	; 32
    202c:	80 93 99 00 	sts	0x0099, r24
					flag_switch=1;
    2030:	81 e0       	ldi	r24, 0x01	; 1
    2032:	90 e0       	ldi	r25, 0x00	; 0
    2034:	90 93 9b 00 	sts	0x009B, r25
    2038:	80 93 9a 00 	sts	0x009A, r24
				}
				case 4:if(flag_switch==0)
    203c:	80 91 9a 00 	lds	r24, 0x009A
    2040:	90 91 9b 00 	lds	r25, 0x009B
    2044:	00 97       	sbiw	r24, 0x00	; 0
    2046:	59 f4       	brne	.+22     	; 0x205e <xbee_seq_node_transfer+0x1f8>
				{
					data = data | 0x28;
    2048:	80 91 99 00 	lds	r24, 0x0099
    204c:	88 62       	ori	r24, 0x28	; 40
    204e:	80 93 99 00 	sts	0x0099, r24
					flag_switch=1;
    2052:	81 e0       	ldi	r24, 0x01	; 1
    2054:	90 e0       	ldi	r25, 0x00	; 0
    2056:	90 93 9b 00 	sts	0x009B, r25
    205a:	80 93 9a 00 	sts	0x009A, r24
				}
				case 5:if(flag_switch==0)
    205e:	80 91 9a 00 	lds	r24, 0x009A
    2062:	90 91 9b 00 	lds	r25, 0x009B
    2066:	00 97       	sbiw	r24, 0x00	; 0
    2068:	59 f4       	brne	.+22     	; 0x2080 <xbee_seq_node_transfer+0x21a>
				{
					data = data | 0x30;
    206a:	80 91 99 00 	lds	r24, 0x0099
    206e:	80 63       	ori	r24, 0x30	; 48
    2070:	80 93 99 00 	sts	0x0099, r24
					flag_switch=1;
    2074:	81 e0       	ldi	r24, 0x01	; 1
    2076:	90 e0       	ldi	r25, 0x00	; 0
    2078:	90 93 9b 00 	sts	0x009B, r25
    207c:	80 93 9a 00 	sts	0x009A, r24
				}
				case 6:if(flag_switch==0)
    2080:	80 91 9a 00 	lds	r24, 0x009A
    2084:	90 91 9b 00 	lds	r25, 0x009B
    2088:	00 97       	sbiw	r24, 0x00	; 0
    208a:	59 f4       	brne	.+22     	; 0x20a2 <xbee_seq_node_transfer+0x23c>
				{
					data = data | 0x38;
    208c:	80 91 99 00 	lds	r24, 0x0099
    2090:	88 63       	ori	r24, 0x38	; 56
    2092:	80 93 99 00 	sts	0x0099, r24
					flag_switch=1;
    2096:	81 e0       	ldi	r24, 0x01	; 1
    2098:	90 e0       	ldi	r25, 0x00	; 0
    209a:	90 93 9b 00 	sts	0x009B, r25
    209e:	80 93 9a 00 	sts	0x009A, r24
				}
			}
			flag_switch=0;
    20a2:	10 92 9b 00 	sts	0x009B, r1
    20a6:	10 92 9a 00 	sts	0x009A, r1
			switch((node_tx/7)+1)
    20aa:	c9 01       	movw	r24, r18
    20ac:	67 e0       	ldi	r22, 0x07	; 7
    20ae:	70 e0       	ldi	r23, 0x00	; 0
    20b0:	0e 94 8d 1a 	call	0x351a	; 0x351a <__udivmodhi4>
    20b4:	6f 5f       	subi	r22, 0xFF	; 255
    20b6:	7f 4f       	sbci	r23, 0xFF	; 255
    20b8:	64 30       	cpi	r22, 0x04	; 4
    20ba:	71 05       	cpc	r23, r1
    20bc:	09 f4       	brne	.+2      	; 0x20c0 <xbee_seq_node_transfer+0x25a>
    20be:	48 c0       	rjmp	.+144    	; 0x2150 <xbee_seq_node_transfer+0x2ea>
    20c0:	65 30       	cpi	r22, 0x05	; 5
    20c2:	71 05       	cpc	r23, r1
    20c4:	58 f4       	brcc	.+22     	; 0x20dc <xbee_seq_node_transfer+0x276>
    20c6:	62 30       	cpi	r22, 0x02	; 2
    20c8:	71 05       	cpc	r23, r1
    20ca:	01 f1       	breq	.+64     	; 0x210c <xbee_seq_node_transfer+0x2a6>
    20cc:	63 30       	cpi	r22, 0x03	; 3
    20ce:	71 05       	cpc	r23, r1
    20d0:	70 f5       	brcc	.+92     	; 0x212e <xbee_seq_node_transfer+0x2c8>
    20d2:	61 30       	cpi	r22, 0x01	; 1
    20d4:	71 05       	cpc	r23, r1
    20d6:	09 f0       	breq	.+2      	; 0x20da <xbee_seq_node_transfer+0x274>
    20d8:	7f c0       	rjmp	.+254    	; 0x21d8 <xbee_seq_node_transfer+0x372>
    20da:	0d c0       	rjmp	.+26     	; 0x20f6 <xbee_seq_node_transfer+0x290>
    20dc:	66 30       	cpi	r22, 0x06	; 6
    20de:	71 05       	cpc	r23, r1
    20e0:	09 f4       	brne	.+2      	; 0x20e4 <xbee_seq_node_transfer+0x27e>
    20e2:	58 c0       	rjmp	.+176    	; 0x2194 <xbee_seq_node_transfer+0x32e>
    20e4:	66 30       	cpi	r22, 0x06	; 6
    20e6:	71 05       	cpc	r23, r1
    20e8:	08 f4       	brcc	.+2      	; 0x20ec <xbee_seq_node_transfer+0x286>
    20ea:	43 c0       	rjmp	.+134    	; 0x2172 <xbee_seq_node_transfer+0x30c>
    20ec:	67 30       	cpi	r22, 0x07	; 7
    20ee:	71 05       	cpc	r23, r1
    20f0:	09 f0       	breq	.+2      	; 0x20f4 <xbee_seq_node_transfer+0x28e>
    20f2:	72 c0       	rjmp	.+228    	; 0x21d8 <xbee_seq_node_transfer+0x372>
    20f4:	60 c0       	rjmp	.+192    	; 0x21b6 <xbee_seq_node_transfer+0x350>
			{
				case 1:data = data | 0x01; flag_switch=1;
    20f6:	80 91 99 00 	lds	r24, 0x0099
    20fa:	81 60       	ori	r24, 0x01	; 1
    20fc:	80 93 99 00 	sts	0x0099, r24
    2100:	81 e0       	ldi	r24, 0x01	; 1
    2102:	90 e0       	ldi	r25, 0x00	; 0
    2104:	90 93 9b 00 	sts	0x009B, r25
    2108:	80 93 9a 00 	sts	0x009A, r24
				case 2:if(flag_switch==0)
    210c:	80 91 9a 00 	lds	r24, 0x009A
    2110:	90 91 9b 00 	lds	r25, 0x009B
    2114:	00 97       	sbiw	r24, 0x00	; 0
    2116:	59 f4       	brne	.+22     	; 0x212e <xbee_seq_node_transfer+0x2c8>
				{
					data = data | 0x02;
    2118:	80 91 99 00 	lds	r24, 0x0099
    211c:	82 60       	ori	r24, 0x02	; 2
    211e:	80 93 99 00 	sts	0x0099, r24
					flag_switch=1;
    2122:	81 e0       	ldi	r24, 0x01	; 1
    2124:	90 e0       	ldi	r25, 0x00	; 0
    2126:	90 93 9b 00 	sts	0x009B, r25
    212a:	80 93 9a 00 	sts	0x009A, r24
				}
				case 3:if(flag_switch==0)
    212e:	80 91 9a 00 	lds	r24, 0x009A
    2132:	90 91 9b 00 	lds	r25, 0x009B
    2136:	00 97       	sbiw	r24, 0x00	; 0
    2138:	59 f4       	brne	.+22     	; 0x2150 <xbee_seq_node_transfer+0x2ea>
				{
					data = data | 0x03;
    213a:	80 91 99 00 	lds	r24, 0x0099
    213e:	83 60       	ori	r24, 0x03	; 3
    2140:	80 93 99 00 	sts	0x0099, r24
					flag_switch=1;
    2144:	81 e0       	ldi	r24, 0x01	; 1
    2146:	90 e0       	ldi	r25, 0x00	; 0
    2148:	90 93 9b 00 	sts	0x009B, r25
    214c:	80 93 9a 00 	sts	0x009A, r24
				}
				case 4:if(flag_switch==0)
    2150:	80 91 9a 00 	lds	r24, 0x009A
    2154:	90 91 9b 00 	lds	r25, 0x009B
    2158:	00 97       	sbiw	r24, 0x00	; 0
    215a:	59 f4       	brne	.+22     	; 0x2172 <xbee_seq_node_transfer+0x30c>
				{
					data = data | 0x04;
    215c:	80 91 99 00 	lds	r24, 0x0099
    2160:	84 60       	ori	r24, 0x04	; 4
    2162:	80 93 99 00 	sts	0x0099, r24
					flag_switch=1;
    2166:	81 e0       	ldi	r24, 0x01	; 1
    2168:	90 e0       	ldi	r25, 0x00	; 0
    216a:	90 93 9b 00 	sts	0x009B, r25
    216e:	80 93 9a 00 	sts	0x009A, r24
				}
				case 5:if(flag_switch==0)
    2172:	80 91 9a 00 	lds	r24, 0x009A
    2176:	90 91 9b 00 	lds	r25, 0x009B
    217a:	00 97       	sbiw	r24, 0x00	; 0
    217c:	59 f4       	brne	.+22     	; 0x2194 <xbee_seq_node_transfer+0x32e>
				{
					data = data | 0x05;
    217e:	80 91 99 00 	lds	r24, 0x0099
    2182:	85 60       	ori	r24, 0x05	; 5
    2184:	80 93 99 00 	sts	0x0099, r24
					flag_switch=1;
    2188:	81 e0       	ldi	r24, 0x01	; 1
    218a:	90 e0       	ldi	r25, 0x00	; 0
    218c:	90 93 9b 00 	sts	0x009B, r25
    2190:	80 93 9a 00 	sts	0x009A, r24
				}
				case 6:if(flag_switch==0)
    2194:	80 91 9a 00 	lds	r24, 0x009A
    2198:	90 91 9b 00 	lds	r25, 0x009B
    219c:	00 97       	sbiw	r24, 0x00	; 0
    219e:	59 f4       	brne	.+22     	; 0x21b6 <xbee_seq_node_transfer+0x350>
				{
					data = data | 0x06;
    21a0:	80 91 99 00 	lds	r24, 0x0099
    21a4:	86 60       	ori	r24, 0x06	; 6
    21a6:	80 93 99 00 	sts	0x0099, r24
					flag_switch=1;
    21aa:	81 e0       	ldi	r24, 0x01	; 1
    21ac:	90 e0       	ldi	r25, 0x00	; 0
    21ae:	90 93 9b 00 	sts	0x009B, r25
    21b2:	80 93 9a 00 	sts	0x009A, r24
				}
				case 7:if(flag_switch==0)
    21b6:	80 91 9a 00 	lds	r24, 0x009A
    21ba:	90 91 9b 00 	lds	r25, 0x009B
    21be:	00 97       	sbiw	r24, 0x00	; 0
    21c0:	59 f4       	brne	.+22     	; 0x21d8 <xbee_seq_node_transfer+0x372>
				{
					data = data | 0x07;
    21c2:	80 91 99 00 	lds	r24, 0x0099
    21c6:	87 60       	ori	r24, 0x07	; 7
    21c8:	80 93 99 00 	sts	0x0099, r24
					flag_switch=1;
    21cc:	81 e0       	ldi	r24, 0x01	; 1
    21ce:	90 e0       	ldi	r25, 0x00	; 0
    21d0:	90 93 9b 00 	sts	0x009B, r25
    21d4:	80 93 9a 00 	sts	0x009A, r24
				}
			}
			flag_switch=0;
    21d8:	10 92 9b 00 	sts	0x009B, r1
    21dc:	10 92 9a 00 	sts	0x009A, r1
		}
		
        
		if(send_flag == 0)
    21e0:	30 97       	sbiw	r30, 0x00	; 0
    21e2:	31 f4       	brne	.+12     	; 0x21f0 <xbee_seq_node_transfer+0x38a>
		data = data | 0x40;
    21e4:	80 91 99 00 	lds	r24, 0x0099
    21e8:	80 64       	ori	r24, 0x40	; 64
    21ea:	80 93 99 00 	sts	0x0099, r24
    21ee:	10 c0       	rjmp	.+32     	; 0x2210 <xbee_seq_node_transfer+0x3aa>
		else if(send_flag == 1)
    21f0:	e1 30       	cpi	r30, 0x01	; 1
    21f2:	f1 05       	cpc	r31, r1
    21f4:	29 f4       	brne	.+10     	; 0x2200 <xbee_seq_node_transfer+0x39a>
		data = data | 0x00;
    21f6:	80 91 99 00 	lds	r24, 0x0099
    21fa:	80 93 99 00 	sts	0x0099, r24
    21fe:	08 c0       	rjmp	.+16     	; 0x2210 <xbee_seq_node_transfer+0x3aa>
		else if(send_flag == 2)
    2200:	e2 30       	cpi	r30, 0x02	; 2
    2202:	f1 05       	cpc	r31, r1
    2204:	29 f4       	brne	.+10     	; 0x2210 <xbee_seq_node_transfer+0x3aa>
		data = data | 0x80;
    2206:	80 91 99 00 	lds	r24, 0x0099
    220a:	80 68       	ori	r24, 0x80	; 128
    220c:	80 93 99 00 	sts	0x0099, r24

		UDR = data ;
    2210:	80 91 99 00 	lds	r24, 0x0099
    2214:	8c b9       	out	0x0c, r24	; 12
	
}
    2216:	08 95       	ret

00002218 <glow_red>:
  */

void glow_red()
{
	unsigned char PortCRestore = 0;
	PortCRestore = PORTC ;
    2218:	85 b3       	in	r24, 0x15	; 21
	PortCRestore = PortCRestore & 0xF8;
    221a:	88 7f       	andi	r24, 0xF8	; 248
	PortCRestore = PortCRestore | 0x01;
    221c:	81 60       	ori	r24, 0x01	; 1
	PORTC = PortCRestore;
    221e:	85 bb       	out	0x15, r24	; 21
}
    2220:	08 95       	ret

00002222 <glow_green>:
  */

void glow_green()
{
	unsigned char PortCRestore = 0;
	PortCRestore = PORTC ;
    2222:	85 b3       	in	r24, 0x15	; 21
	PortCRestore = PortCRestore & 0xF8;
    2224:	88 7f       	andi	r24, 0xF8	; 248
	PortCRestore = PortCRestore | 0x02;
    2226:	82 60       	ori	r24, 0x02	; 2
	PORTC = PortCRestore;
    2228:	85 bb       	out	0x15, r24	; 21
}
    222a:	08 95       	ret

0000222c <glow_blue>:
  */

void glow_blue()
{
	unsigned char PortCRestore = 0;
	PortCRestore = PORTC ;
    222c:	85 b3       	in	r24, 0x15	; 21
	PortCRestore = PortCRestore & 0xF8;
    222e:	88 7f       	andi	r24, 0xF8	; 248
	PortCRestore = PortCRestore | 0x04;
    2230:	84 60       	ori	r24, 0x04	; 4
	PORTC = PortCRestore;
    2232:	85 bb       	out	0x15, r24	; 21
}
    2234:	08 95       	ret

00002236 <rgb_off>:
  */

void rgb_off()
{
	unsigned char PortCRestore = 0;
	PortCRestore = PORTC ;
    2236:	85 b3       	in	r24, 0x15	; 21
	PortCRestore = PortCRestore & 0xF8;
    2238:	88 7f       	andi	r24, 0xF8	; 248
	PORTC = PortCRestore;
    223a:	85 bb       	out	0x15, r24	; 21
}
    223c:	08 95       	ret

0000223e <glow>:
  * Example Call: glow(1)
  */

void glow(unsigned int rgb_color)
{
	if(rgb_color == 0) 
    223e:	00 97       	sbiw	r24, 0x00	; 0
    2240:	71 f4       	brne	.+28     	; 0x225e <glow+0x20>
	{
		glow_red();
    2242:	0e 94 0c 11 	call	0x2218	; 0x2218 <glow_red>
    2246:	8f ef       	ldi	r24, 0xFF	; 255
    2248:	9f e7       	ldi	r25, 0x7F	; 127
    224a:	a6 e1       	ldi	r26, 0x16	; 22
    224c:	81 50       	subi	r24, 0x01	; 1
    224e:	90 40       	sbci	r25, 0x00	; 0
    2250:	a0 40       	sbci	r26, 0x00	; 0
    2252:	e1 f7       	brne	.-8      	; 0x224c <glow+0xe>
    2254:	00 c0       	rjmp	.+0      	; 0x2256 <glow+0x18>
    2256:	00 00       	nop
		_delay_ms(1000);
		rgb_off();
    2258:	0e 94 1b 11 	call	0x2236	; 0x2236 <rgb_off>
    225c:	08 95       	ret
	}
	else if(rgb_color == 1)
    225e:	81 30       	cpi	r24, 0x01	; 1
    2260:	91 05       	cpc	r25, r1
    2262:	71 f4       	brne	.+28     	; 0x2280 <glow+0x42>
	{
		glow_green();
    2264:	0e 94 11 11 	call	0x2222	; 0x2222 <glow_green>
    2268:	8f ef       	ldi	r24, 0xFF	; 255
    226a:	9f e7       	ldi	r25, 0x7F	; 127
    226c:	a6 e1       	ldi	r26, 0x16	; 22
    226e:	81 50       	subi	r24, 0x01	; 1
    2270:	90 40       	sbci	r25, 0x00	; 0
    2272:	a0 40       	sbci	r26, 0x00	; 0
    2274:	e1 f7       	brne	.-8      	; 0x226e <glow+0x30>
    2276:	00 c0       	rjmp	.+0      	; 0x2278 <glow+0x3a>
    2278:	00 00       	nop
		_delay_ms(1000);
		rgb_off();
    227a:	0e 94 1b 11 	call	0x2236	; 0x2236 <rgb_off>
    227e:	08 95       	ret
	}
	else if(rgb_color == 2)
    2280:	82 30       	cpi	r24, 0x02	; 2
    2282:	91 05       	cpc	r25, r1
    2284:	69 f4       	brne	.+26     	; 0x22a0 <glow+0x62>
	{
		glow_blue();
    2286:	0e 94 16 11 	call	0x222c	; 0x222c <glow_blue>
    228a:	8f ef       	ldi	r24, 0xFF	; 255
    228c:	9f e7       	ldi	r25, 0x7F	; 127
    228e:	a6 e1       	ldi	r26, 0x16	; 22
    2290:	81 50       	subi	r24, 0x01	; 1
    2292:	90 40       	sbci	r25, 0x00	; 0
    2294:	a0 40       	sbci	r26, 0x00	; 0
    2296:	e1 f7       	brne	.-8      	; 0x2290 <glow+0x52>
    2298:	00 c0       	rjmp	.+0      	; 0x229a <glow+0x5c>
    229a:	00 00       	nop
		_delay_ms(1000);
		rgb_off();
    229c:	0e 94 1b 11 	call	0x2236	; 0x2236 <rgb_off>
    22a0:	08 95       	ret

000022a2 <__vector_9>:
  * Logic: This interrupt service routine is called on timer overflow.
  * Example Call: N.A
  */

ISR(_VECTOR(9))
{
    22a2:	1f 92       	push	r1
    22a4:	0f 92       	push	r0
    22a6:	0f b6       	in	r0, 0x3f	; 63
    22a8:	0f 92       	push	r0
    22aa:	11 24       	eor	r1, r1
    22ac:	8f 93       	push	r24
    22ae:	9f 93       	push	r25
	TIFR=0X01;
    22b0:	81 e0       	ldi	r24, 0x01	; 1
    22b2:	88 bf       	out	0x38, r24	; 56
	Timer_Count++;
    22b4:	80 91 11 01 	lds	r24, 0x0111
    22b8:	8f 5f       	subi	r24, 0xFF	; 255
    22ba:	80 93 11 01 	sts	0x0111, r24

	if( Timer_Count < 125 )
    22be:	80 91 11 01 	lds	r24, 0x0111
    22c2:	8d 37       	cpi	r24, 0x7D	; 125
    22c4:	10 f4       	brcc	.+4      	; 0x22ca <__vector_9+0x28>
	TCNT0=0XEB;
    22c6:	8b ee       	ldi	r24, 0xEB	; 235
    22c8:	82 bf       	out	0x32, r24	; 50

	if( Timer_Count == Servo_Value )
    22ca:	90 91 11 01 	lds	r25, 0x0111
    22ce:	80 91 6e 00 	lds	r24, 0x006E
    22d2:	98 17       	cp	r25, r24
    22d4:	09 f4       	brne	.+2      	; 0x22d8 <__vector_9+0x36>
	PORTD &=~(1<<7);
    22d6:	97 98       	cbi	0x12, 7	; 18

	if( Timer_Count >= 125 )
    22d8:	80 91 11 01 	lds	r24, 0x0111
    22dc:	8d 37       	cpi	r24, 0x7D	; 125
    22de:	20 f0       	brcs	.+8      	; 0x22e8 <__vector_9+0x46>
	{
		TCNT0=0X97;
    22e0:	87 e9       	ldi	r24, 0x97	; 151
    22e2:	82 bf       	out	0x32, r24	; 50
		TCCR0=0X04;
    22e4:	84 e0       	ldi	r24, 0x04	; 4
    22e6:	83 bf       	out	0x33, r24	; 51
	}

	if( Timer_Count == 130 )
    22e8:	80 91 11 01 	lds	r24, 0x0111
    22ec:	82 38       	cpi	r24, 0x82	; 130
    22ee:	41 f4       	brne	.+16     	; 0x2300 <__vector_9+0x5e>
	{
		PORTD = 0X80;
    22f0:	80 e8       	ldi	r24, 0x80	; 128
    22f2:	82 bb       	out	0x12, r24	; 18
		TCCR0 = 0X02;
    22f4:	82 e0       	ldi	r24, 0x02	; 2
    22f6:	83 bf       	out	0x33, r24	; 51
		TCNT0 = 0XEB;
    22f8:	8b ee       	ldi	r24, 0xEB	; 235
    22fa:	82 bf       	out	0x32, r24	; 50
		Timer_Count = 0;
    22fc:	10 92 11 01 	sts	0x0111, r1
	}
}
    2300:	9f 91       	pop	r25
    2302:	8f 91       	pop	r24
    2304:	0f 90       	pop	r0
    2306:	0f be       	out	0x3f, r0	; 63
    2308:	0f 90       	pop	r0
    230a:	1f 90       	pop	r1
    230c:	18 95       	reti

0000230e <Convert_Angle>:

unsigned char  Convert_Angle(unsigned char  k)
{
	unsigned char timer_value;
	int temp;
	temp = k*5;
    230e:	90 e0       	ldi	r25, 0x00	; 0
    2310:	9c 01       	movw	r18, r24
    2312:	22 0f       	add	r18, r18
    2314:	33 1f       	adc	r19, r19
    2316:	22 0f       	add	r18, r18
    2318:	33 1f       	adc	r19, r19
    231a:	82 0f       	add	r24, r18
    231c:	93 1f       	adc	r25, r19
	timer_value = temp/9;
    231e:	69 e0       	ldi	r22, 0x09	; 9
    2320:	70 e0       	ldi	r23, 0x00	; 0
    2322:	0e 94 a1 1a 	call	0x3542	; 0x3542 <__divmodhi4>
    2326:	86 2f       	mov	r24, r22
    2328:	e9 e9       	ldi	r30, 0x99	; 153
    232a:	f5 e1       	ldi	r31, 0x15	; 21
    232c:	31 97       	sbiw	r30, 0x01	; 1
    232e:	f1 f7       	brne	.-4      	; 0x232c <Convert_Angle+0x1e>
    2330:	00 c0       	rjmp	.+0      	; 0x2332 <Convert_Angle+0x24>
	timer_value = timer_value+25;
	_delay_ms(3);
	return timer_value;
}
    2332:	87 5e       	subi	r24, 0xE7	; 231
    2334:	08 95       	ret

00002336 <feedOut>:
  * Example Call: feedOut()
  */

void feedOut()
{
Servo_Value=Convert_Angle(100);
    2336:	84 e6       	ldi	r24, 0x64	; 100
    2338:	0e 94 87 11 	call	0x230e	; 0x230e <Convert_Angle>
    233c:	80 93 6e 00 	sts	0x006E, r24
    2340:	8c ec       	ldi	r24, 0xCC	; 204
    2342:	9c e3       	ldi	r25, 0x3C	; 60
    2344:	a1 e0       	ldi	r26, 0x01	; 1
    2346:	81 50       	subi	r24, 0x01	; 1
    2348:	90 40       	sbci	r25, 0x00	; 0
    234a:	a0 40       	sbci	r26, 0x00	; 0
    234c:	e1 f7       	brne	.-8      	; 0x2346 <feedOut+0x10>
    234e:	00 c0       	rjmp	.+0      	; 0x2350 <feedOut+0x1a>
_delay_ms(55);
Servo_Value=Convert_Angle(0);
    2350:	80 e0       	ldi	r24, 0x00	; 0
    2352:	0e 94 87 11 	call	0x230e	; 0x230e <Convert_Angle>
    2356:	80 93 6e 00 	sts	0x006E, r24
    235a:	8f ef       	ldi	r24, 0xFF	; 255
    235c:	9f ef       	ldi	r25, 0xFF	; 255
    235e:	a8 e0       	ldi	r26, 0x08	; 8
    2360:	81 50       	subi	r24, 0x01	; 1
    2362:	90 40       	sbci	r25, 0x00	; 0
    2364:	a0 40       	sbci	r26, 0x00	; 0
    2366:	e1 f7       	brne	.-8      	; 0x2360 <feedOut+0x2a>
    2368:	00 c0       	rjmp	.+0      	; 0x236a <feedOut+0x34>
    236a:	00 00       	nop
_delay_ms(400);
}
    236c:	08 95       	ret

0000236e <Sharp_GP2D12_estimation>:
#define F_CPU 7372800
unsigned char sharp=0;
unsigned int value;

unsigned int Sharp_GP2D12_estimation(unsigned char adc_reading)
{
    236e:	0f 93       	push	r16
    2370:	1f 93       	push	r17
	float distance;
	unsigned int distanceInt;
	distance = (int)(10.00*(2799.6*(1.00/(pow(adc_reading,1.1546)))));
    2372:	68 2f       	mov	r22, r24
    2374:	70 e0       	ldi	r23, 0x00	; 0
    2376:	80 e0       	ldi	r24, 0x00	; 0
    2378:	90 e0       	ldi	r25, 0x00	; 0
    237a:	0e 94 37 18 	call	0x306e	; 0x306e <__floatunsisf>
    237e:	2f ee       	ldi	r18, 0xEF	; 239
    2380:	39 ec       	ldi	r19, 0xC9	; 201
    2382:	43 e9       	ldi	r20, 0x93	; 147
    2384:	5f e3       	ldi	r21, 0x3F	; 63
    2386:	0e 94 28 19 	call	0x3250	; 0x3250 <pow>
    238a:	b6 2f       	mov	r27, r22
    238c:	a7 2f       	mov	r26, r23
    238e:	38 2f       	mov	r19, r24
    2390:	29 2f       	mov	r18, r25
    2392:	60 e0       	ldi	r22, 0x00	; 0
    2394:	70 e0       	ldi	r23, 0x00	; 0
    2396:	80 e8       	ldi	r24, 0x80	; 128
    2398:	9f e3       	ldi	r25, 0x3F	; 63
    239a:	42 2f       	mov	r20, r18
    239c:	0b 2f       	mov	r16, r27
    239e:	1a 2f       	mov	r17, r26
    23a0:	23 2f       	mov	r18, r19
    23a2:	34 2f       	mov	r19, r20
    23a4:	a9 01       	movw	r20, r18
    23a6:	98 01       	movw	r18, r16
    23a8:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__divsf3>
    23ac:	2a e9       	ldi	r18, 0x9A	; 154
    23ae:	39 ef       	ldi	r19, 0xF9	; 249
    23b0:	4e e2       	ldi	r20, 0x2E	; 46
    23b2:	55 e4       	ldi	r21, 0x45	; 69
    23b4:	0e 94 c5 18 	call	0x318a	; 0x318a <__mulsf3>
    23b8:	20 e0       	ldi	r18, 0x00	; 0
    23ba:	30 e0       	ldi	r19, 0x00	; 0
    23bc:	40 e2       	ldi	r20, 0x20	; 32
    23be:	51 e4       	ldi	r21, 0x41	; 65
    23c0:	0e 94 c5 18 	call	0x318a	; 0x318a <__mulsf3>
    23c4:	0e 94 06 18 	call	0x300c	; 0x300c <__fixsfsi>
    23c8:	88 27       	eor	r24, r24
    23ca:	77 fd       	sbrc	r23, 7
    23cc:	80 95       	com	r24
    23ce:	98 2f       	mov	r25, r24
    23d0:	0e 94 39 18 	call	0x3072	; 0x3072 <__floatsisf>
	distanceInt = (int)distance;
    23d4:	0e 94 06 18 	call	0x300c	; 0x300c <__fixsfsi>
	if(distanceInt>800)
	{
		distanceInt=800;
	}
	return distanceInt;
    23d8:	86 2f       	mov	r24, r22
    23da:	97 2f       	mov	r25, r23
    23dc:	23 e0       	ldi	r18, 0x03	; 3
    23de:	81 32       	cpi	r24, 0x21	; 33
    23e0:	92 07       	cpc	r25, r18
    23e2:	10 f0       	brcs	.+4      	; 0x23e8 <Sharp_GP2D12_estimation+0x7a>
    23e4:	80 e2       	ldi	r24, 0x20	; 32
    23e6:	93 e0       	ldi	r25, 0x03	; 3
}
    23e8:	1f 91       	pop	r17
    23ea:	0f 91       	pop	r16
    23ec:	08 95       	ret

000023ee <sharp_check>:

unsigned int sharp_check(void)
{
    sharp=ADC_Conversion(7);
    23ee:	87 e0       	ldi	r24, 0x07	; 7
    23f0:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    23f4:	80 93 6c 00 	sts	0x006C, r24
    value= Sharp_GP2D12_estimation(sharp);
    23f8:	0e 94 b7 11 	call	0x236e	; 0x236e <Sharp_GP2D12_estimation>
    23fc:	90 93 1c 01 	sts	0x011C, r25
    2400:	80 93 1b 01 	sts	0x011B, r24
    2404:	2f ef       	ldi	r18, 0xFF	; 255
    2406:	3f eb       	ldi	r19, 0xBF	; 191
    2408:	46 e0       	ldi	r20, 0x06	; 6
    240a:	21 50       	subi	r18, 0x01	; 1
    240c:	30 40       	sbci	r19, 0x00	; 0
    240e:	40 40       	sbci	r20, 0x00	; 0
    2410:	e1 f7       	brne	.-8      	; 0x240a <sharp_check+0x1c>
    2412:	00 c0       	rjmp	.+0      	; 0x2414 <sharp_check+0x26>
    2414:	00 00       	nop
	_delay_ms(300);
	if(value<150)
	 {
	   return 1;
    2416:	21 e0       	ldi	r18, 0x01	; 1
    2418:	30 e0       	ldi	r19, 0x00	; 0
    241a:	86 39       	cpi	r24, 0x96	; 150
    241c:	91 05       	cpc	r25, r1
    241e:	10 f0       	brcs	.+4      	; 0x2424 <sharp_check+0x36>
    2420:	20 e0       	ldi	r18, 0x00	; 0
    2422:	30 e0       	ldi	r19, 0x00	; 0
	 }
	 return 0;
}
    2424:	82 2f       	mov	r24, r18
    2426:	93 2f       	mov	r25, r19
    2428:	08 95       	ret

0000242a <set_path_to_99>:
  * Example Call: set_path_to_99()
  */

void set_path_to_99()
{   
	for(j=0;j<20;++j)
    242a:	10 92 b6 00 	sts	0x00B6, r1
    242e:	80 91 b6 00 	lds	r24, 0x00B6
    2432:	84 31       	cpi	r24, 0x14	; 20
    2434:	b0 f4       	brcc	.+44     	; 0x2462 <set_path_to_99+0x38>
	initial_home_run[j]=99;
    2436:	8d eb       	ldi	r24, 0xBD	; 189
    2438:	90 e0       	ldi	r25, 0x00	; 0
    243a:	23 e6       	ldi	r18, 0x63	; 99
    243c:	30 e0       	ldi	r19, 0x00	; 0
    243e:	e0 91 b6 00 	lds	r30, 0x00B6
    2442:	f0 e0       	ldi	r31, 0x00	; 0
    2444:	ee 0f       	add	r30, r30
    2446:	ff 1f       	adc	r31, r31
    2448:	e8 0f       	add	r30, r24
    244a:	f9 1f       	adc	r31, r25
    244c:	31 83       	std	Z+1, r19	; 0x01
    244e:	20 83       	st	Z, r18
  * Example Call: set_path_to_99()
  */

void set_path_to_99()
{   
	for(j=0;j<20;++j)
    2450:	40 91 b6 00 	lds	r20, 0x00B6
    2454:	4f 5f       	subi	r20, 0xFF	; 255
    2456:	40 93 b6 00 	sts	0x00B6, r20
    245a:	40 91 b6 00 	lds	r20, 0x00B6
    245e:	44 31       	cpi	r20, 0x14	; 20
    2460:	70 f3       	brcs	.-36     	; 0x243e <set_path_to_99+0x14>
    2462:	08 95       	ret

00002464 <reach_destination>:
           It also transfers the the starting position to firebird V via xbee module so that firebird can calculate its Dijkstra path right at start and send the same back to it. 
  * Example Call: reach_destination(4,'A',0)
  */

void reach_destination(unsigned char s1, unsigned char s2 , unsigned int ini_orient)
{  
    2464:	0f 93       	push	r16
    2466:	1f 93       	push	r17
    2468:	cf 93       	push	r28
    246a:	df 93       	push	r29
    246c:	08 2f       	mov	r16, r24
    246e:	16 2f       	mov	r17, r22
    2470:	ea 01       	movw	r28, r20
    set_path_to_99();
    2472:	0e 94 15 12 	call	0x242a	; 0x242a <set_path_to_99>
	
	orient=ini_orient;
    2476:	d0 93 f9 00 	sts	0x00F9, r29
    247a:	c0 93 f8 00 	sts	0x00F8, r28
	curr_pos = convert_rowcol_to_seq(s1,s2);
    247e:	80 2f       	mov	r24, r16
    2480:	61 2f       	mov	r22, r17
    2482:	0e 94 c2 0d 	call	0x1b84	; 0x1b84 <convert_rowcol_to_seq>
    2486:	90 93 b5 00 	sts	0x00B5, r25
    248a:	80 93 b4 00 	sts	0x00B4, r24
	
	xbee_seq_node_transfer(curr_pos,0);
    248e:	80 91 b4 00 	lds	r24, 0x00B4
    2492:	90 91 b5 00 	lds	r25, 0x00B5
    2496:	60 e0       	ldi	r22, 0x00	; 0
    2498:	70 e0       	ldi	r23, 0x00	; 0
    249a:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <xbee_seq_node_transfer>
}
    249e:	df 91       	pop	r29
    24a0:	cf 91       	pop	r28
    24a2:	1f 91       	pop	r17
    24a4:	0f 91       	pop	r16
    24a6:	08 95       	ret

000024a8 <check_path_rec>:
  * Example Call: check_path_rec()
  */

void check_path_rec()
{
	if((initial_home_run[node_count-1]==27) && (home_bit[0]==0))
    24a8:	e0 91 96 00 	lds	r30, 0x0096
    24ac:	f0 91 97 00 	lds	r31, 0x0097
    24b0:	ee 0f       	add	r30, r30
    24b2:	ff 1f       	adc	r31, r31
    24b4:	e5 54       	subi	r30, 0x45	; 69
    24b6:	ff 4f       	sbci	r31, 0xFF	; 255
    24b8:	80 81       	ld	r24, Z
    24ba:	91 81       	ldd	r25, Z+1	; 0x01
    24bc:	8b 31       	cpi	r24, 0x1B	; 27
    24be:	91 05       	cpc	r25, r1
    24c0:	71 f4       	brne	.+28     	; 0x24de <check_path_rec+0x36>
    24c2:	80 91 a4 00 	lds	r24, 0x00A4
    24c6:	90 91 a5 00 	lds	r25, 0x00A5
    24ca:	00 97       	sbiw	r24, 0x00	; 0
    24cc:	41 f4       	brne	.+16     	; 0x24de <check_path_rec+0x36>
	{
		UDR = 0x40;
    24ce:	80 e4       	ldi	r24, 0x40	; 64
    24d0:	8c b9       	out	0x0c, r24	; 12
		home_bit[0]=1;
    24d2:	81 e0       	ldi	r24, 0x01	; 1
    24d4:	90 e0       	ldi	r25, 0x00	; 0
    24d6:	90 93 a5 00 	sts	0x00A5, r25
    24da:	80 93 a4 00 	sts	0x00A4, r24
    24de:	08 95       	ret

000024e0 <all_bot_ready>:
  * Example Call: all_bot_ready()
  */ 

int all_bot_ready()
{
 	if((home_bit[0]==1) && (home_bit[1]==1) && (home_bit[2]==1)) return 1; 
    24e0:	80 91 a4 00 	lds	r24, 0x00A4
    24e4:	90 91 a5 00 	lds	r25, 0x00A5
    24e8:	81 30       	cpi	r24, 0x01	; 1
    24ea:	91 05       	cpc	r25, r1
    24ec:	99 f4       	brne	.+38     	; 0x2514 <all_bot_ready+0x34>
    24ee:	80 91 a6 00 	lds	r24, 0x00A6
    24f2:	90 91 a7 00 	lds	r25, 0x00A7
    24f6:	81 30       	cpi	r24, 0x01	; 1
    24f8:	91 05       	cpc	r25, r1
    24fa:	79 f4       	brne	.+30     	; 0x251a <all_bot_ready+0x3a>
    24fc:	20 91 a8 00 	lds	r18, 0x00A8
    2500:	30 91 a9 00 	lds	r19, 0x00A9
  * Output: None
  * Logic: This function  checks whether all the bots have finished their set/cycle/navigation and returns 1 or 0 accordingly
  * Example Call: all_bot_ready()
  */ 

int all_bot_ready()
    2504:	81 e0       	ldi	r24, 0x01	; 1
    2506:	90 e0       	ldi	r25, 0x00	; 0
    2508:	21 30       	cpi	r18, 0x01	; 1
    250a:	31 05       	cpc	r19, r1
    250c:	41 f0       	breq	.+16     	; 0x251e <all_bot_ready+0x3e>
    250e:	80 e0       	ldi	r24, 0x00	; 0
    2510:	90 e0       	ldi	r25, 0x00	; 0
    2512:	08 95       	ret
{
 	if((home_bit[0]==1) && (home_bit[1]==1) && (home_bit[2]==1)) return 1; 
	return 0;
    2514:	80 e0       	ldi	r24, 0x00	; 0
    2516:	90 e0       	ldi	r25, 0x00	; 0
    2518:	08 95       	ret
    251a:	80 e0       	ldi	r24, 0x00	; 0
    251c:	90 e0       	ldi	r25, 0x00	; 0
}
    251e:	08 95       	ret

00002520 <line_follow_set0>:
           
  * Example Call: line_follow_set0()
  */ 

void line_follow_set0(void)
{
    2520:	8f 92       	push	r8
    2522:	9f 92       	push	r9
    2524:	af 92       	push	r10
    2526:	bf 92       	push	r11
    2528:	cf 92       	push	r12
    252a:	df 92       	push	r13
    252c:	ef 92       	push	r14
    252e:	ff 92       	push	r15
    2530:	0f 93       	push	r16
    2532:	1f 93       	push	r17
    2534:	cf 93       	push	r28
    2536:	df 93       	push	r29
	Left_white_line = ADC_Conversion(3);
    2538:	83 e0       	ldi	r24, 0x03	; 3
    253a:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    253e:	80 93 79 00 	sts	0x0079, r24
	Center_white_line = ADC_Conversion(4);
    2542:	84 e0       	ldi	r24, 0x04	; 4
    2544:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    2548:	80 93 78 00 	sts	0x0078, r24
	Right_white_line = ADC_Conversion(5);
    254c:	85 e0       	ldi	r24, 0x05	; 5
    254e:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    2552:	80 93 77 00 	sts	0x0077, r24
	error = Right_white_line - Left_white_line;
    2556:	90 e0       	ldi	r25, 0x00	; 0
    2558:	20 91 79 00 	lds	r18, 0x0079
    255c:	82 1b       	sub	r24, r18
    255e:	91 09       	sbc	r25, r1
    2560:	90 93 13 01 	sts	0x0113, r25
    2564:	80 93 12 01 	sts	0x0112, r24
	int motorSpeed = Kp * error + Kd * (error - lastError);
    2568:	60 91 12 01 	lds	r22, 0x0112
    256c:	70 91 13 01 	lds	r23, 0x0113
    2570:	c0 90 67 00 	lds	r12, 0x0067
    2574:	d0 90 68 00 	lds	r13, 0x0068
    2578:	e0 90 69 00 	lds	r14, 0x0069
    257c:	f0 90 6a 00 	lds	r15, 0x006A
    2580:	c0 91 12 01 	lds	r28, 0x0112
    2584:	d0 91 13 01 	lds	r29, 0x0113
    2588:	00 91 7a 00 	lds	r16, 0x007A
    258c:	10 91 7b 00 	lds	r17, 0x007B
    2590:	80 90 63 00 	lds	r8, 0x0063
    2594:	90 90 64 00 	lds	r9, 0x0064
    2598:	a0 90 65 00 	lds	r10, 0x0065
    259c:	b0 90 66 00 	lds	r11, 0x0066
    25a0:	88 27       	eor	r24, r24
    25a2:	77 fd       	sbrc	r23, 7
    25a4:	80 95       	com	r24
    25a6:	98 2f       	mov	r25, r24
    25a8:	0e 94 39 18 	call	0x3072	; 0x3072 <__floatsisf>
    25ac:	a7 01       	movw	r20, r14
    25ae:	96 01       	movw	r18, r12
    25b0:	0e 94 c5 18 	call	0x318a	; 0x318a <__mulsf3>
    25b4:	6b 01       	movw	r12, r22
    25b6:	7c 01       	movw	r14, r24
    25b8:	be 01       	movw	r22, r28
    25ba:	60 1b       	sub	r22, r16
    25bc:	71 0b       	sbc	r23, r17
    25be:	88 27       	eor	r24, r24
    25c0:	77 fd       	sbrc	r23, 7
    25c2:	80 95       	com	r24
    25c4:	98 2f       	mov	r25, r24
    25c6:	0e 94 39 18 	call	0x3072	; 0x3072 <__floatsisf>
    25ca:	a5 01       	movw	r20, r10
    25cc:	94 01       	movw	r18, r8
    25ce:	0e 94 c5 18 	call	0x318a	; 0x318a <__mulsf3>
    25d2:	9b 01       	movw	r18, r22
    25d4:	ac 01       	movw	r20, r24
    25d6:	c7 01       	movw	r24, r14
    25d8:	b6 01       	movw	r22, r12
    25da:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <__addsf3>
    25de:	0e 94 06 18 	call	0x300c	; 0x300c <__fixsfsi>
	lastError = error;
    25e2:	80 91 12 01 	lds	r24, 0x0112
    25e6:	90 91 13 01 	lds	r25, 0x0113
    25ea:	90 93 7b 00 	sts	0x007B, r25
    25ee:	80 93 7a 00 	sts	0x007A, r24
	int rightMotorSpeed = rightBaseSpeed - motorSpeed;
    25f2:	00 91 62 00 	lds	r16, 0x0062
    25f6:	10 e0       	ldi	r17, 0x00	; 0
	int leftMotorSpeed = leftBaseSpeed + motorSpeed;
    25f8:	80 91 61 00 	lds	r24, 0x0061
    25fc:	eb 01       	movw	r28, r22
    25fe:	c8 0f       	add	r28, r24
    2600:	d1 1d       	adc	r29, r1
    2602:	06 1b       	sub	r16, r22
    2604:	17 0b       	sbc	r17, r23
    2606:	08 33       	cpi	r16, 0x38	; 56
    2608:	11 05       	cpc	r17, r1
    260a:	14 f0       	brlt	.+4      	; 0x2610 <line_follow_set0+0xf0>
    260c:	07 e3       	ldi	r16, 0x37	; 55
    260e:	10 e0       	ldi	r17, 0x00	; 0
    2610:	c8 33       	cpi	r28, 0x38	; 56
    2612:	d1 05       	cpc	r29, r1
    2614:	14 f0       	brlt	.+4      	; 0x261a <line_follow_set0+0xfa>
    2616:	c7 e3       	ldi	r28, 0x37	; 55
    2618:	d0 e0       	ldi	r29, 0x00	; 0
	if (rightMotorSpeed > rightMaxSpeed ) rightMotorSpeed = rightMaxSpeed;
	if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
	if (rightMotorSpeed < 0) rightMotorSpeed = 0;
	if (leftMotorSpeed < 0) leftMotorSpeed = 0;

	forward();
    261a:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <forward>
	velocity(leftMotorSpeed,rightMotorSpeed);
    261e:	ce 01       	movw	r24, r28
    2620:	dd 23       	and	r29, r29
    2622:	14 f4       	brge	.+4      	; 0x2628 <line_follow_set0+0x108>
    2624:	80 e0       	ldi	r24, 0x00	; 0
    2626:	90 e0       	ldi	r25, 0x00	; 0
    2628:	b8 01       	movw	r22, r16
    262a:	11 23       	and	r17, r17
    262c:	14 f4       	brge	.+4      	; 0x2632 <line_follow_set0+0x112>
    262e:	60 e0       	ldi	r22, 0x00	; 0
    2630:	70 e0       	ldi	r23, 0x00	; 0
    2632:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>

	if(Center_white_line>100 && Left_white_line>100 && Right_white_line>100)
    2636:	80 91 78 00 	lds	r24, 0x0078
    263a:	85 36       	cpi	r24, 0x65	; 101
    263c:	08 f4       	brcc	.+2      	; 0x2640 <line_follow_set0+0x120>
    263e:	a5 c0       	rjmp	.+330    	; 0x278a <line_follow_set0+0x26a>
    2640:	80 91 79 00 	lds	r24, 0x0079
    2644:	85 36       	cpi	r24, 0x65	; 101
    2646:	08 f4       	brcc	.+2      	; 0x264a <line_follow_set0+0x12a>
    2648:	a0 c0       	rjmp	.+320    	; 0x278a <line_follow_set0+0x26a>
    264a:	80 91 77 00 	lds	r24, 0x0077
    264e:	85 36       	cpi	r24, 0x65	; 101
    2650:	08 f4       	brcc	.+2      	; 0x2654 <line_follow_set0+0x134>
    2652:	9b c0       	rjmp	.+310    	; 0x278a <line_follow_set0+0x26a>
	{	
		update_curr_pos();
    2654:	0e 94 8f 00 	call	0x11e	; 0x11e <update_curr_pos>
		
		//velocity(40,40);
		//_delay_ms(300);
		stop();
    2658:	0e 94 b9 0a 	call	0x1572	; 0x1572 <stop>
		buzz();
    265c:	0e 94 02 02 	call	0x404	; 0x404 <buzz>
		
       if(curr_pos==21)
    2660:	80 91 b4 00 	lds	r24, 0x00B4
    2664:	90 91 b5 00 	lds	r25, 0x00B5
    2668:	85 31       	cpi	r24, 0x15	; 21
    266a:	91 05       	cpc	r25, r1
    266c:	b9 f5       	brne	.+110    	; 0x26dc <line_follow_set0+0x1bc>
		{
			ensure_orient(1);
    266e:	81 e0       	ldi	r24, 0x01	; 1
    2670:	90 e0       	ldi	r25, 0x00	; 0
    2672:	0e 94 bd 0a 	call	0x157a	; 0x157a <ensure_orient>
			UDR = 0x40;
    2676:	80 e4       	ldi	r24, 0x40	; 64
    2678:	8c b9       	out	0x0c, r24	; 12
    267a:	2f ef       	ldi	r18, 0xFF	; 255
    267c:	3f e3       	ldi	r19, 0x3F	; 63
    267e:	42 e0       	ldi	r20, 0x02	; 2
    2680:	21 50       	subi	r18, 0x01	; 1
    2682:	30 40       	sbci	r19, 0x00	; 0
    2684:	40 40       	sbci	r20, 0x00	; 0
    2686:	e1 f7       	brne	.-8      	; 0x2680 <line_follow_set0+0x160>
    2688:	00 c0       	rjmp	.+0      	; 0x268a <line_follow_set0+0x16a>
    268a:	00 00       	nop
			_delay_ms(100);
			UDR = 0x40;
    268c:	8c b9       	out	0x0c, r24	; 12
    268e:	2f ef       	ldi	r18, 0xFF	; 255
    2690:	3f e3       	ldi	r19, 0x3F	; 63
    2692:	42 e0       	ldi	r20, 0x02	; 2
    2694:	21 50       	subi	r18, 0x01	; 1
    2696:	30 40       	sbci	r19, 0x00	; 0
    2698:	40 40       	sbci	r20, 0x00	; 0
    269a:	e1 f7       	brne	.-8      	; 0x2694 <line_follow_set0+0x174>
    269c:	00 c0       	rjmp	.+0      	; 0x269e <line_follow_set0+0x17e>
    269e:	00 00       	nop
			_delay_ms(100);
			UDR = 0x40;
    26a0:	8c b9       	out	0x0c, r24	; 12
			home_bit[0] = 1;
    26a2:	81 e0       	ldi	r24, 0x01	; 1
    26a4:	90 e0       	ldi	r25, 0x00	; 0
    26a6:	90 93 a5 00 	sts	0x00A5, r25
    26aa:	80 93 a4 00 	sts	0x00A4, r24
			while(all_bot_ready() == 0);
    26ae:	0e 94 70 12 	call	0x24e0	; 0x24e0 <all_bot_ready>
    26b2:	00 97       	sbiw	r24, 0x00	; 0
    26b4:	e1 f3       	breq	.-8      	; 0x26ae <line_follow_set0+0x18e>
			all_bot_clear();
    26b6:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <all_bot_clear>
			event = 0;
    26ba:	10 92 9d 00 	sts	0x009D, r1
    26be:	10 92 9c 00 	sts	0x009C, r1
			cycle = 1;
    26c2:	81 e0       	ldi	r24, 0x01	; 1
    26c4:	90 e0       	ldi	r25, 0x00	; 0
    26c6:	90 93 a3 00 	sts	0x00A3, r25
    26ca:	80 93 a2 00 	sts	0x00A2, r24
			set_cover=50;
    26ce:	82 e3       	ldi	r24, 0x32	; 50
    26d0:	90 e0       	ldi	r25, 0x00	; 0
    26d2:	90 93 9f 00 	sts	0x009F, r25
    26d6:	80 93 9e 00 	sts	0x009E, r24
    26da:	38 c0       	rjmp	.+112    	; 0x274c <line_follow_set0+0x22c>
		}
		else if(curr_pos==27)
    26dc:	80 91 b4 00 	lds	r24, 0x00B4
    26e0:	90 91 b5 00 	lds	r25, 0x00B5
    26e4:	8b 31       	cpi	r24, 0x1B	; 27
    26e6:	91 05       	cpc	r25, r1
    26e8:	59 f5       	brne	.+86     	; 0x2740 <line_follow_set0+0x220>
		{
			event=3;
    26ea:	83 e0       	ldi	r24, 0x03	; 3
    26ec:	90 e0       	ldi	r25, 0x00	; 0
    26ee:	90 93 9d 00 	sts	0x009D, r25
    26f2:	80 93 9c 00 	sts	0x009C, r24
			cycle = 1;
    26f6:	c1 e0       	ldi	r28, 0x01	; 1
    26f8:	d0 e0       	ldi	r29, 0x00	; 0
    26fa:	d0 93 a3 00 	sts	0x00A3, r29
    26fe:	c0 93 a2 00 	sts	0x00A2, r28
			ensure_orient(2);
    2702:	82 e0       	ldi	r24, 0x02	; 2
    2704:	90 e0       	ldi	r25, 0x00	; 0
    2706:	0e 94 bd 0a 	call	0x157a	; 0x157a <ensure_orient>
			home_bit[0]=1;
    270a:	d0 93 a5 00 	sts	0x00A5, r29
    270e:	c0 93 a4 00 	sts	0x00A4, r28
			UDR = 0x40;
    2712:	80 e4       	ldi	r24, 0x40	; 64
    2714:	8c b9       	out	0x0c, r24	; 12
    2716:	2f ef       	ldi	r18, 0xFF	; 255
    2718:	3f e3       	ldi	r19, 0x3F	; 63
    271a:	42 e0       	ldi	r20, 0x02	; 2
    271c:	21 50       	subi	r18, 0x01	; 1
    271e:	30 40       	sbci	r19, 0x00	; 0
    2720:	40 40       	sbci	r20, 0x00	; 0
    2722:	e1 f7       	brne	.-8      	; 0x271c <line_follow_set0+0x1fc>
    2724:	00 c0       	rjmp	.+0      	; 0x2726 <line_follow_set0+0x206>
    2726:	00 00       	nop
			_delay_ms(100);
			UDR = 0x40;
    2728:	8c b9       	out	0x0c, r24	; 12
    272a:	2f ef       	ldi	r18, 0xFF	; 255
    272c:	3f e3       	ldi	r19, 0x3F	; 63
    272e:	42 e0       	ldi	r20, 0x02	; 2
    2730:	21 50       	subi	r18, 0x01	; 1
    2732:	30 40       	sbci	r19, 0x00	; 0
    2734:	40 40       	sbci	r20, 0x00	; 0
    2736:	e1 f7       	brne	.-8      	; 0x2730 <line_follow_set0+0x210>
    2738:	00 c0       	rjmp	.+0      	; 0x273a <line_follow_set0+0x21a>
    273a:	00 00       	nop
			_delay_ms(100);
			UDR = 0x40;
    273c:	8c b9       	out	0x0c, r24	; 12
    273e:	06 c0       	rjmp	.+12     	; 0x274c <line_follow_set0+0x22c>
		}
		else
		{
			event=0;
    2740:	10 92 9d 00 	sts	0x009D, r1
    2744:	10 92 9c 00 	sts	0x009C, r1
			//forward();
			//_delay_ms(150);
			just_forward();
    2748:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
		}
		if((curr_pos == 25) && (set_cover == 0))
    274c:	80 91 b4 00 	lds	r24, 0x00B4
    2750:	90 91 b5 00 	lds	r25, 0x00B5
    2754:	89 31       	cpi	r24, 0x19	; 25
    2756:	91 05       	cpc	r25, r1
    2758:	41 f4       	brne	.+16     	; 0x276a <line_follow_set0+0x24a>
    275a:	80 91 9e 00 	lds	r24, 0x009E
    275e:	90 91 9f 00 	lds	r25, 0x009F
    2762:	00 97       	sbiw	r24, 0x00	; 0
    2764:	11 f4       	brne	.+4      	; 0x276a <line_follow_set0+0x24a>
		{
			all_xbee_clear();
    2766:	0e 94 df 00 	call	0x1be	; 0x1be <all_xbee_clear>
		}
		if((curr_pos == 23) && (set_cover == 50))
    276a:	80 91 b4 00 	lds	r24, 0x00B4
    276e:	90 91 b5 00 	lds	r25, 0x00B5
    2772:	87 31       	cpi	r24, 0x17	; 23
    2774:	91 05       	cpc	r25, r1
    2776:	49 f4       	brne	.+18     	; 0x278a <line_follow_set0+0x26a>
    2778:	80 91 9e 00 	lds	r24, 0x009E
    277c:	90 91 9f 00 	lds	r25, 0x009F
    2780:	82 33       	cpi	r24, 0x32	; 50
    2782:	91 05       	cpc	r25, r1
    2784:	11 f4       	brne	.+4      	; 0x278a <line_follow_set0+0x26a>
		{
			all_xbee_clear();
    2786:	0e 94 df 00 	call	0x1be	; 0x1be <all_xbee_clear>
		}
	}	 
}
    278a:	df 91       	pop	r29
    278c:	cf 91       	pop	r28
    278e:	1f 91       	pop	r17
    2790:	0f 91       	pop	r16
    2792:	ff 90       	pop	r15
    2794:	ef 90       	pop	r14
    2796:	df 90       	pop	r13
    2798:	cf 90       	pop	r12
    279a:	bf 90       	pop	r11
    279c:	af 90       	pop	r10
    279e:	9f 90       	pop	r9
    27a0:	8f 90       	pop	r8
    27a2:	08 95       	ret

000027a4 <main>:
 cycle 5: This cycle marks the end of task.		  		  

*/

void main()
{
    27a4:	2f 92       	push	r2
    27a6:	3f 92       	push	r3
    27a8:	4f 92       	push	r4
    27aa:	5f 92       	push	r5
    27ac:	6f 92       	push	r6
    27ae:	7f 92       	push	r7
    27b0:	8f 92       	push	r8
    27b2:	9f 92       	push	r9
    27b4:	af 92       	push	r10
    27b6:	bf 92       	push	r11
    27b8:	cf 92       	push	r12
    27ba:	df 92       	push	r13
    27bc:	ef 92       	push	r14
    27be:	ff 92       	push	r15
    27c0:	0f 93       	push	r16
    27c2:	1f 93       	push	r17
    27c4:	cf 93       	push	r28
    27c6:	df 93       	push	r29
   init_devices();
    27c8:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <init_devices>
    27cc:	8f ef       	ldi	r24, 0xFF	; 255
    27ce:	9f e9       	ldi	r25, 0x9F	; 159
    27d0:	a5 e0       	ldi	r26, 0x05	; 5
    27d2:	81 50       	subi	r24, 0x01	; 1
    27d4:	90 40       	sbci	r25, 0x00	; 0
    27d6:	a0 40       	sbci	r26, 0x00	; 0
    27d8:	e1 f7       	brne	.-8      	; 0x27d2 <main+0x2e>
    27da:	00 c0       	rjmp	.+0      	; 0x27dc <main+0x38>
    27dc:	00 00       	nop
   _delay_ms(250);
  reach_destination('5','G',3);
    27de:	85 e3       	ldi	r24, 0x35	; 53
    27e0:	67 e4       	ldi	r22, 0x47	; 71
    27e2:	43 e0       	ldi	r20, 0x03	; 3
    27e4:	50 e0       	ldi	r21, 0x00	; 0
    27e6:	0e 94 32 12 	call	0x2464	; 0x2464 <reach_destination>
  Servo_Value=Convert_Angle(0);
    27ea:	80 e0       	ldi	r24, 0x00	; 0
    27ec:	0e 94 87 11 	call	0x230e	; 0x230e <Convert_Angle>
    27f0:	80 93 6e 00 	sts	0x006E, r24
    27f4:	8f ef       	ldi	r24, 0xFF	; 255
    27f6:	9f ea       	ldi	r25, 0xAF	; 175
    27f8:	a1 e0       	ldi	r26, 0x01	; 1
    27fa:	81 50       	subi	r24, 0x01	; 1
    27fc:	90 40       	sbci	r25, 0x00	; 0
    27fe:	a0 40       	sbci	r26, 0x00	; 0
    2800:	e1 f7       	brne	.-8      	; 0x27fa <main+0x56>
    2802:	00 c0       	rjmp	.+0      	; 0x2804 <main+0x60>
    2804:	00 00       	nop
		  }
		  if(event == 2)
		  {
			  if(all_bot_ready() == 1)
			  {
				  cycle = 1;
    2806:	ee 24       	eor	r14, r14
    2808:	ff 24       	eor	r15, r15
    280a:	e3 94       	inc	r14
				  event = 0;
				  all_bot_clear();
				  xbee_com = 1;
    280c:	99 24       	eor	r9, r9
    280e:	93 94       	inc	r9
			  }
		  }
		  if(event == 1)
		  {
			  run_home();
			  event = 2;
    2810:	c2 e0       	ldi	r28, 0x02	; 2
    2812:	d0 e0       	ldi	r29, 0x00	; 0
			  
			  if(all_bot_ready() == 1)
			  {
				  all_bot_clear();
				  all_xbee_clear();
				  xbee_com = -1;
    2814:	88 24       	eor	r8, r8
    2816:	8a 94       	dec	r8
			  else if(set_cover==50)
			  {
				  if(left_plant_set2_count==0)line_follow_till_2(13);
				  else
				  {
					  line_follow_till_2(left_plant_set2[array_index]);
    2818:	0f 2e       	mov	r0, r31
    281a:	f7 e0       	ldi	r31, 0x07	; 7
    281c:	2f 2e       	mov	r2, r31
    281e:	f1 e0       	ldi	r31, 0x01	; 1
    2820:	3f 2e       	mov	r3, r31
    2822:	f0 2d       	mov	r31, r0
			  if(set_cover==0)
			  {
				  if(right_plant_set2_count==0)line_follow_till_2(7);
				  else
				  {
					  line_follow_till_2(right_plant_set2[array_index]);
    2824:	0f 2e       	mov	r0, r31
    2826:	fe ee       	ldi	r31, 0xEE	; 238
    2828:	af 2e       	mov	r10, r31
    282a:	f0 e0       	ldi	r31, 0x00	; 0
    282c:	bf 2e       	mov	r11, r31
    282e:	f0 2d       	mov	r31, r0
		  UDR = 0x40;
		  _delay_ms(100);
		  UDR = 0x40;
		  _delay_ms(100);
		  UDR = 0x40;
		  home_bit[0] = 1;
    2830:	0f 2e       	mov	r0, r31
    2832:	f4 ea       	ldi	r31, 0xA4	; 164
    2834:	4f 2e       	mov	r4, r31
    2836:	f0 e0       	ldi	r31, 0x00	; 0
    2838:	5f 2e       	mov	r5, r31
    283a:	f0 2d       	mov	r31, r0
			  else if(set_cover==50)
			  {
				  if(left_plant_set1_count==0)line_follow_till_1(41);
				  else
				  {
					  line_follow_till_1(left_plant_set1[array_index]);
    283c:	0f 2e       	mov	r0, r31
    283e:	fc ef       	ldi	r31, 0xFC	; 252
    2840:	6f 2e       	mov	r6, r31
    2842:	f0 e0       	ldi	r31, 0x00	; 0
    2844:	7f 2e       	mov	r7, r31
    2846:	f0 2d       	mov	r31, r0
			  if(set_cover==0)
			  {
				  if(right_plant_set1_count==0)line_follow_till_1(35);
				  else
				  {
					  line_follow_till_1(right_plant_set1[array_index]);
    2848:	0f 2e       	mov	r0, r31
    284a:	fa ea       	ldi	r31, 0xAA	; 170
    284c:	cf 2e       	mov	r12, r31
    284e:	f0 e0       	ldi	r31, 0x00	; 0
    2850:	df 2e       	mov	r13, r31
    2852:	f0 2d       	mov	r31, r0
			  line_follow_set0();
		  }
		  if(event == 3)
		  {
			  xbee_com = 1;
			  set_cover = 50;
    2854:	02 e3       	ldi	r16, 0x32	; 50
    2856:	10 e0       	ldi	r17, 0x00	; 0
  Servo_Value=Convert_Angle(0);
  _delay_ms(75);
  while(1)
  {
	  
	  if(cycle == 0)
    2858:	80 91 a2 00 	lds	r24, 0x00A2
    285c:	90 91 a3 00 	lds	r25, 0x00A3
    2860:	00 97       	sbiw	r24, 0x00	; 0
    2862:	09 f0       	breq	.+2      	; 0x2866 <main+0xc2>
    2864:	45 c0       	rjmp	.+138    	; 0x28f0 <main+0x14c>
	  {
		  if(event == 0)
    2866:	80 91 9c 00 	lds	r24, 0x009C
    286a:	90 91 9d 00 	lds	r25, 0x009D
    286e:	00 97       	sbiw	r24, 0x00	; 0
    2870:	b1 f4       	brne	.+44     	; 0x289e <main+0xfa>
		  {
			  check_path_rec();
    2872:	0e 94 54 12 	call	0x24a8	; 0x24a8 <check_path_rec>
			  
			  if(all_bot_ready() == 1)
    2876:	0e 94 70 12 	call	0x24e0	; 0x24e0 <all_bot_ready>
    287a:	81 30       	cpi	r24, 0x01	; 1
    287c:	91 05       	cpc	r25, r1
    287e:	79 f4       	brne	.+30     	; 0x289e <main+0xfa>
			  {
				  all_bot_clear();
    2880:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <all_bot_clear>
				  all_xbee_clear();
    2884:	0e 94 df 00 	call	0x1be	; 0x1be <all_xbee_clear>
				  xbee_com = -1;
    2888:	80 92 98 00 	sts	0x0098, r8
				  event++;
    288c:	80 91 9c 00 	lds	r24, 0x009C
    2890:	90 91 9d 00 	lds	r25, 0x009D
    2894:	01 96       	adiw	r24, 0x01	; 1
    2896:	90 93 9d 00 	sts	0x009D, r25
    289a:	80 93 9c 00 	sts	0x009C, r24
			  }
		  }
		  if(event == 1)
    289e:	80 91 9c 00 	lds	r24, 0x009C
    28a2:	90 91 9d 00 	lds	r25, 0x009D
    28a6:	81 30       	cpi	r24, 0x01	; 1
    28a8:	91 05       	cpc	r25, r1
    28aa:	51 f4       	brne	.+20     	; 0x28c0 <main+0x11c>
		  {
			  run_home();
    28ac:	0e 94 10 02 	call	0x420	; 0x420 <run_home>
			  event = 2;
    28b0:	d0 93 9d 00 	sts	0x009D, r29
    28b4:	c0 93 9c 00 	sts	0x009C, r28
			  cycle = 0;
    28b8:	10 92 a3 00 	sts	0x00A3, r1
    28bc:	10 92 a2 00 	sts	0x00A2, r1
		  }
		  if(event == 2)
    28c0:	80 91 9c 00 	lds	r24, 0x009C
    28c4:	90 91 9d 00 	lds	r25, 0x009D
    28c8:	82 30       	cpi	r24, 0x02	; 2
    28ca:	91 05       	cpc	r25, r1
    28cc:	89 f4       	brne	.+34     	; 0x28f0 <main+0x14c>
		  {
			  if(all_bot_ready() == 1)
    28ce:	0e 94 70 12 	call	0x24e0	; 0x24e0 <all_bot_ready>
    28d2:	81 30       	cpi	r24, 0x01	; 1
    28d4:	91 05       	cpc	r25, r1
    28d6:	61 f4       	brne	.+24     	; 0x28f0 <main+0x14c>
			  {
				  cycle = 1;
    28d8:	f0 92 a3 00 	sts	0x00A3, r15
    28dc:	e0 92 a2 00 	sts	0x00A2, r14
				  event = 0;
    28e0:	10 92 9d 00 	sts	0x009D, r1
    28e4:	10 92 9c 00 	sts	0x009C, r1
				  all_bot_clear();
    28e8:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <all_bot_clear>
				  xbee_com = 1;
    28ec:	90 92 98 00 	sts	0x0098, r9
			  }
		  }
		  
	  }
	  if(cycle == 1)
    28f0:	80 91 a2 00 	lds	r24, 0x00A2
    28f4:	90 91 a3 00 	lds	r25, 0x00A3
    28f8:	81 30       	cpi	r24, 0x01	; 1
    28fa:	91 05       	cpc	r25, r1
    28fc:	09 f0       	breq	.+2      	; 0x2900 <main+0x15c>
    28fe:	d2 c0       	rjmp	.+420    	; 0x2aa4 <main+0x300>
	  {
		  if(event == 0)
    2900:	80 91 9c 00 	lds	r24, 0x009C
    2904:	90 91 9d 00 	lds	r25, 0x009D
    2908:	00 97       	sbiw	r24, 0x00	; 0
    290a:	19 f5       	brne	.+70     	; 0x2952 <main+0x1ae>
		  {
			  forward_mm(115);
    290c:	83 e7       	ldi	r24, 0x73	; 115
    290e:	90 e0       	ldi	r25, 0x00	; 0
    2910:	0e 94 5f 0b 	call	0x16be	; 0x16be <forward_mm>
			  stop();
    2914:	0e 94 b9 0a 	call	0x1572	; 0x1572 <stop>
			  
			  
			  if(sharp_check() == 1)
    2918:	0e 94 f7 11 	call	0x23ee	; 0x23ee <sharp_check>
    291c:	81 30       	cpi	r24, 0x01	; 1
    291e:	91 05       	cpc	r25, r1
    2920:	a1 f4       	brne	.+40     	; 0x294a <main+0x1a6>
			  {
				  event = 1;
    2922:	f0 92 9d 00 	sts	0x009D, r15
    2926:	e0 92 9c 00 	sts	0x009C, r14
				  forward_mm(40);
    292a:	88 e2       	ldi	r24, 0x28	; 40
    292c:	90 e0       	ldi	r25, 0x00	; 0
    292e:	0e 94 5f 0b 	call	0x16be	; 0x16be <forward_mm>
				  stop();
    2932:	0e 94 b9 0a 	call	0x1572	; 0x1572 <stop>
    2936:	8f ef       	ldi	r24, 0xFF	; 255
    2938:	9f e7       	ldi	r25, 0x7F	; 127
    293a:	a4 e0       	ldi	r26, 0x04	; 4
    293c:	81 50       	subi	r24, 0x01	; 1
    293e:	90 40       	sbci	r25, 0x00	; 0
    2940:	a0 40       	sbci	r26, 0x00	; 0
    2942:	e1 f7       	brne	.-8      	; 0x293c <main+0x198>
    2944:	00 c0       	rjmp	.+0      	; 0x2946 <main+0x1a2>
    2946:	00 00       	nop
    2948:	04 c0       	rjmp	.+8      	; 0x2952 <main+0x1ae>
				  _delay_ms(200);
				  
			  }
			  else
			  event = 2;
    294a:	d0 93 9d 00 	sts	0x009D, r29
    294e:	c0 93 9c 00 	sts	0x009C, r28
		  }
		  if(event == 1)
    2952:	80 91 9c 00 	lds	r24, 0x009C
    2956:	90 91 9d 00 	lds	r25, 0x009D
    295a:	81 30       	cpi	r24, 0x01	; 1
    295c:	91 05       	cpc	r25, r1
    295e:	09 f0       	breq	.+2      	; 0x2962 <main+0x1be>
    2960:	53 c0       	rjmp	.+166    	; 0x2a08 <main+0x264>
		  {
			  color_check();
    2962:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <color_check>
			  if(color_result == 0)
    2966:	80 91 19 01 	lds	r24, 0x0119
    296a:	90 91 1a 01 	lds	r25, 0x011A
    296e:	00 97       	sbiw	r24, 0x00	; 0
    2970:	81 f4       	brne	.+32     	; 0x2992 <main+0x1ee>
			  {
				  glow_red();
    2972:	0e 94 0c 11 	call	0x2218	; 0x2218 <glow_red>
				  feedOut();
    2976:	0e 94 9b 11 	call	0x2336	; 0x2336 <feedOut>
    297a:	8f ef       	ldi	r24, 0xFF	; 255
    297c:	9f ef       	ldi	r25, 0xFF	; 255
    297e:	ac e2       	ldi	r26, 0x2C	; 44
    2980:	81 50       	subi	r24, 0x01	; 1
    2982:	90 40       	sbci	r25, 0x00	; 0
    2984:	a0 40       	sbci	r26, 0x00	; 0
    2986:	e1 f7       	brne	.-8      	; 0x2980 <main+0x1dc>
    2988:	00 c0       	rjmp	.+0      	; 0x298a <main+0x1e6>
    298a:	00 00       	nop
				  _delay_ms(2000);
				  rgb_off();
    298c:	0e 94 1b 11 	call	0x2236	; 0x2236 <rgb_off>
    2990:	37 c0       	rjmp	.+110    	; 0x2a00 <main+0x25c>
			  }
			  else
			  {
				  if(color_result == 1)
    2992:	80 91 19 01 	lds	r24, 0x0119
    2996:	90 91 1a 01 	lds	r25, 0x011A
    299a:	81 30       	cpi	r24, 0x01	; 1
    299c:	91 05       	cpc	r25, r1
    299e:	a9 f4       	brne	.+42     	; 0x29ca <main+0x226>
				  {
					  glow_green();
    29a0:	0e 94 11 11 	call	0x2222	; 0x2222 <glow_green>
					  xbee_seq_node_transfer(curr_pos, 1);
    29a4:	80 91 b4 00 	lds	r24, 0x00B4
    29a8:	90 91 b5 00 	lds	r25, 0x00B5
    29ac:	b7 01       	movw	r22, r14
    29ae:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <xbee_seq_node_transfer>
    29b2:	8f ef       	ldi	r24, 0xFF	; 255
    29b4:	9f ef       	ldi	r25, 0xFF	; 255
    29b6:	ac e2       	ldi	r26, 0x2C	; 44
    29b8:	81 50       	subi	r24, 0x01	; 1
    29ba:	90 40       	sbci	r25, 0x00	; 0
    29bc:	a0 40       	sbci	r26, 0x00	; 0
    29be:	e1 f7       	brne	.-8      	; 0x29b8 <main+0x214>
    29c0:	00 c0       	rjmp	.+0      	; 0x29c2 <main+0x21e>
    29c2:	00 00       	nop
					  _delay_ms(2000);
					  rgb_off();
    29c4:	0e 94 1b 11 	call	0x2236	; 0x2236 <rgb_off>
    29c8:	1b c0       	rjmp	.+54     	; 0x2a00 <main+0x25c>
				  }
				  else if(color_result == 2)
    29ca:	80 91 19 01 	lds	r24, 0x0119
    29ce:	90 91 1a 01 	lds	r25, 0x011A
    29d2:	82 30       	cpi	r24, 0x02	; 2
    29d4:	91 05       	cpc	r25, r1
    29d6:	a1 f4       	brne	.+40     	; 0x2a00 <main+0x25c>
				  {
					  glow_blue();
    29d8:	0e 94 16 11 	call	0x222c	; 0x222c <glow_blue>
					  xbee_seq_node_transfer(curr_pos, 2);
    29dc:	80 91 b4 00 	lds	r24, 0x00B4
    29e0:	90 91 b5 00 	lds	r25, 0x00B5
    29e4:	be 01       	movw	r22, r28
    29e6:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <xbee_seq_node_transfer>
    29ea:	8f ef       	ldi	r24, 0xFF	; 255
    29ec:	9f ef       	ldi	r25, 0xFF	; 255
    29ee:	ac e2       	ldi	r26, 0x2C	; 44
    29f0:	81 50       	subi	r24, 0x01	; 1
    29f2:	90 40       	sbci	r25, 0x00	; 0
    29f4:	a0 40       	sbci	r26, 0x00	; 0
    29f6:	e1 f7       	brne	.-8      	; 0x29f0 <main+0x24c>
    29f8:	00 c0       	rjmp	.+0      	; 0x29fa <main+0x256>
    29fa:	00 00       	nop
					  _delay_ms(2000);
					  rgb_off();
    29fc:	0e 94 1b 11 	call	0x2236	; 0x2236 <rgb_off>
				  }
			  }
			  event = 2;
    2a00:	d0 93 9d 00 	sts	0x009D, r29
    2a04:	c0 93 9c 00 	sts	0x009C, r28
		  }
		  if(event == 2)
    2a08:	80 91 9c 00 	lds	r24, 0x009C
    2a0c:	90 91 9d 00 	lds	r25, 0x009D
    2a10:	82 30       	cpi	r24, 0x02	; 2
    2a12:	91 05       	cpc	r25, r1
    2a14:	11 f4       	brne	.+4      	; 0x2a1a <main+0x276>
		  {
			  line_follow_set0();
    2a16:	0e 94 90 12 	call	0x2520	; 0x2520 <line_follow_set0>
		  }
		  if(event == 3)
    2a1a:	80 91 9c 00 	lds	r24, 0x009C
    2a1e:	90 91 9d 00 	lds	r25, 0x009D
    2a22:	83 30       	cpi	r24, 0x03	; 3
    2a24:	91 05       	cpc	r25, r1
    2a26:	09 f0       	breq	.+2      	; 0x2a2a <main+0x286>
    2a28:	17 cf       	rjmp	.-466    	; 0x2858 <main+0xb4>
		  {
			  xbee_com = 1;
    2a2a:	90 92 98 00 	sts	0x0098, r9
			  set_cover = 50;
    2a2e:	10 93 9f 00 	sts	0x009F, r17
    2a32:	00 93 9e 00 	sts	0x009E, r16
			  if(all_bot_ready()==1)
    2a36:	0e 94 70 12 	call	0x24e0	; 0x24e0 <all_bot_ready>
    2a3a:	81 30       	cpi	r24, 0x01	; 1
    2a3c:	91 05       	cpc	r25, r1
    2a3e:	09 f0       	breq	.+2      	; 0x2a42 <main+0x29e>
    2a40:	0b cf       	rjmp	.-490    	; 0x2858 <main+0xb4>
			  {
				  all_bot_clear();
    2a42:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <all_bot_clear>
				  cycle = 2;
    2a46:	d0 93 a3 00 	sts	0x00A3, r29
    2a4a:	c0 93 a2 00 	sts	0x00A2, r28
				  navigate_0();
    2a4e:	0e 94 54 06 	call	0xca8	; 0xca8 <navigate_0>
				  stop();
    2a52:	0e 94 b9 0a 	call	0x1572	; 0x1572 <stop>
				  UDR = 0x40;
    2a56:	90 e4       	ldi	r25, 0x40	; 64
    2a58:	9c b9       	out	0x0c, r25	; 12
    2a5a:	8f ef       	ldi	r24, 0xFF	; 255
    2a5c:	9f e3       	ldi	r25, 0x3F	; 63
    2a5e:	a2 e0       	ldi	r26, 0x02	; 2
    2a60:	81 50       	subi	r24, 0x01	; 1
    2a62:	90 40       	sbci	r25, 0x00	; 0
    2a64:	a0 40       	sbci	r26, 0x00	; 0
    2a66:	e1 f7       	brne	.-8      	; 0x2a60 <main+0x2bc>
    2a68:	00 c0       	rjmp	.+0      	; 0x2a6a <main+0x2c6>
    2a6a:	00 00       	nop
				  _delay_ms(100);
				  UDR = 0x40;
    2a6c:	90 e4       	ldi	r25, 0x40	; 64
    2a6e:	9c b9       	out	0x0c, r25	; 12
    2a70:	8f ef       	ldi	r24, 0xFF	; 255
    2a72:	9f e3       	ldi	r25, 0x3F	; 63
    2a74:	a2 e0       	ldi	r26, 0x02	; 2
    2a76:	81 50       	subi	r24, 0x01	; 1
    2a78:	90 40       	sbci	r25, 0x00	; 0
    2a7a:	a0 40       	sbci	r26, 0x00	; 0
    2a7c:	e1 f7       	brne	.-8      	; 0x2a76 <main+0x2d2>
    2a7e:	00 c0       	rjmp	.+0      	; 0x2a80 <main+0x2dc>
    2a80:	00 00       	nop
				  _delay_ms(100);
				  UDR = 0x40;
    2a82:	90 e4       	ldi	r25, 0x40	; 64
    2a84:	9c b9       	out	0x0c, r25	; 12
				  home_bit[0] = 1;
    2a86:	d2 01       	movw	r26, r4
    2a88:	11 96       	adiw	r26, 0x01	; 1
    2a8a:	fc 92       	st	X, r15
    2a8c:	ee 92       	st	-X, r14
				  while(all_bot_ready() == 0);
    2a8e:	0e 94 70 12 	call	0x24e0	; 0x24e0 <all_bot_ready>
    2a92:	00 97       	sbiw	r24, 0x00	; 0
    2a94:	e1 f3       	breq	.-8      	; 0x2a8e <main+0x2ea>
				  all_bot_clear();
    2a96:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <all_bot_clear>
				  start_flag = 1;
    2a9a:	f0 92 18 01 	sts	0x0118, r15
    2a9e:	e0 92 17 01 	sts	0x0117, r14
    2aa2:	da ce       	rjmp	.-588    	; 0x2858 <main+0xb4>
			  }
		  }
	  }
	  else if(cycle == 2)
    2aa4:	80 91 a2 00 	lds	r24, 0x00A2
    2aa8:	90 91 a3 00 	lds	r25, 0x00A3
    2aac:	82 30       	cpi	r24, 0x02	; 2
    2aae:	91 05       	cpc	r25, r1
    2ab0:	09 f0       	breq	.+2      	; 0x2ab4 <main+0x310>
    2ab2:	e1 c0       	rjmp	.+450    	; 0x2c76 <main+0x4d2>
	  {
		  if(event==0)
    2ab4:	80 91 9c 00 	lds	r24, 0x009C
    2ab8:	90 91 9d 00 	lds	r25, 0x009D
    2abc:	00 97       	sbiw	r24, 0x00	; 0
    2abe:	09 f0       	breq	.+2      	; 0x2ac2 <main+0x31e>
    2ac0:	40 c0       	rjmp	.+128    	; 0x2b42 <main+0x39e>
		  {
			  if(set_cover==0)
    2ac2:	80 91 9e 00 	lds	r24, 0x009E
    2ac6:	90 91 9f 00 	lds	r25, 0x009F
    2aca:	00 97       	sbiw	r24, 0x00	; 0
    2acc:	c9 f4       	brne	.+50     	; 0x2b00 <main+0x35c>
			  {
				  if(right_plant_set1_count==0)line_follow_till_1(35);
    2ace:	80 91 94 00 	lds	r24, 0x0094
    2ad2:	90 91 95 00 	lds	r25, 0x0095
    2ad6:	00 97       	sbiw	r24, 0x00	; 0
    2ad8:	29 f4       	brne	.+10     	; 0x2ae4 <main+0x340>
    2ada:	83 e2       	ldi	r24, 0x23	; 35
    2adc:	90 e0       	ldi	r25, 0x00	; 0
    2ade:	0e 94 ac 08 	call	0x1158	; 0x1158 <line_follow_till_1>
    2ae2:	ba ce       	rjmp	.-652    	; 0x2858 <main+0xb4>
				  else
				  {
					  line_follow_till_1(right_plant_set1[array_index]);
    2ae4:	80 91 8c 00 	lds	r24, 0x008C
    2ae8:	90 91 8d 00 	lds	r25, 0x008D
    2aec:	88 0f       	add	r24, r24
    2aee:	99 1f       	adc	r25, r25
    2af0:	8c 0d       	add	r24, r12
    2af2:	9d 1d       	adc	r25, r13
    2af4:	fc 01       	movw	r30, r24
    2af6:	80 81       	ld	r24, Z
    2af8:	91 81       	ldd	r25, Z+1	; 0x01
    2afa:	0e 94 ac 08 	call	0x1158	; 0x1158 <line_follow_till_1>
    2afe:	ac ce       	rjmp	.-680    	; 0x2858 <main+0xb4>
				  }
				  
			  }
			  else if(set_cover==50)
    2b00:	80 91 9e 00 	lds	r24, 0x009E
    2b04:	90 91 9f 00 	lds	r25, 0x009F
    2b08:	82 33       	cpi	r24, 0x32	; 50
    2b0a:	91 05       	cpc	r25, r1
    2b0c:	09 f0       	breq	.+2      	; 0x2b10 <main+0x36c>
    2b0e:	a4 ce       	rjmp	.-696    	; 0x2858 <main+0xb4>
			  {
				  if(left_plant_set1_count==0)line_follow_till_1(41);
    2b10:	80 91 92 00 	lds	r24, 0x0092
    2b14:	90 91 93 00 	lds	r25, 0x0093
    2b18:	00 97       	sbiw	r24, 0x00	; 0
    2b1a:	29 f4       	brne	.+10     	; 0x2b26 <main+0x382>
    2b1c:	89 e2       	ldi	r24, 0x29	; 41
    2b1e:	90 e0       	ldi	r25, 0x00	; 0
    2b20:	0e 94 ac 08 	call	0x1158	; 0x1158 <line_follow_till_1>
    2b24:	99 ce       	rjmp	.-718    	; 0x2858 <main+0xb4>
				  else
				  {
					  line_follow_till_1(left_plant_set1[array_index]);
    2b26:	80 91 8c 00 	lds	r24, 0x008C
    2b2a:	90 91 8d 00 	lds	r25, 0x008D
    2b2e:	88 0f       	add	r24, r24
    2b30:	99 1f       	adc	r25, r25
    2b32:	86 0d       	add	r24, r6
    2b34:	97 1d       	adc	r25, r7
    2b36:	dc 01       	movw	r26, r24
    2b38:	8d 91       	ld	r24, X+
    2b3a:	9c 91       	ld	r25, X
    2b3c:	0e 94 ac 08 	call	0x1158	; 0x1158 <line_follow_till_1>
    2b40:	8b ce       	rjmp	.-746    	; 0x2858 <main+0xb4>
				  }
			  }
		  }
		  else if(event==1)
    2b42:	80 91 9c 00 	lds	r24, 0x009C
    2b46:	90 91 9d 00 	lds	r25, 0x009D
    2b4a:	81 30       	cpi	r24, 0x01	; 1
    2b4c:	91 05       	cpc	r25, r1
    2b4e:	f1 f5       	brne	.+124    	; 0x2bcc <main+0x428>
		  {
			  glow_red();
    2b50:	0e 94 0c 11 	call	0x2218	; 0x2218 <glow_red>
			  feedOut();
    2b54:	0e 94 9b 11 	call	0x2336	; 0x2336 <feedOut>
			  rgb_off();
    2b58:	0e 94 1b 11 	call	0x2236	; 0x2236 <rgb_off>
			  event=0;
    2b5c:	10 92 9d 00 	sts	0x009D, r1
    2b60:	10 92 9c 00 	sts	0x009C, r1
		      if(set_cover==0)                 {--right_plant_set1_count;  ++array_index; }
    2b64:	80 91 9e 00 	lds	r24, 0x009E
    2b68:	90 91 9f 00 	lds	r25, 0x009F
    2b6c:	00 97       	sbiw	r24, 0x00	; 0
    2b6e:	99 f4       	brne	.+38     	; 0x2b96 <main+0x3f2>
    2b70:	80 91 94 00 	lds	r24, 0x0094
    2b74:	90 91 95 00 	lds	r25, 0x0095
    2b78:	01 97       	sbiw	r24, 0x01	; 1
    2b7a:	90 93 95 00 	sts	0x0095, r25
    2b7e:	80 93 94 00 	sts	0x0094, r24
    2b82:	80 91 8c 00 	lds	r24, 0x008C
    2b86:	90 91 8d 00 	lds	r25, 0x008D
    2b8a:	01 96       	adiw	r24, 0x01	; 1
    2b8c:	90 93 8d 00 	sts	0x008D, r25
    2b90:	80 93 8c 00 	sts	0x008C, r24
    2b94:	61 ce       	rjmp	.-830    	; 0x2858 <main+0xb4>
	          else if(set_cover==50)           {--left_plant_set1_count;   ++array_index; }
    2b96:	80 91 9e 00 	lds	r24, 0x009E
    2b9a:	90 91 9f 00 	lds	r25, 0x009F
    2b9e:	82 33       	cpi	r24, 0x32	; 50
    2ba0:	91 05       	cpc	r25, r1
    2ba2:	09 f0       	breq	.+2      	; 0x2ba6 <main+0x402>
    2ba4:	59 ce       	rjmp	.-846    	; 0x2858 <main+0xb4>
    2ba6:	80 91 92 00 	lds	r24, 0x0092
    2baa:	90 91 93 00 	lds	r25, 0x0093
    2bae:	01 97       	sbiw	r24, 0x01	; 1
    2bb0:	90 93 93 00 	sts	0x0093, r25
    2bb4:	80 93 92 00 	sts	0x0092, r24
    2bb8:	80 91 8c 00 	lds	r24, 0x008C
    2bbc:	90 91 8d 00 	lds	r25, 0x008D
    2bc0:	01 96       	adiw	r24, 0x01	; 1
    2bc2:	90 93 8d 00 	sts	0x008D, r25
    2bc6:	80 93 8c 00 	sts	0x008C, r24
    2bca:	46 ce       	rjmp	.-884    	; 0x2858 <main+0xb4>
          }
  else if(event == 2)       // will wait for all bots to complete the whole set and hence start navigation to next step
    2bcc:	80 91 9c 00 	lds	r24, 0x009C
    2bd0:	90 91 9d 00 	lds	r25, 0x009D
    2bd4:	82 30       	cpi	r24, 0x02	; 2
    2bd6:	91 05       	cpc	r25, r1
    2bd8:	09 f0       	breq	.+2      	; 0x2bdc <main+0x438>
    2bda:	3e ce       	rjmp	.-900    	; 0x2858 <main+0xb4>
  {
	  if(all_bot_ready()==1)
    2bdc:	0e 94 70 12 	call	0x24e0	; 0x24e0 <all_bot_ready>
    2be0:	81 30       	cpi	r24, 0x01	; 1
    2be2:	91 05       	cpc	r25, r1
    2be4:	09 f0       	breq	.+2      	; 0x2be8 <main+0x444>
    2be6:	38 ce       	rjmp	.-912    	; 0x2858 <main+0xb4>
	  {
		  all_bot_clear();
    2be8:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <all_bot_clear>
		  navigate_1();
    2bec:	0e 94 66 05 	call	0xacc	; 0xacc <navigate_1>
		  ++set;
    2bf0:	80 91 a0 00 	lds	r24, 0x00A0
    2bf4:	90 91 a1 00 	lds	r25, 0x00A1
    2bf8:	01 96       	adiw	r24, 0x01	; 1
    2bfa:	90 93 a1 00 	sts	0x00A1, r25
    2bfe:	80 93 a0 00 	sts	0x00A0, r24
		  set_cover=0;
    2c02:	10 92 9f 00 	sts	0x009F, r1
    2c06:	10 92 9e 00 	sts	0x009E, r1
		  array_index=0;
    2c0a:	10 92 8d 00 	sts	0x008D, r1
    2c0e:	10 92 8c 00 	sts	0x008C, r1
		  event=0;
    2c12:	10 92 9d 00 	sts	0x009D, r1
    2c16:	10 92 9c 00 	sts	0x009C, r1
		  ++cycle;
    2c1a:	80 91 a2 00 	lds	r24, 0x00A2
    2c1e:	90 91 a3 00 	lds	r25, 0x00A3
    2c22:	01 96       	adiw	r24, 0x01	; 1
    2c24:	90 93 a3 00 	sts	0x00A3, r25
    2c28:	80 93 a2 00 	sts	0x00A2, r24
		  stop();
    2c2c:	0e 94 b9 0a 	call	0x1572	; 0x1572 <stop>
		  UDR = 0x40;
    2c30:	b0 e4       	ldi	r27, 0x40	; 64
    2c32:	bc b9       	out	0x0c, r27	; 12
    2c34:	8f ef       	ldi	r24, 0xFF	; 255
    2c36:	9f e3       	ldi	r25, 0x3F	; 63
    2c38:	a2 e0       	ldi	r26, 0x02	; 2
    2c3a:	81 50       	subi	r24, 0x01	; 1
    2c3c:	90 40       	sbci	r25, 0x00	; 0
    2c3e:	a0 40       	sbci	r26, 0x00	; 0
    2c40:	e1 f7       	brne	.-8      	; 0x2c3a <main+0x496>
    2c42:	00 c0       	rjmp	.+0      	; 0x2c44 <main+0x4a0>
    2c44:	00 00       	nop
		  _delay_ms(100);
		  UDR = 0x40;
    2c46:	90 e4       	ldi	r25, 0x40	; 64
    2c48:	9c b9       	out	0x0c, r25	; 12
    2c4a:	8f ef       	ldi	r24, 0xFF	; 255
    2c4c:	9f e3       	ldi	r25, 0x3F	; 63
    2c4e:	a2 e0       	ldi	r26, 0x02	; 2
    2c50:	81 50       	subi	r24, 0x01	; 1
    2c52:	90 40       	sbci	r25, 0x00	; 0
    2c54:	a0 40       	sbci	r26, 0x00	; 0
    2c56:	e1 f7       	brne	.-8      	; 0x2c50 <main+0x4ac>
    2c58:	00 c0       	rjmp	.+0      	; 0x2c5a <main+0x4b6>
    2c5a:	00 00       	nop
		  _delay_ms(100);
		  UDR = 0x40;
    2c5c:	90 e4       	ldi	r25, 0x40	; 64
    2c5e:	9c b9       	out	0x0c, r25	; 12
		  home_bit[0] = 1;
    2c60:	d2 01       	movw	r26, r4
    2c62:	11 96       	adiw	r26, 0x01	; 1
    2c64:	fc 92       	st	X, r15
    2c66:	ee 92       	st	-X, r14
		  while(all_bot_ready() == 0);
    2c68:	0e 94 70 12 	call	0x24e0	; 0x24e0 <all_bot_ready>
    2c6c:	00 97       	sbiw	r24, 0x00	; 0
    2c6e:	e1 f3       	breq	.-8      	; 0x2c68 <main+0x4c4>
		  all_bot_clear();
    2c70:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <all_bot_clear>
    2c74:	f1 cd       	rjmp	.-1054   	; 0x2858 <main+0xb4>
		  
	  }
  }
	   }
	  else if(cycle == 3)
    2c76:	80 91 a2 00 	lds	r24, 0x00A2
    2c7a:	90 91 a3 00 	lds	r25, 0x00A3
    2c7e:	83 30       	cpi	r24, 0x03	; 3
    2c80:	91 05       	cpc	r25, r1
    2c82:	09 f0       	breq	.+2      	; 0x2c86 <main+0x4e2>
    2c84:	bb c0       	rjmp	.+374    	; 0x2dfc <main+0x658>
	  {
		  
		  if(event==0)
    2c86:	80 91 9c 00 	lds	r24, 0x009C
    2c8a:	90 91 9d 00 	lds	r25, 0x009D
    2c8e:	00 97       	sbiw	r24, 0x00	; 0
    2c90:	09 f0       	breq	.+2      	; 0x2c94 <main+0x4f0>
    2c92:	40 c0       	rjmp	.+128    	; 0x2d14 <main+0x570>
		  {
			  if(set_cover==0)
    2c94:	80 91 9e 00 	lds	r24, 0x009E
    2c98:	90 91 9f 00 	lds	r25, 0x009F
    2c9c:	00 97       	sbiw	r24, 0x00	; 0
    2c9e:	c9 f4       	brne	.+50     	; 0x2cd2 <main+0x52e>
			  {
				  if(right_plant_set2_count==0)line_follow_till_2(7);
    2ca0:	80 91 90 00 	lds	r24, 0x0090
    2ca4:	90 91 91 00 	lds	r25, 0x0091
    2ca8:	00 97       	sbiw	r24, 0x00	; 0
    2caa:	29 f4       	brne	.+10     	; 0x2cb6 <main+0x512>
    2cac:	87 e0       	ldi	r24, 0x07	; 7
    2cae:	90 e0       	ldi	r25, 0x00	; 0
    2cb0:	0e 94 3d 07 	call	0xe7a	; 0xe7a <line_follow_till_2>
    2cb4:	d1 cd       	rjmp	.-1118   	; 0x2858 <main+0xb4>
				  else
				  {
					  line_follow_till_2(right_plant_set2[array_index]);
    2cb6:	80 91 8c 00 	lds	r24, 0x008C
    2cba:	90 91 8d 00 	lds	r25, 0x008D
    2cbe:	88 0f       	add	r24, r24
    2cc0:	99 1f       	adc	r25, r25
    2cc2:	8a 0d       	add	r24, r10
    2cc4:	9b 1d       	adc	r25, r11
    2cc6:	fc 01       	movw	r30, r24
    2cc8:	80 81       	ld	r24, Z
    2cca:	91 81       	ldd	r25, Z+1	; 0x01
    2ccc:	0e 94 3d 07 	call	0xe7a	; 0xe7a <line_follow_till_2>
    2cd0:	c3 cd       	rjmp	.-1146   	; 0x2858 <main+0xb4>
				  }
				  
			  }
			  else if(set_cover==50)
    2cd2:	80 91 9e 00 	lds	r24, 0x009E
    2cd6:	90 91 9f 00 	lds	r25, 0x009F
    2cda:	82 33       	cpi	r24, 0x32	; 50
    2cdc:	91 05       	cpc	r25, r1
    2cde:	09 f0       	breq	.+2      	; 0x2ce2 <main+0x53e>
    2ce0:	bb cd       	rjmp	.-1162   	; 0x2858 <main+0xb4>
			  {
				  if(left_plant_set2_count==0)line_follow_till_2(13);
    2ce2:	80 91 8e 00 	lds	r24, 0x008E
    2ce6:	90 91 8f 00 	lds	r25, 0x008F
    2cea:	00 97       	sbiw	r24, 0x00	; 0
    2cec:	29 f4       	brne	.+10     	; 0x2cf8 <main+0x554>
    2cee:	8d e0       	ldi	r24, 0x0D	; 13
    2cf0:	90 e0       	ldi	r25, 0x00	; 0
    2cf2:	0e 94 3d 07 	call	0xe7a	; 0xe7a <line_follow_till_2>
    2cf6:	b0 cd       	rjmp	.-1184   	; 0x2858 <main+0xb4>
				  else
				  {
					  line_follow_till_2(left_plant_set2[array_index]);
    2cf8:	80 91 8c 00 	lds	r24, 0x008C
    2cfc:	90 91 8d 00 	lds	r25, 0x008D
    2d00:	88 0f       	add	r24, r24
    2d02:	99 1f       	adc	r25, r25
    2d04:	82 0d       	add	r24, r2
    2d06:	93 1d       	adc	r25, r3
    2d08:	dc 01       	movw	r26, r24
    2d0a:	8d 91       	ld	r24, X+
    2d0c:	9c 91       	ld	r25, X
    2d0e:	0e 94 3d 07 	call	0xe7a	; 0xe7a <line_follow_till_2>
    2d12:	a2 cd       	rjmp	.-1212   	; 0x2858 <main+0xb4>
				  }
			  }
		  }
		  else if(event==1)
    2d14:	80 91 9c 00 	lds	r24, 0x009C
    2d18:	90 91 9d 00 	lds	r25, 0x009D
    2d1c:	81 30       	cpi	r24, 0x01	; 1
    2d1e:	91 05       	cpc	r25, r1
    2d20:	f1 f5       	brne	.+124    	; 0x2d9e <main+0x5fa>
		  {
			  glow_red();
    2d22:	0e 94 0c 11 	call	0x2218	; 0x2218 <glow_red>
			  feedOut();
    2d26:	0e 94 9b 11 	call	0x2336	; 0x2336 <feedOut>
			  rgb_off();
    2d2a:	0e 94 1b 11 	call	0x2236	; 0x2236 <rgb_off>
			  event=0;
    2d2e:	10 92 9d 00 	sts	0x009D, r1
    2d32:	10 92 9c 00 	sts	0x009C, r1
		      if(set_cover==0)                 {--right_plant_set2_count;  ++array_index; }
    2d36:	80 91 9e 00 	lds	r24, 0x009E
    2d3a:	90 91 9f 00 	lds	r25, 0x009F
    2d3e:	00 97       	sbiw	r24, 0x00	; 0
    2d40:	99 f4       	brne	.+38     	; 0x2d68 <main+0x5c4>
    2d42:	80 91 90 00 	lds	r24, 0x0090
    2d46:	90 91 91 00 	lds	r25, 0x0091
    2d4a:	01 97       	sbiw	r24, 0x01	; 1
    2d4c:	90 93 91 00 	sts	0x0091, r25
    2d50:	80 93 90 00 	sts	0x0090, r24
    2d54:	80 91 8c 00 	lds	r24, 0x008C
    2d58:	90 91 8d 00 	lds	r25, 0x008D
    2d5c:	01 96       	adiw	r24, 0x01	; 1
    2d5e:	90 93 8d 00 	sts	0x008D, r25
    2d62:	80 93 8c 00 	sts	0x008C, r24
    2d66:	78 cd       	rjmp	.-1296   	; 0x2858 <main+0xb4>
	          else if(set_cover==50)           {--left_plant_set2_count;   ++array_index; }
    2d68:	80 91 9e 00 	lds	r24, 0x009E
    2d6c:	90 91 9f 00 	lds	r25, 0x009F
    2d70:	82 33       	cpi	r24, 0x32	; 50
    2d72:	91 05       	cpc	r25, r1
    2d74:	09 f0       	breq	.+2      	; 0x2d78 <main+0x5d4>
    2d76:	70 cd       	rjmp	.-1312   	; 0x2858 <main+0xb4>
    2d78:	80 91 8e 00 	lds	r24, 0x008E
    2d7c:	90 91 8f 00 	lds	r25, 0x008F
    2d80:	01 97       	sbiw	r24, 0x01	; 1
    2d82:	90 93 8f 00 	sts	0x008F, r25
    2d86:	80 93 8e 00 	sts	0x008E, r24
    2d8a:	80 91 8c 00 	lds	r24, 0x008C
    2d8e:	90 91 8d 00 	lds	r25, 0x008D
    2d92:	01 96       	adiw	r24, 0x01	; 1
    2d94:	90 93 8d 00 	sts	0x008D, r25
    2d98:	80 93 8c 00 	sts	0x008C, r24
    2d9c:	5d cd       	rjmp	.-1350   	; 0x2858 <main+0xb4>
          }
  else if(event==2)
    2d9e:	80 91 9c 00 	lds	r24, 0x009C
    2da2:	90 91 9d 00 	lds	r25, 0x009D
    2da6:	82 30       	cpi	r24, 0x02	; 2
    2da8:	91 05       	cpc	r25, r1
    2daa:	09 f0       	breq	.+2      	; 0x2dae <main+0x60a>
    2dac:	55 cd       	rjmp	.-1366   	; 0x2858 <main+0xb4>
  {
	  if(all_bot_ready()==1)
    2dae:	0e 94 70 12 	call	0x24e0	; 0x24e0 <all_bot_ready>
    2db2:	81 30       	cpi	r24, 0x01	; 1
    2db4:	91 05       	cpc	r25, r1
    2db6:	09 f0       	breq	.+2      	; 0x2dba <main+0x616>
    2db8:	4f cd       	rjmp	.-1378   	; 0x2858 <main+0xb4>
	  {
		  all_bot_clear();
    2dba:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <all_bot_clear>
		  ++set;
    2dbe:	80 91 a0 00 	lds	r24, 0x00A0
    2dc2:	90 91 a1 00 	lds	r25, 0x00A1
    2dc6:	01 96       	adiw	r24, 0x01	; 1
    2dc8:	90 93 a1 00 	sts	0x00A1, r25
    2dcc:	80 93 a0 00 	sts	0x00A0, r24
		  set_cover=0;
    2dd0:	10 92 9f 00 	sts	0x009F, r1
    2dd4:	10 92 9e 00 	sts	0x009E, r1
		  array_index=0;
    2dd8:	10 92 8d 00 	sts	0x008D, r1
    2ddc:	10 92 8c 00 	sts	0x008C, r1
		  event=0;
    2de0:	10 92 9d 00 	sts	0x009D, r1
    2de4:	10 92 9c 00 	sts	0x009C, r1
		  ++cycle;
    2de8:	80 91 a2 00 	lds	r24, 0x00A2
    2dec:	90 91 a3 00 	lds	r25, 0x00A3
    2df0:	01 96       	adiw	r24, 0x01	; 1
    2df2:	90 93 a3 00 	sts	0x00A3, r25
    2df6:	80 93 a2 00 	sts	0x00A2, r24
    2dfa:	2e cd       	rjmp	.-1444   	; 0x2858 <main+0xb4>
	  }
  }
	   }
	   else if(cycle==4)   // final home run begins
    2dfc:	80 91 a2 00 	lds	r24, 0x00A2
    2e00:	90 91 a3 00 	lds	r25, 0x00A3
    2e04:	84 30       	cpi	r24, 0x04	; 4
    2e06:	91 05       	cpc	r25, r1
    2e08:	61 f4       	brne	.+24     	; 0x2e22 <main+0x67e>
	   {
		   final_home_run();
    2e0a:	0e 94 a1 04 	call	0x942	; 0x942 <final_home_run>
		   ++cycle;
    2e0e:	80 91 a2 00 	lds	r24, 0x00A2
    2e12:	90 91 a3 00 	lds	r25, 0x00A3
    2e16:	01 96       	adiw	r24, 0x01	; 1
    2e18:	90 93 a3 00 	sts	0x00A3, r25
    2e1c:	80 93 a2 00 	sts	0x00A2, r24
    2e20:	1b cd       	rjmp	.-1482   	; 0x2858 <main+0xb4>
	   }
	   else if(cycle==5)  // come out of event loop
    2e22:	80 91 a2 00 	lds	r24, 0x00A2
    2e26:	90 91 a3 00 	lds	r25, 0x00A3
    2e2a:	85 30       	cpi	r24, 0x05	; 5
    2e2c:	91 05       	cpc	r25, r1
    2e2e:	09 f0       	breq	.+2      	; 0x2e32 <main+0x68e>
    2e30:	13 cd       	rjmp	.-1498   	; 0x2858 <main+0xb4>
	   {
		   buzzer_on();
    2e32:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <buzzer_on>
    2e36:	8f ef       	ldi	r24, 0xFF	; 255
    2e38:	9f ef       	ldi	r25, 0xFF	; 255
    2e3a:	a6 e8       	ldi	r26, 0x86	; 134
    2e3c:	81 50       	subi	r24, 0x01	; 1
    2e3e:	90 40       	sbci	r25, 0x00	; 0
    2e40:	a0 40       	sbci	r26, 0x00	; 0
    2e42:	e1 f7       	brne	.-8      	; 0x2e3c <main+0x698>
    2e44:	00 c0       	rjmp	.+0      	; 0x2e46 <main+0x6a2>
    2e46:	00 00       	nop
		   _delay_ms(6000);
		    buzzer_off();
    2e48:	0e 94 fe 01 	call	0x3fc	; 0x3fc <buzzer_off>
		   break;
	   }
  }	
    2e4c:	df 91       	pop	r29
    2e4e:	cf 91       	pop	r28
    2e50:	1f 91       	pop	r17
    2e52:	0f 91       	pop	r16
    2e54:	ff 90       	pop	r15
    2e56:	ef 90       	pop	r14
    2e58:	df 90       	pop	r13
    2e5a:	cf 90       	pop	r12
    2e5c:	bf 90       	pop	r11
    2e5e:	af 90       	pop	r10
    2e60:	9f 90       	pop	r9
    2e62:	8f 90       	pop	r8
    2e64:	7f 90       	pop	r7
    2e66:	6f 90       	pop	r6
    2e68:	5f 90       	pop	r5
    2e6a:	4f 90       	pop	r4
    2e6c:	3f 90       	pop	r3
    2e6e:	2f 90       	pop	r2
    2e70:	08 95       	ret

00002e72 <__subsf3>:
    2e72:	50 58       	subi	r21, 0x80	; 128

00002e74 <__addsf3>:
    2e74:	bb 27       	eor	r27, r27
    2e76:	aa 27       	eor	r26, r26
    2e78:	0e d0       	rcall	.+28     	; 0x2e96 <__addsf3x>
    2e7a:	4d c1       	rjmp	.+666    	; 0x3116 <__fp_round>
    2e7c:	3e d1       	rcall	.+636    	; 0x30fa <__fp_pscA>
    2e7e:	30 f0       	brcs	.+12     	; 0x2e8c <__addsf3+0x18>
    2e80:	43 d1       	rcall	.+646    	; 0x3108 <__fp_pscB>
    2e82:	20 f0       	brcs	.+8      	; 0x2e8c <__addsf3+0x18>
    2e84:	31 f4       	brne	.+12     	; 0x2e92 <__addsf3+0x1e>
    2e86:	9f 3f       	cpi	r25, 0xFF	; 255
    2e88:	11 f4       	brne	.+4      	; 0x2e8e <__addsf3+0x1a>
    2e8a:	1e f4       	brtc	.+6      	; 0x2e92 <__addsf3+0x1e>
    2e8c:	33 c1       	rjmp	.+614    	; 0x30f4 <__fp_nan>
    2e8e:	0e f4       	brtc	.+2      	; 0x2e92 <__addsf3+0x1e>
    2e90:	e0 95       	com	r30
    2e92:	e7 fb       	bst	r30, 7
    2e94:	29 c1       	rjmp	.+594    	; 0x30e8 <__fp_inf>

00002e96 <__addsf3x>:
    2e96:	e9 2f       	mov	r30, r25
    2e98:	4f d1       	rcall	.+670    	; 0x3138 <__fp_split3>
    2e9a:	80 f3       	brcs	.-32     	; 0x2e7c <__addsf3+0x8>
    2e9c:	ba 17       	cp	r27, r26
    2e9e:	62 07       	cpc	r22, r18
    2ea0:	73 07       	cpc	r23, r19
    2ea2:	84 07       	cpc	r24, r20
    2ea4:	95 07       	cpc	r25, r21
    2ea6:	18 f0       	brcs	.+6      	; 0x2eae <__addsf3x+0x18>
    2ea8:	71 f4       	brne	.+28     	; 0x2ec6 <__addsf3x+0x30>
    2eaa:	9e f5       	brtc	.+102    	; 0x2f12 <__addsf3x+0x7c>
    2eac:	67 c1       	rjmp	.+718    	; 0x317c <__fp_zero>
    2eae:	0e f4       	brtc	.+2      	; 0x2eb2 <__addsf3x+0x1c>
    2eb0:	e0 95       	com	r30
    2eb2:	0b 2e       	mov	r0, r27
    2eb4:	ba 2f       	mov	r27, r26
    2eb6:	a0 2d       	mov	r26, r0
    2eb8:	0b 01       	movw	r0, r22
    2eba:	b9 01       	movw	r22, r18
    2ebc:	90 01       	movw	r18, r0
    2ebe:	0c 01       	movw	r0, r24
    2ec0:	ca 01       	movw	r24, r20
    2ec2:	a0 01       	movw	r20, r0
    2ec4:	11 24       	eor	r1, r1
    2ec6:	ff 27       	eor	r31, r31
    2ec8:	59 1b       	sub	r21, r25
    2eca:	99 f0       	breq	.+38     	; 0x2ef2 <__addsf3x+0x5c>
    2ecc:	59 3f       	cpi	r21, 0xF9	; 249
    2ece:	50 f4       	brcc	.+20     	; 0x2ee4 <__addsf3x+0x4e>
    2ed0:	50 3e       	cpi	r21, 0xE0	; 224
    2ed2:	68 f1       	brcs	.+90     	; 0x2f2e <__addsf3x+0x98>
    2ed4:	1a 16       	cp	r1, r26
    2ed6:	f0 40       	sbci	r31, 0x00	; 0
    2ed8:	a2 2f       	mov	r26, r18
    2eda:	23 2f       	mov	r18, r19
    2edc:	34 2f       	mov	r19, r20
    2ede:	44 27       	eor	r20, r20
    2ee0:	58 5f       	subi	r21, 0xF8	; 248
    2ee2:	f3 cf       	rjmp	.-26     	; 0x2eca <__addsf3x+0x34>
    2ee4:	46 95       	lsr	r20
    2ee6:	37 95       	ror	r19
    2ee8:	27 95       	ror	r18
    2eea:	a7 95       	ror	r26
    2eec:	f0 40       	sbci	r31, 0x00	; 0
    2eee:	53 95       	inc	r21
    2ef0:	c9 f7       	brne	.-14     	; 0x2ee4 <__addsf3x+0x4e>
    2ef2:	7e f4       	brtc	.+30     	; 0x2f12 <__addsf3x+0x7c>
    2ef4:	1f 16       	cp	r1, r31
    2ef6:	ba 0b       	sbc	r27, r26
    2ef8:	62 0b       	sbc	r22, r18
    2efa:	73 0b       	sbc	r23, r19
    2efc:	84 0b       	sbc	r24, r20
    2efe:	ba f0       	brmi	.+46     	; 0x2f2e <__addsf3x+0x98>
    2f00:	91 50       	subi	r25, 0x01	; 1
    2f02:	a1 f0       	breq	.+40     	; 0x2f2c <__addsf3x+0x96>
    2f04:	ff 0f       	add	r31, r31
    2f06:	bb 1f       	adc	r27, r27
    2f08:	66 1f       	adc	r22, r22
    2f0a:	77 1f       	adc	r23, r23
    2f0c:	88 1f       	adc	r24, r24
    2f0e:	c2 f7       	brpl	.-16     	; 0x2f00 <__addsf3x+0x6a>
    2f10:	0e c0       	rjmp	.+28     	; 0x2f2e <__addsf3x+0x98>
    2f12:	ba 0f       	add	r27, r26
    2f14:	62 1f       	adc	r22, r18
    2f16:	73 1f       	adc	r23, r19
    2f18:	84 1f       	adc	r24, r20
    2f1a:	48 f4       	brcc	.+18     	; 0x2f2e <__addsf3x+0x98>
    2f1c:	87 95       	ror	r24
    2f1e:	77 95       	ror	r23
    2f20:	67 95       	ror	r22
    2f22:	b7 95       	ror	r27
    2f24:	f7 95       	ror	r31
    2f26:	9e 3f       	cpi	r25, 0xFE	; 254
    2f28:	08 f0       	brcs	.+2      	; 0x2f2c <__addsf3x+0x96>
    2f2a:	b3 cf       	rjmp	.-154    	; 0x2e92 <__addsf3+0x1e>
    2f2c:	93 95       	inc	r25
    2f2e:	88 0f       	add	r24, r24
    2f30:	08 f0       	brcs	.+2      	; 0x2f34 <__addsf3x+0x9e>
    2f32:	99 27       	eor	r25, r25
    2f34:	ee 0f       	add	r30, r30
    2f36:	97 95       	ror	r25
    2f38:	87 95       	ror	r24
    2f3a:	08 95       	ret

00002f3c <__divsf3>:
    2f3c:	0c d0       	rcall	.+24     	; 0x2f56 <__divsf3x>
    2f3e:	eb c0       	rjmp	.+470    	; 0x3116 <__fp_round>
    2f40:	e3 d0       	rcall	.+454    	; 0x3108 <__fp_pscB>
    2f42:	40 f0       	brcs	.+16     	; 0x2f54 <__divsf3+0x18>
    2f44:	da d0       	rcall	.+436    	; 0x30fa <__fp_pscA>
    2f46:	30 f0       	brcs	.+12     	; 0x2f54 <__divsf3+0x18>
    2f48:	21 f4       	brne	.+8      	; 0x2f52 <__divsf3+0x16>
    2f4a:	5f 3f       	cpi	r21, 0xFF	; 255
    2f4c:	19 f0       	breq	.+6      	; 0x2f54 <__divsf3+0x18>
    2f4e:	cc c0       	rjmp	.+408    	; 0x30e8 <__fp_inf>
    2f50:	51 11       	cpse	r21, r1
    2f52:	15 c1       	rjmp	.+554    	; 0x317e <__fp_szero>
    2f54:	cf c0       	rjmp	.+414    	; 0x30f4 <__fp_nan>

00002f56 <__divsf3x>:
    2f56:	f0 d0       	rcall	.+480    	; 0x3138 <__fp_split3>
    2f58:	98 f3       	brcs	.-26     	; 0x2f40 <__divsf3+0x4>

00002f5a <__divsf3_pse>:
    2f5a:	99 23       	and	r25, r25
    2f5c:	c9 f3       	breq	.-14     	; 0x2f50 <__divsf3+0x14>
    2f5e:	55 23       	and	r21, r21
    2f60:	b1 f3       	breq	.-20     	; 0x2f4e <__divsf3+0x12>
    2f62:	95 1b       	sub	r25, r21
    2f64:	55 0b       	sbc	r21, r21
    2f66:	bb 27       	eor	r27, r27
    2f68:	aa 27       	eor	r26, r26
    2f6a:	62 17       	cp	r22, r18
    2f6c:	73 07       	cpc	r23, r19
    2f6e:	84 07       	cpc	r24, r20
    2f70:	38 f0       	brcs	.+14     	; 0x2f80 <__divsf3_pse+0x26>
    2f72:	9f 5f       	subi	r25, 0xFF	; 255
    2f74:	5f 4f       	sbci	r21, 0xFF	; 255
    2f76:	22 0f       	add	r18, r18
    2f78:	33 1f       	adc	r19, r19
    2f7a:	44 1f       	adc	r20, r20
    2f7c:	aa 1f       	adc	r26, r26
    2f7e:	a9 f3       	breq	.-22     	; 0x2f6a <__divsf3_pse+0x10>
    2f80:	33 d0       	rcall	.+102    	; 0x2fe8 <__divsf3_pse+0x8e>
    2f82:	0e 2e       	mov	r0, r30
    2f84:	3a f0       	brmi	.+14     	; 0x2f94 <__divsf3_pse+0x3a>
    2f86:	e0 e8       	ldi	r30, 0x80	; 128
    2f88:	30 d0       	rcall	.+96     	; 0x2fea <__divsf3_pse+0x90>
    2f8a:	91 50       	subi	r25, 0x01	; 1
    2f8c:	50 40       	sbci	r21, 0x00	; 0
    2f8e:	e6 95       	lsr	r30
    2f90:	00 1c       	adc	r0, r0
    2f92:	ca f7       	brpl	.-14     	; 0x2f86 <__divsf3_pse+0x2c>
    2f94:	29 d0       	rcall	.+82     	; 0x2fe8 <__divsf3_pse+0x8e>
    2f96:	fe 2f       	mov	r31, r30
    2f98:	27 d0       	rcall	.+78     	; 0x2fe8 <__divsf3_pse+0x8e>
    2f9a:	66 0f       	add	r22, r22
    2f9c:	77 1f       	adc	r23, r23
    2f9e:	88 1f       	adc	r24, r24
    2fa0:	bb 1f       	adc	r27, r27
    2fa2:	26 17       	cp	r18, r22
    2fa4:	37 07       	cpc	r19, r23
    2fa6:	48 07       	cpc	r20, r24
    2fa8:	ab 07       	cpc	r26, r27
    2faa:	b0 e8       	ldi	r27, 0x80	; 128
    2fac:	09 f0       	breq	.+2      	; 0x2fb0 <__divsf3_pse+0x56>
    2fae:	bb 0b       	sbc	r27, r27
    2fb0:	80 2d       	mov	r24, r0
    2fb2:	bf 01       	movw	r22, r30
    2fb4:	ff 27       	eor	r31, r31
    2fb6:	93 58       	subi	r25, 0x83	; 131
    2fb8:	5f 4f       	sbci	r21, 0xFF	; 255
    2fba:	2a f0       	brmi	.+10     	; 0x2fc6 <__divsf3_pse+0x6c>
    2fbc:	9e 3f       	cpi	r25, 0xFE	; 254
    2fbe:	51 05       	cpc	r21, r1
    2fc0:	68 f0       	brcs	.+26     	; 0x2fdc <__divsf3_pse+0x82>
    2fc2:	92 c0       	rjmp	.+292    	; 0x30e8 <__fp_inf>
    2fc4:	dc c0       	rjmp	.+440    	; 0x317e <__fp_szero>
    2fc6:	5f 3f       	cpi	r21, 0xFF	; 255
    2fc8:	ec f3       	brlt	.-6      	; 0x2fc4 <__divsf3_pse+0x6a>
    2fca:	98 3e       	cpi	r25, 0xE8	; 232
    2fcc:	dc f3       	brlt	.-10     	; 0x2fc4 <__divsf3_pse+0x6a>
    2fce:	86 95       	lsr	r24
    2fd0:	77 95       	ror	r23
    2fd2:	67 95       	ror	r22
    2fd4:	b7 95       	ror	r27
    2fd6:	f7 95       	ror	r31
    2fd8:	9f 5f       	subi	r25, 0xFF	; 255
    2fda:	c9 f7       	brne	.-14     	; 0x2fce <__divsf3_pse+0x74>
    2fdc:	88 0f       	add	r24, r24
    2fde:	91 1d       	adc	r25, r1
    2fe0:	96 95       	lsr	r25
    2fe2:	87 95       	ror	r24
    2fe4:	97 f9       	bld	r25, 7
    2fe6:	08 95       	ret
    2fe8:	e1 e0       	ldi	r30, 0x01	; 1
    2fea:	66 0f       	add	r22, r22
    2fec:	77 1f       	adc	r23, r23
    2fee:	88 1f       	adc	r24, r24
    2ff0:	bb 1f       	adc	r27, r27
    2ff2:	62 17       	cp	r22, r18
    2ff4:	73 07       	cpc	r23, r19
    2ff6:	84 07       	cpc	r24, r20
    2ff8:	ba 07       	cpc	r27, r26
    2ffa:	20 f0       	brcs	.+8      	; 0x3004 <__divsf3_pse+0xaa>
    2ffc:	62 1b       	sub	r22, r18
    2ffe:	73 0b       	sbc	r23, r19
    3000:	84 0b       	sbc	r24, r20
    3002:	ba 0b       	sbc	r27, r26
    3004:	ee 1f       	adc	r30, r30
    3006:	88 f7       	brcc	.-30     	; 0x2fea <__divsf3_pse+0x90>
    3008:	e0 95       	com	r30
    300a:	08 95       	ret

0000300c <__fixsfsi>:
    300c:	04 d0       	rcall	.+8      	; 0x3016 <__fixunssfsi>
    300e:	68 94       	set
    3010:	b1 11       	cpse	r27, r1
    3012:	b5 c0       	rjmp	.+362    	; 0x317e <__fp_szero>
    3014:	08 95       	ret

00003016 <__fixunssfsi>:
    3016:	98 d0       	rcall	.+304    	; 0x3148 <__fp_splitA>
    3018:	88 f0       	brcs	.+34     	; 0x303c <__fixunssfsi+0x26>
    301a:	9f 57       	subi	r25, 0x7F	; 127
    301c:	90 f0       	brcs	.+36     	; 0x3042 <__fixunssfsi+0x2c>
    301e:	b9 2f       	mov	r27, r25
    3020:	99 27       	eor	r25, r25
    3022:	b7 51       	subi	r27, 0x17	; 23
    3024:	a0 f0       	brcs	.+40     	; 0x304e <__fixunssfsi+0x38>
    3026:	d1 f0       	breq	.+52     	; 0x305c <__fixunssfsi+0x46>
    3028:	66 0f       	add	r22, r22
    302a:	77 1f       	adc	r23, r23
    302c:	88 1f       	adc	r24, r24
    302e:	99 1f       	adc	r25, r25
    3030:	1a f0       	brmi	.+6      	; 0x3038 <__fixunssfsi+0x22>
    3032:	ba 95       	dec	r27
    3034:	c9 f7       	brne	.-14     	; 0x3028 <__fixunssfsi+0x12>
    3036:	12 c0       	rjmp	.+36     	; 0x305c <__fixunssfsi+0x46>
    3038:	b1 30       	cpi	r27, 0x01	; 1
    303a:	81 f0       	breq	.+32     	; 0x305c <__fixunssfsi+0x46>
    303c:	9f d0       	rcall	.+318    	; 0x317c <__fp_zero>
    303e:	b1 e0       	ldi	r27, 0x01	; 1
    3040:	08 95       	ret
    3042:	9c c0       	rjmp	.+312    	; 0x317c <__fp_zero>
    3044:	67 2f       	mov	r22, r23
    3046:	78 2f       	mov	r23, r24
    3048:	88 27       	eor	r24, r24
    304a:	b8 5f       	subi	r27, 0xF8	; 248
    304c:	39 f0       	breq	.+14     	; 0x305c <__fixunssfsi+0x46>
    304e:	b9 3f       	cpi	r27, 0xF9	; 249
    3050:	cc f3       	brlt	.-14     	; 0x3044 <__fixunssfsi+0x2e>
    3052:	86 95       	lsr	r24
    3054:	77 95       	ror	r23
    3056:	67 95       	ror	r22
    3058:	b3 95       	inc	r27
    305a:	d9 f7       	brne	.-10     	; 0x3052 <__fixunssfsi+0x3c>
    305c:	3e f4       	brtc	.+14     	; 0x306c <__fixunssfsi+0x56>
    305e:	90 95       	com	r25
    3060:	80 95       	com	r24
    3062:	70 95       	com	r23
    3064:	61 95       	neg	r22
    3066:	7f 4f       	sbci	r23, 0xFF	; 255
    3068:	8f 4f       	sbci	r24, 0xFF	; 255
    306a:	9f 4f       	sbci	r25, 0xFF	; 255
    306c:	08 95       	ret

0000306e <__floatunsisf>:
    306e:	e8 94       	clt
    3070:	09 c0       	rjmp	.+18     	; 0x3084 <__floatsisf+0x12>

00003072 <__floatsisf>:
    3072:	97 fb       	bst	r25, 7
    3074:	3e f4       	brtc	.+14     	; 0x3084 <__floatsisf+0x12>
    3076:	90 95       	com	r25
    3078:	80 95       	com	r24
    307a:	70 95       	com	r23
    307c:	61 95       	neg	r22
    307e:	7f 4f       	sbci	r23, 0xFF	; 255
    3080:	8f 4f       	sbci	r24, 0xFF	; 255
    3082:	9f 4f       	sbci	r25, 0xFF	; 255
    3084:	99 23       	and	r25, r25
    3086:	a9 f0       	breq	.+42     	; 0x30b2 <__floatsisf+0x40>
    3088:	f9 2f       	mov	r31, r25
    308a:	96 e9       	ldi	r25, 0x96	; 150
    308c:	bb 27       	eor	r27, r27
    308e:	93 95       	inc	r25
    3090:	f6 95       	lsr	r31
    3092:	87 95       	ror	r24
    3094:	77 95       	ror	r23
    3096:	67 95       	ror	r22
    3098:	b7 95       	ror	r27
    309a:	f1 11       	cpse	r31, r1
    309c:	f8 cf       	rjmp	.-16     	; 0x308e <__floatsisf+0x1c>
    309e:	fa f4       	brpl	.+62     	; 0x30de <__floatsisf+0x6c>
    30a0:	bb 0f       	add	r27, r27
    30a2:	11 f4       	brne	.+4      	; 0x30a8 <__floatsisf+0x36>
    30a4:	60 ff       	sbrs	r22, 0
    30a6:	1b c0       	rjmp	.+54     	; 0x30de <__floatsisf+0x6c>
    30a8:	6f 5f       	subi	r22, 0xFF	; 255
    30aa:	7f 4f       	sbci	r23, 0xFF	; 255
    30ac:	8f 4f       	sbci	r24, 0xFF	; 255
    30ae:	9f 4f       	sbci	r25, 0xFF	; 255
    30b0:	16 c0       	rjmp	.+44     	; 0x30de <__floatsisf+0x6c>
    30b2:	88 23       	and	r24, r24
    30b4:	11 f0       	breq	.+4      	; 0x30ba <__floatsisf+0x48>
    30b6:	96 e9       	ldi	r25, 0x96	; 150
    30b8:	11 c0       	rjmp	.+34     	; 0x30dc <__floatsisf+0x6a>
    30ba:	77 23       	and	r23, r23
    30bc:	21 f0       	breq	.+8      	; 0x30c6 <__floatsisf+0x54>
    30be:	9e e8       	ldi	r25, 0x8E	; 142
    30c0:	87 2f       	mov	r24, r23
    30c2:	76 2f       	mov	r23, r22
    30c4:	05 c0       	rjmp	.+10     	; 0x30d0 <__floatsisf+0x5e>
    30c6:	66 23       	and	r22, r22
    30c8:	71 f0       	breq	.+28     	; 0x30e6 <__floatsisf+0x74>
    30ca:	96 e8       	ldi	r25, 0x86	; 134
    30cc:	86 2f       	mov	r24, r22
    30ce:	70 e0       	ldi	r23, 0x00	; 0
    30d0:	60 e0       	ldi	r22, 0x00	; 0
    30d2:	2a f0       	brmi	.+10     	; 0x30de <__floatsisf+0x6c>
    30d4:	9a 95       	dec	r25
    30d6:	66 0f       	add	r22, r22
    30d8:	77 1f       	adc	r23, r23
    30da:	88 1f       	adc	r24, r24
    30dc:	da f7       	brpl	.-10     	; 0x30d4 <__floatsisf+0x62>
    30de:	88 0f       	add	r24, r24
    30e0:	96 95       	lsr	r25
    30e2:	87 95       	ror	r24
    30e4:	97 f9       	bld	r25, 7
    30e6:	08 95       	ret

000030e8 <__fp_inf>:
    30e8:	97 f9       	bld	r25, 7
    30ea:	9f 67       	ori	r25, 0x7F	; 127
    30ec:	80 e8       	ldi	r24, 0x80	; 128
    30ee:	70 e0       	ldi	r23, 0x00	; 0
    30f0:	60 e0       	ldi	r22, 0x00	; 0
    30f2:	08 95       	ret

000030f4 <__fp_nan>:
    30f4:	9f ef       	ldi	r25, 0xFF	; 255
    30f6:	80 ec       	ldi	r24, 0xC0	; 192
    30f8:	08 95       	ret

000030fa <__fp_pscA>:
    30fa:	00 24       	eor	r0, r0
    30fc:	0a 94       	dec	r0
    30fe:	16 16       	cp	r1, r22
    3100:	17 06       	cpc	r1, r23
    3102:	18 06       	cpc	r1, r24
    3104:	09 06       	cpc	r0, r25
    3106:	08 95       	ret

00003108 <__fp_pscB>:
    3108:	00 24       	eor	r0, r0
    310a:	0a 94       	dec	r0
    310c:	12 16       	cp	r1, r18
    310e:	13 06       	cpc	r1, r19
    3110:	14 06       	cpc	r1, r20
    3112:	05 06       	cpc	r0, r21
    3114:	08 95       	ret

00003116 <__fp_round>:
    3116:	09 2e       	mov	r0, r25
    3118:	03 94       	inc	r0
    311a:	00 0c       	add	r0, r0
    311c:	11 f4       	brne	.+4      	; 0x3122 <__fp_round+0xc>
    311e:	88 23       	and	r24, r24
    3120:	52 f0       	brmi	.+20     	; 0x3136 <__fp_round+0x20>
    3122:	bb 0f       	add	r27, r27
    3124:	40 f4       	brcc	.+16     	; 0x3136 <__fp_round+0x20>
    3126:	bf 2b       	or	r27, r31
    3128:	11 f4       	brne	.+4      	; 0x312e <__fp_round+0x18>
    312a:	60 ff       	sbrs	r22, 0
    312c:	04 c0       	rjmp	.+8      	; 0x3136 <__fp_round+0x20>
    312e:	6f 5f       	subi	r22, 0xFF	; 255
    3130:	7f 4f       	sbci	r23, 0xFF	; 255
    3132:	8f 4f       	sbci	r24, 0xFF	; 255
    3134:	9f 4f       	sbci	r25, 0xFF	; 255
    3136:	08 95       	ret

00003138 <__fp_split3>:
    3138:	57 fd       	sbrc	r21, 7
    313a:	90 58       	subi	r25, 0x80	; 128
    313c:	44 0f       	add	r20, r20
    313e:	55 1f       	adc	r21, r21
    3140:	59 f0       	breq	.+22     	; 0x3158 <__fp_splitA+0x10>
    3142:	5f 3f       	cpi	r21, 0xFF	; 255
    3144:	71 f0       	breq	.+28     	; 0x3162 <__fp_splitA+0x1a>
    3146:	47 95       	ror	r20

00003148 <__fp_splitA>:
    3148:	88 0f       	add	r24, r24
    314a:	97 fb       	bst	r25, 7
    314c:	99 1f       	adc	r25, r25
    314e:	61 f0       	breq	.+24     	; 0x3168 <__fp_splitA+0x20>
    3150:	9f 3f       	cpi	r25, 0xFF	; 255
    3152:	79 f0       	breq	.+30     	; 0x3172 <__fp_splitA+0x2a>
    3154:	87 95       	ror	r24
    3156:	08 95       	ret
    3158:	12 16       	cp	r1, r18
    315a:	13 06       	cpc	r1, r19
    315c:	14 06       	cpc	r1, r20
    315e:	55 1f       	adc	r21, r21
    3160:	f2 cf       	rjmp	.-28     	; 0x3146 <__fp_split3+0xe>
    3162:	46 95       	lsr	r20
    3164:	f1 df       	rcall	.-30     	; 0x3148 <__fp_splitA>
    3166:	08 c0       	rjmp	.+16     	; 0x3178 <__fp_splitA+0x30>
    3168:	16 16       	cp	r1, r22
    316a:	17 06       	cpc	r1, r23
    316c:	18 06       	cpc	r1, r24
    316e:	99 1f       	adc	r25, r25
    3170:	f1 cf       	rjmp	.-30     	; 0x3154 <__fp_splitA+0xc>
    3172:	86 95       	lsr	r24
    3174:	71 05       	cpc	r23, r1
    3176:	61 05       	cpc	r22, r1
    3178:	08 94       	sec
    317a:	08 95       	ret

0000317c <__fp_zero>:
    317c:	e8 94       	clt

0000317e <__fp_szero>:
    317e:	bb 27       	eor	r27, r27
    3180:	66 27       	eor	r22, r22
    3182:	77 27       	eor	r23, r23
    3184:	cb 01       	movw	r24, r22
    3186:	97 f9       	bld	r25, 7
    3188:	08 95       	ret

0000318a <__mulsf3>:
    318a:	0b d0       	rcall	.+22     	; 0x31a2 <__mulsf3x>
    318c:	c4 cf       	rjmp	.-120    	; 0x3116 <__fp_round>
    318e:	b5 df       	rcall	.-150    	; 0x30fa <__fp_pscA>
    3190:	28 f0       	brcs	.+10     	; 0x319c <__mulsf3+0x12>
    3192:	ba df       	rcall	.-140    	; 0x3108 <__fp_pscB>
    3194:	18 f0       	brcs	.+6      	; 0x319c <__mulsf3+0x12>
    3196:	95 23       	and	r25, r21
    3198:	09 f0       	breq	.+2      	; 0x319c <__mulsf3+0x12>
    319a:	a6 cf       	rjmp	.-180    	; 0x30e8 <__fp_inf>
    319c:	ab cf       	rjmp	.-170    	; 0x30f4 <__fp_nan>
    319e:	11 24       	eor	r1, r1
    31a0:	ee cf       	rjmp	.-36     	; 0x317e <__fp_szero>

000031a2 <__mulsf3x>:
    31a2:	ca df       	rcall	.-108    	; 0x3138 <__fp_split3>
    31a4:	a0 f3       	brcs	.-24     	; 0x318e <__mulsf3+0x4>

000031a6 <__mulsf3_pse>:
    31a6:	95 9f       	mul	r25, r21
    31a8:	d1 f3       	breq	.-12     	; 0x319e <__mulsf3+0x14>
    31aa:	95 0f       	add	r25, r21
    31ac:	50 e0       	ldi	r21, 0x00	; 0
    31ae:	55 1f       	adc	r21, r21
    31b0:	62 9f       	mul	r22, r18
    31b2:	f0 01       	movw	r30, r0
    31b4:	72 9f       	mul	r23, r18
    31b6:	bb 27       	eor	r27, r27
    31b8:	f0 0d       	add	r31, r0
    31ba:	b1 1d       	adc	r27, r1
    31bc:	63 9f       	mul	r22, r19
    31be:	aa 27       	eor	r26, r26
    31c0:	f0 0d       	add	r31, r0
    31c2:	b1 1d       	adc	r27, r1
    31c4:	aa 1f       	adc	r26, r26
    31c6:	64 9f       	mul	r22, r20
    31c8:	66 27       	eor	r22, r22
    31ca:	b0 0d       	add	r27, r0
    31cc:	a1 1d       	adc	r26, r1
    31ce:	66 1f       	adc	r22, r22
    31d0:	82 9f       	mul	r24, r18
    31d2:	22 27       	eor	r18, r18
    31d4:	b0 0d       	add	r27, r0
    31d6:	a1 1d       	adc	r26, r1
    31d8:	62 1f       	adc	r22, r18
    31da:	73 9f       	mul	r23, r19
    31dc:	b0 0d       	add	r27, r0
    31de:	a1 1d       	adc	r26, r1
    31e0:	62 1f       	adc	r22, r18
    31e2:	83 9f       	mul	r24, r19
    31e4:	a0 0d       	add	r26, r0
    31e6:	61 1d       	adc	r22, r1
    31e8:	22 1f       	adc	r18, r18
    31ea:	74 9f       	mul	r23, r20
    31ec:	33 27       	eor	r19, r19
    31ee:	a0 0d       	add	r26, r0
    31f0:	61 1d       	adc	r22, r1
    31f2:	23 1f       	adc	r18, r19
    31f4:	84 9f       	mul	r24, r20
    31f6:	60 0d       	add	r22, r0
    31f8:	21 1d       	adc	r18, r1
    31fa:	82 2f       	mov	r24, r18
    31fc:	76 2f       	mov	r23, r22
    31fe:	6a 2f       	mov	r22, r26
    3200:	11 24       	eor	r1, r1
    3202:	9f 57       	subi	r25, 0x7F	; 127
    3204:	50 40       	sbci	r21, 0x00	; 0
    3206:	8a f0       	brmi	.+34     	; 0x322a <__mulsf3_pse+0x84>
    3208:	e1 f0       	breq	.+56     	; 0x3242 <__mulsf3_pse+0x9c>
    320a:	88 23       	and	r24, r24
    320c:	4a f0       	brmi	.+18     	; 0x3220 <__mulsf3_pse+0x7a>
    320e:	ee 0f       	add	r30, r30
    3210:	ff 1f       	adc	r31, r31
    3212:	bb 1f       	adc	r27, r27
    3214:	66 1f       	adc	r22, r22
    3216:	77 1f       	adc	r23, r23
    3218:	88 1f       	adc	r24, r24
    321a:	91 50       	subi	r25, 0x01	; 1
    321c:	50 40       	sbci	r21, 0x00	; 0
    321e:	a9 f7       	brne	.-22     	; 0x320a <__mulsf3_pse+0x64>
    3220:	9e 3f       	cpi	r25, 0xFE	; 254
    3222:	51 05       	cpc	r21, r1
    3224:	70 f0       	brcs	.+28     	; 0x3242 <__mulsf3_pse+0x9c>
    3226:	60 cf       	rjmp	.-320    	; 0x30e8 <__fp_inf>
    3228:	aa cf       	rjmp	.-172    	; 0x317e <__fp_szero>
    322a:	5f 3f       	cpi	r21, 0xFF	; 255
    322c:	ec f3       	brlt	.-6      	; 0x3228 <__mulsf3_pse+0x82>
    322e:	98 3e       	cpi	r25, 0xE8	; 232
    3230:	dc f3       	brlt	.-10     	; 0x3228 <__mulsf3_pse+0x82>
    3232:	86 95       	lsr	r24
    3234:	77 95       	ror	r23
    3236:	67 95       	ror	r22
    3238:	b7 95       	ror	r27
    323a:	f7 95       	ror	r31
    323c:	e7 95       	ror	r30
    323e:	9f 5f       	subi	r25, 0xFF	; 255
    3240:	c1 f7       	brne	.-16     	; 0x3232 <__mulsf3_pse+0x8c>
    3242:	fe 2b       	or	r31, r30
    3244:	88 0f       	add	r24, r24
    3246:	91 1d       	adc	r25, r1
    3248:	96 95       	lsr	r25
    324a:	87 95       	ror	r24
    324c:	97 f9       	bld	r25, 7
    324e:	08 95       	ret

00003250 <pow>:
    3250:	fa 01       	movw	r30, r20
    3252:	ee 0f       	add	r30, r30
    3254:	ff 1f       	adc	r31, r31
    3256:	30 96       	adiw	r30, 0x00	; 0
    3258:	21 05       	cpc	r18, r1
    325a:	31 05       	cpc	r19, r1
    325c:	99 f1       	breq	.+102    	; 0x32c4 <pow+0x74>
    325e:	61 15       	cp	r22, r1
    3260:	71 05       	cpc	r23, r1
    3262:	61 f4       	brne	.+24     	; 0x327c <pow+0x2c>
    3264:	80 38       	cpi	r24, 0x80	; 128
    3266:	bf e3       	ldi	r27, 0x3F	; 63
    3268:	9b 07       	cpc	r25, r27
    326a:	49 f1       	breq	.+82     	; 0x32be <pow+0x6e>
    326c:	68 94       	set
    326e:	90 38       	cpi	r25, 0x80	; 128
    3270:	81 05       	cpc	r24, r1
    3272:	61 f0       	breq	.+24     	; 0x328c <pow+0x3c>
    3274:	80 38       	cpi	r24, 0x80	; 128
    3276:	bf ef       	ldi	r27, 0xFF	; 255
    3278:	9b 07       	cpc	r25, r27
    327a:	41 f0       	breq	.+16     	; 0x328c <pow+0x3c>
    327c:	99 23       	and	r25, r25
    327e:	42 f5       	brpl	.+80     	; 0x32d0 <pow+0x80>
    3280:	ff 3f       	cpi	r31, 0xFF	; 255
    3282:	e1 05       	cpc	r30, r1
    3284:	31 05       	cpc	r19, r1
    3286:	21 05       	cpc	r18, r1
    3288:	11 f1       	breq	.+68     	; 0x32ce <pow+0x7e>
    328a:	e8 94       	clt
    328c:	08 94       	sec
    328e:	e7 95       	ror	r30
    3290:	d9 01       	movw	r26, r18
    3292:	aa 23       	and	r26, r26
    3294:	29 f4       	brne	.+10     	; 0x32a0 <pow+0x50>
    3296:	ab 2f       	mov	r26, r27
    3298:	be 2f       	mov	r27, r30
    329a:	f8 5f       	subi	r31, 0xF8	; 248
    329c:	d0 f3       	brcs	.-12     	; 0x3292 <pow+0x42>
    329e:	10 c0       	rjmp	.+32     	; 0x32c0 <pow+0x70>
    32a0:	ff 5f       	subi	r31, 0xFF	; 255
    32a2:	70 f4       	brcc	.+28     	; 0x32c0 <pow+0x70>
    32a4:	a6 95       	lsr	r26
    32a6:	e0 f7       	brcc	.-8      	; 0x32a0 <pow+0x50>
    32a8:	f7 39       	cpi	r31, 0x97	; 151
    32aa:	50 f0       	brcs	.+20     	; 0x32c0 <pow+0x70>
    32ac:	19 f0       	breq	.+6      	; 0x32b4 <pow+0x64>
    32ae:	ff 3a       	cpi	r31, 0xAF	; 175
    32b0:	38 f4       	brcc	.+14     	; 0x32c0 <pow+0x70>
    32b2:	9f 77       	andi	r25, 0x7F	; 127
    32b4:	9f 93       	push	r25
    32b6:	0c d0       	rcall	.+24     	; 0x32d0 <pow+0x80>
    32b8:	0f 90       	pop	r0
    32ba:	07 fc       	sbrc	r0, 7
    32bc:	90 58       	subi	r25, 0x80	; 128
    32be:	08 95       	ret
    32c0:	3e f0       	brts	.+14     	; 0x32d0 <pow+0x80>
    32c2:	18 cf       	rjmp	.-464    	; 0x30f4 <__fp_nan>
    32c4:	60 e0       	ldi	r22, 0x00	; 0
    32c6:	70 e0       	ldi	r23, 0x00	; 0
    32c8:	80 e8       	ldi	r24, 0x80	; 128
    32ca:	9f e3       	ldi	r25, 0x3F	; 63
    32cc:	08 95       	ret
    32ce:	4f e7       	ldi	r20, 0x7F	; 127
    32d0:	9f 77       	andi	r25, 0x7F	; 127
    32d2:	5f 93       	push	r21
    32d4:	4f 93       	push	r20
    32d6:	3f 93       	push	r19
    32d8:	2f 93       	push	r18
    32da:	9e d0       	rcall	.+316    	; 0x3418 <log>
    32dc:	2f 91       	pop	r18
    32de:	3f 91       	pop	r19
    32e0:	4f 91       	pop	r20
    32e2:	5f 91       	pop	r21
    32e4:	52 df       	rcall	.-348    	; 0x318a <__mulsf3>
    32e6:	05 c0       	rjmp	.+10     	; 0x32f2 <exp>
    32e8:	19 f4       	brne	.+6      	; 0x32f0 <pow+0xa0>
    32ea:	0e f0       	brts	.+2      	; 0x32ee <pow+0x9e>
    32ec:	fd ce       	rjmp	.-518    	; 0x30e8 <__fp_inf>
    32ee:	46 cf       	rjmp	.-372    	; 0x317c <__fp_zero>
    32f0:	01 cf       	rjmp	.-510    	; 0x30f4 <__fp_nan>

000032f2 <exp>:
    32f2:	2a df       	rcall	.-428    	; 0x3148 <__fp_splitA>
    32f4:	c8 f3       	brcs	.-14     	; 0x32e8 <pow+0x98>
    32f6:	96 38       	cpi	r25, 0x86	; 134
    32f8:	c0 f7       	brcc	.-16     	; 0x32ea <pow+0x9a>
    32fa:	07 f8       	bld	r0, 7
    32fc:	0f 92       	push	r0
    32fe:	e8 94       	clt
    3300:	2b e3       	ldi	r18, 0x3B	; 59
    3302:	3a ea       	ldi	r19, 0xAA	; 170
    3304:	48 eb       	ldi	r20, 0xB8	; 184
    3306:	5f e7       	ldi	r21, 0x7F	; 127
    3308:	4e df       	rcall	.-356    	; 0x31a6 <__mulsf3_pse>
    330a:	0f 92       	push	r0
    330c:	0f 92       	push	r0
    330e:	0f 92       	push	r0
    3310:	4d b7       	in	r20, 0x3d	; 61
    3312:	5e b7       	in	r21, 0x3e	; 62
    3314:	0f 92       	push	r0
    3316:	c0 d0       	rcall	.+384    	; 0x3498 <modf>
    3318:	e4 e5       	ldi	r30, 0x54	; 84
    331a:	f0 e0       	ldi	r31, 0x00	; 0
    331c:	16 d0       	rcall	.+44     	; 0x334a <__fp_powser>
    331e:	4f 91       	pop	r20
    3320:	5f 91       	pop	r21
    3322:	ef 91       	pop	r30
    3324:	ff 91       	pop	r31
    3326:	e5 95       	asr	r30
    3328:	ee 1f       	adc	r30, r30
    332a:	ff 1f       	adc	r31, r31
    332c:	49 f0       	breq	.+18     	; 0x3340 <exp+0x4e>
    332e:	fe 57       	subi	r31, 0x7E	; 126
    3330:	e0 68       	ori	r30, 0x80	; 128
    3332:	44 27       	eor	r20, r20
    3334:	ee 0f       	add	r30, r30
    3336:	44 1f       	adc	r20, r20
    3338:	fa 95       	dec	r31
    333a:	e1 f7       	brne	.-8      	; 0x3334 <exp+0x42>
    333c:	41 95       	neg	r20
    333e:	55 0b       	sbc	r21, r21
    3340:	32 d0       	rcall	.+100    	; 0x33a6 <ldexp>
    3342:	0f 90       	pop	r0
    3344:	07 fe       	sbrs	r0, 7
    3346:	26 c0       	rjmp	.+76     	; 0x3394 <inverse>
    3348:	08 95       	ret

0000334a <__fp_powser>:
    334a:	df 93       	push	r29
    334c:	cf 93       	push	r28
    334e:	1f 93       	push	r17
    3350:	0f 93       	push	r16
    3352:	ff 92       	push	r15
    3354:	ef 92       	push	r14
    3356:	df 92       	push	r13
    3358:	7b 01       	movw	r14, r22
    335a:	8c 01       	movw	r16, r24
    335c:	68 94       	set
    335e:	05 c0       	rjmp	.+10     	; 0x336a <__fp_powser+0x20>
    3360:	da 2e       	mov	r13, r26
    3362:	ef 01       	movw	r28, r30
    3364:	1e df       	rcall	.-452    	; 0x31a2 <__mulsf3x>
    3366:	fe 01       	movw	r30, r28
    3368:	e8 94       	clt
    336a:	a5 91       	lpm	r26, Z+
    336c:	25 91       	lpm	r18, Z+
    336e:	35 91       	lpm	r19, Z+
    3370:	45 91       	lpm	r20, Z+
    3372:	55 91       	lpm	r21, Z+
    3374:	ae f3       	brts	.-22     	; 0x3360 <__fp_powser+0x16>
    3376:	ef 01       	movw	r28, r30
    3378:	8e dd       	rcall	.-1252   	; 0x2e96 <__addsf3x>
    337a:	fe 01       	movw	r30, r28
    337c:	97 01       	movw	r18, r14
    337e:	a8 01       	movw	r20, r16
    3380:	da 94       	dec	r13
    3382:	79 f7       	brne	.-34     	; 0x3362 <__fp_powser+0x18>
    3384:	df 90       	pop	r13
    3386:	ef 90       	pop	r14
    3388:	ff 90       	pop	r15
    338a:	0f 91       	pop	r16
    338c:	1f 91       	pop	r17
    338e:	cf 91       	pop	r28
    3390:	df 91       	pop	r29
    3392:	08 95       	ret

00003394 <inverse>:
    3394:	9b 01       	movw	r18, r22
    3396:	ac 01       	movw	r20, r24
    3398:	60 e0       	ldi	r22, 0x00	; 0
    339a:	70 e0       	ldi	r23, 0x00	; 0
    339c:	80 e8       	ldi	r24, 0x80	; 128
    339e:	9f e3       	ldi	r25, 0x3F	; 63
    33a0:	cd cd       	rjmp	.-1126   	; 0x2f3c <__divsf3>
    33a2:	a2 ce       	rjmp	.-700    	; 0x30e8 <__fp_inf>
    33a4:	ac c0       	rjmp	.+344    	; 0x34fe <__fp_mpack>

000033a6 <ldexp>:
    33a6:	d0 de       	rcall	.-608    	; 0x3148 <__fp_splitA>
    33a8:	e8 f3       	brcs	.-6      	; 0x33a4 <inverse+0x10>
    33aa:	99 23       	and	r25, r25
    33ac:	d9 f3       	breq	.-10     	; 0x33a4 <inverse+0x10>
    33ae:	94 0f       	add	r25, r20
    33b0:	51 1d       	adc	r21, r1
    33b2:	bb f3       	brvs	.-18     	; 0x33a2 <inverse+0xe>
    33b4:	91 50       	subi	r25, 0x01	; 1
    33b6:	50 40       	sbci	r21, 0x00	; 0
    33b8:	94 f0       	brlt	.+36     	; 0x33de <ldexp+0x38>
    33ba:	59 f0       	breq	.+22     	; 0x33d2 <ldexp+0x2c>
    33bc:	88 23       	and	r24, r24
    33be:	32 f0       	brmi	.+12     	; 0x33cc <ldexp+0x26>
    33c0:	66 0f       	add	r22, r22
    33c2:	77 1f       	adc	r23, r23
    33c4:	88 1f       	adc	r24, r24
    33c6:	91 50       	subi	r25, 0x01	; 1
    33c8:	50 40       	sbci	r21, 0x00	; 0
    33ca:	c1 f7       	brne	.-16     	; 0x33bc <ldexp+0x16>
    33cc:	9e 3f       	cpi	r25, 0xFE	; 254
    33ce:	51 05       	cpc	r21, r1
    33d0:	44 f7       	brge	.-48     	; 0x33a2 <inverse+0xe>
    33d2:	88 0f       	add	r24, r24
    33d4:	91 1d       	adc	r25, r1
    33d6:	96 95       	lsr	r25
    33d8:	87 95       	ror	r24
    33da:	97 f9       	bld	r25, 7
    33dc:	08 95       	ret
    33de:	5f 3f       	cpi	r21, 0xFF	; 255
    33e0:	ac f0       	brlt	.+42     	; 0x340c <ldexp+0x66>
    33e2:	98 3e       	cpi	r25, 0xE8	; 232
    33e4:	9c f0       	brlt	.+38     	; 0x340c <ldexp+0x66>
    33e6:	bb 27       	eor	r27, r27
    33e8:	86 95       	lsr	r24
    33ea:	77 95       	ror	r23
    33ec:	67 95       	ror	r22
    33ee:	b7 95       	ror	r27
    33f0:	08 f4       	brcc	.+2      	; 0x33f4 <ldexp+0x4e>
    33f2:	b1 60       	ori	r27, 0x01	; 1
    33f4:	93 95       	inc	r25
    33f6:	c1 f7       	brne	.-16     	; 0x33e8 <ldexp+0x42>
    33f8:	bb 0f       	add	r27, r27
    33fa:	58 f7       	brcc	.-42     	; 0x33d2 <ldexp+0x2c>
    33fc:	11 f4       	brne	.+4      	; 0x3402 <ldexp+0x5c>
    33fe:	60 ff       	sbrs	r22, 0
    3400:	e8 cf       	rjmp	.-48     	; 0x33d2 <ldexp+0x2c>
    3402:	6f 5f       	subi	r22, 0xFF	; 255
    3404:	7f 4f       	sbci	r23, 0xFF	; 255
    3406:	8f 4f       	sbci	r24, 0xFF	; 255
    3408:	9f 4f       	sbci	r25, 0xFF	; 255
    340a:	e3 cf       	rjmp	.-58     	; 0x33d2 <ldexp+0x2c>
    340c:	b8 ce       	rjmp	.-656    	; 0x317e <__fp_szero>
    340e:	0e f0       	brts	.+2      	; 0x3412 <ldexp+0x6c>
    3410:	76 c0       	rjmp	.+236    	; 0x34fe <__fp_mpack>
    3412:	70 ce       	rjmp	.-800    	; 0x30f4 <__fp_nan>
    3414:	68 94       	set
    3416:	68 ce       	rjmp	.-816    	; 0x30e8 <__fp_inf>

00003418 <log>:
    3418:	97 de       	rcall	.-722    	; 0x3148 <__fp_splitA>
    341a:	c8 f3       	brcs	.-14     	; 0x340e <ldexp+0x68>
    341c:	99 23       	and	r25, r25
    341e:	d1 f3       	breq	.-12     	; 0x3414 <ldexp+0x6e>
    3420:	c6 f3       	brts	.-16     	; 0x3412 <ldexp+0x6c>
    3422:	df 93       	push	r29
    3424:	cf 93       	push	r28
    3426:	1f 93       	push	r17
    3428:	0f 93       	push	r16
    342a:	ff 92       	push	r15
    342c:	c9 2f       	mov	r28, r25
    342e:	dd 27       	eor	r29, r29
    3430:	88 23       	and	r24, r24
    3432:	2a f0       	brmi	.+10     	; 0x343e <log+0x26>
    3434:	21 97       	sbiw	r28, 0x01	; 1
    3436:	66 0f       	add	r22, r22
    3438:	77 1f       	adc	r23, r23
    343a:	88 1f       	adc	r24, r24
    343c:	da f7       	brpl	.-10     	; 0x3434 <log+0x1c>
    343e:	20 e0       	ldi	r18, 0x00	; 0
    3440:	30 e0       	ldi	r19, 0x00	; 0
    3442:	40 e8       	ldi	r20, 0x80	; 128
    3444:	5f eb       	ldi	r21, 0xBF	; 191
    3446:	9f e3       	ldi	r25, 0x3F	; 63
    3448:	88 39       	cpi	r24, 0x98	; 152
    344a:	20 f0       	brcs	.+8      	; 0x3454 <log+0x3c>
    344c:	80 3e       	cpi	r24, 0xE0	; 224
    344e:	30 f0       	brcs	.+12     	; 0x345c <log+0x44>
    3450:	21 96       	adiw	r28, 0x01	; 1
    3452:	8f 77       	andi	r24, 0x7F	; 127
    3454:	0f dd       	rcall	.-1506   	; 0x2e74 <__addsf3>
    3456:	ec e7       	ldi	r30, 0x7C	; 124
    3458:	f0 e0       	ldi	r31, 0x00	; 0
    345a:	03 c0       	rjmp	.+6      	; 0x3462 <log+0x4a>
    345c:	0b dd       	rcall	.-1514   	; 0x2e74 <__addsf3>
    345e:	e9 ea       	ldi	r30, 0xA9	; 169
    3460:	f0 e0       	ldi	r31, 0x00	; 0
    3462:	73 df       	rcall	.-282    	; 0x334a <__fp_powser>
    3464:	8b 01       	movw	r16, r22
    3466:	be 01       	movw	r22, r28
    3468:	ec 01       	movw	r28, r24
    346a:	fb 2e       	mov	r15, r27
    346c:	6f 57       	subi	r22, 0x7F	; 127
    346e:	71 09       	sbc	r23, r1
    3470:	75 95       	asr	r23
    3472:	77 1f       	adc	r23, r23
    3474:	88 0b       	sbc	r24, r24
    3476:	99 0b       	sbc	r25, r25
    3478:	fc dd       	rcall	.-1032   	; 0x3072 <__floatsisf>
    347a:	28 e1       	ldi	r18, 0x18	; 24
    347c:	32 e7       	ldi	r19, 0x72	; 114
    347e:	41 e3       	ldi	r20, 0x31	; 49
    3480:	5f e3       	ldi	r21, 0x3F	; 63
    3482:	8f de       	rcall	.-738    	; 0x31a2 <__mulsf3x>
    3484:	af 2d       	mov	r26, r15
    3486:	98 01       	movw	r18, r16
    3488:	ae 01       	movw	r20, r28
    348a:	ff 90       	pop	r15
    348c:	0f 91       	pop	r16
    348e:	1f 91       	pop	r17
    3490:	cf 91       	pop	r28
    3492:	df 91       	pop	r29
    3494:	00 dd       	rcall	.-1536   	; 0x2e96 <__addsf3x>
    3496:	3f ce       	rjmp	.-898    	; 0x3116 <__fp_round>

00003498 <modf>:
    3498:	fa 01       	movw	r30, r20
    349a:	dc 01       	movw	r26, r24
    349c:	aa 0f       	add	r26, r26
    349e:	bb 1f       	adc	r27, r27
    34a0:	9b 01       	movw	r18, r22
    34a2:	ac 01       	movw	r20, r24
    34a4:	bf 57       	subi	r27, 0x7F	; 127
    34a6:	28 f4       	brcc	.+10     	; 0x34b2 <modf+0x1a>
    34a8:	22 27       	eor	r18, r18
    34aa:	33 27       	eor	r19, r19
    34ac:	44 27       	eor	r20, r20
    34ae:	50 78       	andi	r21, 0x80	; 128
    34b0:	1f c0       	rjmp	.+62     	; 0x34f0 <modf+0x58>
    34b2:	b7 51       	subi	r27, 0x17	; 23
    34b4:	88 f4       	brcc	.+34     	; 0x34d8 <modf+0x40>
    34b6:	ab 2f       	mov	r26, r27
    34b8:	00 24       	eor	r0, r0
    34ba:	46 95       	lsr	r20
    34bc:	37 95       	ror	r19
    34be:	27 95       	ror	r18
    34c0:	01 1c       	adc	r0, r1
    34c2:	a3 95       	inc	r26
    34c4:	d2 f3       	brmi	.-12     	; 0x34ba <modf+0x22>
    34c6:	00 20       	and	r0, r0
    34c8:	69 f0       	breq	.+26     	; 0x34e4 <modf+0x4c>
    34ca:	22 0f       	add	r18, r18
    34cc:	33 1f       	adc	r19, r19
    34ce:	44 1f       	adc	r20, r20
    34d0:	b3 95       	inc	r27
    34d2:	da f3       	brmi	.-10     	; 0x34ca <modf+0x32>
    34d4:	0d d0       	rcall	.+26     	; 0x34f0 <modf+0x58>
    34d6:	cd cc       	rjmp	.-1638   	; 0x2e72 <__subsf3>
    34d8:	61 30       	cpi	r22, 0x01	; 1
    34da:	71 05       	cpc	r23, r1
    34dc:	a0 e8       	ldi	r26, 0x80	; 128
    34de:	8a 07       	cpc	r24, r26
    34e0:	b9 46       	sbci	r27, 0x69	; 105
    34e2:	30 f4       	brcc	.+12     	; 0x34f0 <modf+0x58>
    34e4:	9b 01       	movw	r18, r22
    34e6:	ac 01       	movw	r20, r24
    34e8:	66 27       	eor	r22, r22
    34ea:	77 27       	eor	r23, r23
    34ec:	88 27       	eor	r24, r24
    34ee:	90 78       	andi	r25, 0x80	; 128
    34f0:	30 96       	adiw	r30, 0x00	; 0
    34f2:	21 f0       	breq	.+8      	; 0x34fc <modf+0x64>
    34f4:	20 83       	st	Z, r18
    34f6:	31 83       	std	Z+1, r19	; 0x01
    34f8:	42 83       	std	Z+2, r20	; 0x02
    34fa:	53 83       	std	Z+3, r21	; 0x03
    34fc:	08 95       	ret

000034fe <__fp_mpack>:
    34fe:	9f 3f       	cpi	r25, 0xFF	; 255
    3500:	31 f0       	breq	.+12     	; 0x350e <__fp_mpack_finite+0xc>

00003502 <__fp_mpack_finite>:
    3502:	91 50       	subi	r25, 0x01	; 1
    3504:	20 f4       	brcc	.+8      	; 0x350e <__fp_mpack_finite+0xc>
    3506:	87 95       	ror	r24
    3508:	77 95       	ror	r23
    350a:	67 95       	ror	r22
    350c:	b7 95       	ror	r27
    350e:	88 0f       	add	r24, r24
    3510:	91 1d       	adc	r25, r1
    3512:	96 95       	lsr	r25
    3514:	87 95       	ror	r24
    3516:	97 f9       	bld	r25, 7
    3518:	08 95       	ret

0000351a <__udivmodhi4>:
    351a:	aa 1b       	sub	r26, r26
    351c:	bb 1b       	sub	r27, r27
    351e:	51 e1       	ldi	r21, 0x11	; 17
    3520:	07 c0       	rjmp	.+14     	; 0x3530 <__udivmodhi4_ep>

00003522 <__udivmodhi4_loop>:
    3522:	aa 1f       	adc	r26, r26
    3524:	bb 1f       	adc	r27, r27
    3526:	a6 17       	cp	r26, r22
    3528:	b7 07       	cpc	r27, r23
    352a:	10 f0       	brcs	.+4      	; 0x3530 <__udivmodhi4_ep>
    352c:	a6 1b       	sub	r26, r22
    352e:	b7 0b       	sbc	r27, r23

00003530 <__udivmodhi4_ep>:
    3530:	88 1f       	adc	r24, r24
    3532:	99 1f       	adc	r25, r25
    3534:	5a 95       	dec	r21
    3536:	a9 f7       	brne	.-22     	; 0x3522 <__udivmodhi4_loop>
    3538:	80 95       	com	r24
    353a:	90 95       	com	r25
    353c:	bc 01       	movw	r22, r24
    353e:	cd 01       	movw	r24, r26
    3540:	08 95       	ret

00003542 <__divmodhi4>:
    3542:	97 fb       	bst	r25, 7
    3544:	09 2e       	mov	r0, r25
    3546:	07 26       	eor	r0, r23
    3548:	0a d0       	rcall	.+20     	; 0x355e <__divmodhi4_neg1>
    354a:	77 fd       	sbrc	r23, 7
    354c:	04 d0       	rcall	.+8      	; 0x3556 <__divmodhi4_neg2>
    354e:	e5 df       	rcall	.-54     	; 0x351a <__udivmodhi4>
    3550:	06 d0       	rcall	.+12     	; 0x355e <__divmodhi4_neg1>
    3552:	00 20       	and	r0, r0
    3554:	1a f4       	brpl	.+6      	; 0x355c <__divmodhi4_exit>

00003556 <__divmodhi4_neg2>:
    3556:	70 95       	com	r23
    3558:	61 95       	neg	r22
    355a:	7f 4f       	sbci	r23, 0xFF	; 255

0000355c <__divmodhi4_exit>:
    355c:	08 95       	ret

0000355e <__divmodhi4_neg1>:
    355e:	f6 f7       	brtc	.-4      	; 0x355c <__divmodhi4_exit>
    3560:	90 95       	com	r25
    3562:	81 95       	neg	r24
    3564:	9f 4f       	sbci	r25, 0xFF	; 255
    3566:	08 95       	ret

00003568 <_exit>:
    3568:	f8 94       	cli

0000356a <__stop_program>:
    356a:	ff cf       	rjmp	.-2      	; 0x356a <__stop_program>
