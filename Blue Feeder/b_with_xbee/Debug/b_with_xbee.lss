
b_with_xbee.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000035da  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000c  00800060  000035da  0000366e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000b1  0080006c  0080006c  0000367a  2**0
                  ALLOC
  3 .stab         000033e4  00000000  00000000  0000367c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009aa  00000000  00000000  00006a60  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000c0  00000000  00000000  00007410  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002a8f  00000000  00000000  000074d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000043f  00000000  00000000  00009f5f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000db8  00000000  00000000  0000a39e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000009ac  00000000  00000000  0000b158  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000905  00000000  00000000  0000bb04  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001c65  00000000  00000000  0000c409  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000120  00000000  00000000  0000e06e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__ctors_end>
       4:	0c 94 43 0b 	jmp	0x1686	; 0x1686 <__vector_1>
       8:	0c 94 2c 0b 	jmp	0x1658	; 0x1658 <__vector_2>
       c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      10:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      14:	0c 94 e4 0c 	jmp	0x19c8	; 0x19c8 <__vector_5>
      18:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      1c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      20:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      24:	0c 94 97 11 	jmp	0x232e	; 0x232e <__vector_9>
      28:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      2c:	0c 94 6c 0e 	jmp	0x1cd8	; 0x1cd8 <__vector_11>
      30:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      34:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      38:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      3c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      40:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      44:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      48:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      4c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      50:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      54:	07 63       	ori	r16, 0x37	; 55
      56:	42 36       	cpi	r20, 0x62	; 98
      58:	b7 9b       	sbis	0x16, 7	; 22
      5a:	d8 a7       	lds	r29, 0x78
      5c:	1a 39       	cpi	r17, 0x9A	; 154
      5e:	68 56       	subi	r22, 0x68	; 104
      60:	18 ae       	sts	0xb8, r17
      62:	ba ab       	sts	0x5a, r27
      64:	55 8c       	ldd	r5, Z+29	; 0x1d
      66:	1d 3c       	cpi	r17, 0xCD	; 205
      68:	b7 cc       	rjmp	.-1682   	; 0xfffff9d8 <__eeprom_end+0xff7ef9d8>
      6a:	57 63       	ori	r21, 0x37	; 55
      6c:	bd 6d       	ori	r27, 0xDD	; 221
      6e:	ed fd       	.word	0xfded	; ????
      70:	75 3e       	cpi	r23, 0xE5	; 229
      72:	f6 17       	cp	r31, r22
      74:	72 31       	cpi	r23, 0x12	; 18
      76:	bf 00       	.word	0x00bf	; ????
      78:	00 00       	nop
      7a:	80 3f       	cpi	r24, 0xF0	; 240
      7c:	08 00       	.word	0x0008	; ????
      7e:	00 00       	nop
      80:	be 92       	st	-X, r11
      82:	24 49       	sbci	r18, 0x94	; 148
      84:	12 3e       	cpi	r17, 0xE2	; 226
      86:	ab aa       	sts	0x9b, r26
      88:	aa 2a       	or	r10, r26
      8a:	be cd       	rjmp	.-1156   	; 0xfffffc08 <__eeprom_end+0xff7efc08>
      8c:	cc cc       	rjmp	.-1640   	; 0xfffffa26 <__eeprom_end+0xff7efa26>
      8e:	4c 3e       	cpi	r20, 0xEC	; 236
      90:	00 00       	nop
      92:	00 80       	ld	r0, Z
      94:	be ab       	sts	0x5e, r27
      96:	aa aa       	sts	0x9a, r26
      98:	aa 3e       	cpi	r26, 0xEA	; 234
      9a:	00 00       	nop
      9c:	00 00       	nop
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	00 00       	nop
      a6:	00 00       	nop
      a8:	00 08       	sbc	r0, r0
      aa:	41 78       	andi	r20, 0x81	; 129
      ac:	d3 bb       	out	0x13, r29	; 19
      ae:	43 87       	std	Z+11, r20	; 0x0b
      b0:	d1 13       	cpse	r29, r17
      b2:	3d 19       	sub	r19, r13
      b4:	0e 3c       	cpi	r16, 0xCE	; 206
      b6:	c3 bd       	out	0x23, r28	; 35
      b8:	42 82       	std	Z+2, r4	; 0x02
      ba:	ad 2b       	or	r26, r29
      bc:	3e 68       	ori	r19, 0x8E	; 142
      be:	ec 82       	std	Y+4, r14	; 0x04
      c0:	76 be       	out	0x36, r7	; 54
      c2:	d9 8f       	std	Y+25, r29	; 0x19
      c4:	e1 a9       	sts	0x41, r30
      c6:	3e 4c       	sbci	r19, 0xCE	; 206
      c8:	80 ef       	ldi	r24, 0xF0	; 240
      ca:	ff be       	out	0x3f, r15	; 63
      cc:	01 c4       	rjmp	.+2050   	; 0x8d0 <__stack+0x471>
      ce:	ff 7f       	andi	r31, 0xFF	; 255
      d0:	3f 00       	.word	0x003f	; ????
      d2:	00 00       	nop
	...

000000d6 <__ctors_end>:
      d6:	11 24       	eor	r1, r1
      d8:	1f be       	out	0x3f, r1	; 63
      da:	cf e5       	ldi	r28, 0x5F	; 95
      dc:	d4 e0       	ldi	r29, 0x04	; 4
      de:	de bf       	out	0x3e, r29	; 62
      e0:	cd bf       	out	0x3d, r28	; 61

000000e2 <__do_copy_data>:
      e2:	10 e0       	ldi	r17, 0x00	; 0
      e4:	a0 e6       	ldi	r26, 0x60	; 96
      e6:	b0 e0       	ldi	r27, 0x00	; 0
      e8:	ea ed       	ldi	r30, 0xDA	; 218
      ea:	f5 e3       	ldi	r31, 0x35	; 53
      ec:	02 c0       	rjmp	.+4      	; 0xf2 <__do_copy_data+0x10>
      ee:	05 90       	lpm	r0, Z+
      f0:	0d 92       	st	X+, r0
      f2:	ac 36       	cpi	r26, 0x6C	; 108
      f4:	b1 07       	cpc	r27, r17
      f6:	d9 f7       	brne	.-10     	; 0xee <__do_copy_data+0xc>

000000f8 <__do_clear_bss>:
      f8:	11 e0       	ldi	r17, 0x01	; 1
      fa:	ac e6       	ldi	r26, 0x6C	; 108
      fc:	b0 e0       	ldi	r27, 0x00	; 0
      fe:	01 c0       	rjmp	.+2      	; 0x102 <.do_clear_bss_start>

00000100 <.do_clear_bss_loop>:
     100:	1d 92       	st	X+, r1

00000102 <.do_clear_bss_start>:
     102:	ad 31       	cpi	r26, 0x1D	; 29
     104:	b1 07       	cpc	r27, r17
     106:	e1 f7       	brne	.-8      	; 0x100 <.do_clear_bss_loop>
     108:	0e 94 17 14 	call	0x282e	; 0x282e <main>
     10c:	0c 94 eb 1a 	jmp	0x35d6	; 0x35d6 <_exit>

00000110 <__bad_interrupt>:
     110:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000114 <velocity>:
  * Example Call: velocity(70,70)
  */ 

void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR1AH = 0x00;
     114:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = left_motor;
     116:	8a bd       	out	0x2a, r24	; 42
	OCR1BH = 0x00;
     118:	19 bc       	out	0x29, r1	; 41
	OCR1BL = right_motor;
     11a:	68 bd       	out	0x28, r22	; 40
}
     11c:	08 95       	ret

0000011e <update_curr_pos>:
  * Example Call: update_curr_pos()
  */

void update_curr_pos()
{
	if(orient==0)        curr_pos-=7;
     11e:	80 91 f6 00 	lds	r24, 0x00F6
     122:	90 91 f7 00 	lds	r25, 0x00F7
     126:	00 97       	sbiw	r24, 0x00	; 0
     128:	51 f4       	brne	.+20     	; 0x13e <update_curr_pos+0x20>
     12a:	80 91 b2 00 	lds	r24, 0x00B2
     12e:	90 91 b3 00 	lds	r25, 0x00B3
     132:	07 97       	sbiw	r24, 0x07	; 7
     134:	90 93 b3 00 	sts	0x00B3, r25
     138:	80 93 b2 00 	sts	0x00B2, r24
     13c:	08 95       	ret
	else if(orient==1)   curr_pos+=1;
     13e:	80 91 f6 00 	lds	r24, 0x00F6
     142:	90 91 f7 00 	lds	r25, 0x00F7
     146:	81 30       	cpi	r24, 0x01	; 1
     148:	91 05       	cpc	r25, r1
     14a:	51 f4       	brne	.+20     	; 0x160 <update_curr_pos+0x42>
     14c:	80 91 b2 00 	lds	r24, 0x00B2
     150:	90 91 b3 00 	lds	r25, 0x00B3
     154:	01 96       	adiw	r24, 0x01	; 1
     156:	90 93 b3 00 	sts	0x00B3, r25
     15a:	80 93 b2 00 	sts	0x00B2, r24
     15e:	08 95       	ret
	else if(orient==2)   curr_pos+=7;
     160:	80 91 f6 00 	lds	r24, 0x00F6
     164:	90 91 f7 00 	lds	r25, 0x00F7
     168:	82 30       	cpi	r24, 0x02	; 2
     16a:	91 05       	cpc	r25, r1
     16c:	51 f4       	brne	.+20     	; 0x182 <update_curr_pos+0x64>
     16e:	80 91 b2 00 	lds	r24, 0x00B2
     172:	90 91 b3 00 	lds	r25, 0x00B3
     176:	07 96       	adiw	r24, 0x07	; 7
     178:	90 93 b3 00 	sts	0x00B3, r25
     17c:	80 93 b2 00 	sts	0x00B2, r24
     180:	08 95       	ret
	else if(orient==3)   curr_pos-=1;
     182:	80 91 f6 00 	lds	r24, 0x00F6
     186:	90 91 f7 00 	lds	r25, 0x00F7
     18a:	83 30       	cpi	r24, 0x03	; 3
     18c:	91 05       	cpc	r25, r1
     18e:	49 f4       	brne	.+18     	; 0x1a2 <update_curr_pos+0x84>
     190:	80 91 b2 00 	lds	r24, 0x00B2
     194:	90 91 b3 00 	lds	r25, 0x00B3
     198:	01 97       	sbiw	r24, 0x01	; 1
     19a:	90 93 b3 00 	sts	0x00B3, r25
     19e:	80 93 b2 00 	sts	0x00B2, r24
     1a2:	08 95       	ret

000001a4 <all_bot_clear>:
  * Example Call: all_bot_clear()
  */

void all_bot_clear()
{
   home_bit[0]=0;
     1a4:	10 92 a3 00 	sts	0x00A3, r1
     1a8:	10 92 a2 00 	sts	0x00A2, r1
   home_bit[1]=0;
     1ac:	10 92 a5 00 	sts	0x00A5, r1
     1b0:	10 92 a4 00 	sts	0x00A4, r1
   home_bit[2]=0;	
     1b4:	10 92 a7 00 	sts	0x00A7, r1
     1b8:	10 92 a6 00 	sts	0x00A6, r1
}
     1bc:	08 95       	ret

000001be <all_xbee_clear>:

void all_xbee_clear()
{
	red_xbee_flag = 0;
     1be:	10 92 89 00 	sts	0x0089, r1
     1c2:	10 92 88 00 	sts	0x0088, r1
	green_xbee_flag = 0;
     1c6:	10 92 87 00 	sts	0x0087, r1
     1ca:	10 92 86 00 	sts	0x0086, r1
}
     1ce:	08 95       	ret

000001d0 <shiftr>:
  * Logic: This function is used to shift the elements of initiial_home_run[] array to introduce the position behind the start position of the bot
  * Example Call: shiftr(26)
  */ 

void shiftr(int imag_prev)
{
     1d0:	cf 93       	push	r28
     1d2:	df 93       	push	r29
     1d4:	ec 01       	movw	r28, r24
    int i,n;
    i=node_count;
     1d6:	20 91 94 00 	lds	r18, 0x0094
     1da:	30 91 95 00 	lds	r19, 0x0095
    n=node_count-1;
     1de:	40 91 94 00 	lds	r20, 0x0094
     1e2:	50 91 95 00 	lds	r21, 0x0095
    while(i>0)
     1e6:	12 16       	cp	r1, r18
     1e8:	13 06       	cpc	r1, r19
     1ea:	c4 f4       	brge	.+48     	; 0x21c <shiftr+0x4c>

void shiftr(int imag_prev)
{
    int i,n;
    i=node_count;
    n=node_count-1;
     1ec:	41 50       	subi	r20, 0x01	; 1
     1ee:	50 40       	sbci	r21, 0x00	; 0
    while(i>0)
    {  
		initial_home_run[i] = initial_home_run[n] ;
     1f0:	ab eb       	ldi	r26, 0xBB	; 187
     1f2:	b0 e0       	ldi	r27, 0x00	; 0
     1f4:	fa 01       	movw	r30, r20
     1f6:	ee 0f       	add	r30, r30
     1f8:	ff 1f       	adc	r31, r31
     1fa:	ea 0f       	add	r30, r26
     1fc:	fb 1f       	adc	r31, r27
     1fe:	60 81       	ld	r22, Z
     200:	71 81       	ldd	r23, Z+1	; 0x01
     202:	c9 01       	movw	r24, r18
     204:	88 0f       	add	r24, r24
     206:	99 1f       	adc	r25, r25
     208:	8a 0f       	add	r24, r26
     20a:	9b 1f       	adc	r25, r27
     20c:	fc 01       	movw	r30, r24
     20e:	71 83       	std	Z+1, r23	; 0x01
     210:	60 83       	st	Z, r22
		--n;
     212:	41 50       	subi	r20, 0x01	; 1
     214:	50 40       	sbci	r21, 0x00	; 0
		--i;
     216:	21 50       	subi	r18, 0x01	; 1
     218:	30 40       	sbci	r19, 0x00	; 0
void shiftr(int imag_prev)
{
    int i,n;
    i=node_count;
    n=node_count-1;
    while(i>0)
     21a:	61 f7       	brne	.-40     	; 0x1f4 <shiftr+0x24>
    {  
		initial_home_run[i] = initial_home_run[n] ;
		--n;
		--i;
	}		
    initial_home_run[0]= imag_prev ;
     21c:	d0 93 bc 00 	sts	0x00BC, r29
     220:	c0 93 bb 00 	sts	0x00BB, r28
}
     224:	df 91       	pop	r29
     226:	cf 91       	pop	r28
     228:	08 95       	ret

0000022a <just_forward>:

void just_forward()
{
	//stop();
	//_delay_ms(500);
	forward();
     22a:	0e 94 28 0b 	call	0x1650	; 0x1650 <forward>
	velocity(35,35);
     22e:	83 e2       	ldi	r24, 0x23	; 35
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	63 e2       	ldi	r22, 0x23	; 35
     234:	70 e0       	ldi	r23, 0x00	; 0
     236:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     23a:	8f ef       	ldi	r24, 0xFF	; 255
     23c:	9f ef       	ldi	r25, 0xFF	; 255
     23e:	a1 e1       	ldi	r26, 0x11	; 17
     240:	81 50       	subi	r24, 0x01	; 1
     242:	90 40       	sbci	r25, 0x00	; 0
     244:	a0 40       	sbci	r26, 0x00	; 0
     246:	e1 f7       	brne	.-8      	; 0x240 <just_forward+0x16>
     248:	00 c0       	rjmp	.+0      	; 0x24a <just_forward+0x20>
     24a:	00 00       	nop
	_delay_ms(800);
	
}
     24c:	08 95       	ret

0000024e <turn_right>:
void turn_right()
{
	//stop();
	//_delay_ms(500);
	forward();
     24e:	0e 94 28 0b 	call	0x1650	; 0x1650 <forward>
	velocity(35,35);
     252:	83 e2       	ldi	r24, 0x23	; 35
     254:	90 e0       	ldi	r25, 0x00	; 0
     256:	63 e2       	ldi	r22, 0x23	; 35
     258:	70 e0       	ldi	r23, 0x00	; 0
     25a:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>
     25e:	8f ef       	ldi	r24, 0xFF	; 255
     260:	9f e7       	ldi	r25, 0x7F	; 127
     262:	ad e0       	ldi	r26, 0x0D	; 13
     264:	81 50       	subi	r24, 0x01	; 1
     266:	90 40       	sbci	r25, 0x00	; 0
     268:	a0 40       	sbci	r26, 0x00	; 0
     26a:	e1 f7       	brne	.-8      	; 0x264 <turn_right+0x16>
     26c:	00 c0       	rjmp	.+0      	; 0x26e <turn_right+0x20>
     26e:	00 00       	nop
	_delay_ms(600);
	turn(1);
     270:	81 e0       	ldi	r24, 0x01	; 1
     272:	90 e0       	ldi	r25, 0x00	; 0
     274:	0e 94 42 0c 	call	0x1884	; 0x1884 <turn>
}
     278:	08 95       	ret

0000027a <turn_left>:
}
void turn_left()
{
	//stop();
	//_delay_ms(500);
	forward();
     27a:	0e 94 28 0b 	call	0x1650	; 0x1650 <forward>
	velocity(35,35);
     27e:	83 e2       	ldi	r24, 0x23	; 35
     280:	90 e0       	ldi	r25, 0x00	; 0
     282:	63 e2       	ldi	r22, 0x23	; 35
     284:	70 e0       	ldi	r23, 0x00	; 0
     286:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>
     28a:	8f ef       	ldi	r24, 0xFF	; 255
     28c:	9f e7       	ldi	r25, 0x7F	; 127
     28e:	ad e0       	ldi	r26, 0x0D	; 13
     290:	81 50       	subi	r24, 0x01	; 1
     292:	90 40       	sbci	r25, 0x00	; 0
     294:	a0 40       	sbci	r26, 0x00	; 0
     296:	e1 f7       	brne	.-8      	; 0x290 <turn_left+0x16>
     298:	00 c0       	rjmp	.+0      	; 0x29a <turn_left+0x20>
     29a:	00 00       	nop
	_delay_ms(600);
	//left();
	//_delay_ms(1700);
	turn(0);
     29c:	80 e0       	ldi	r24, 0x00	; 0
     29e:	90 e0       	ldi	r25, 0x00	; 0
     2a0:	0e 94 42 0c 	call	0x1884	; 0x1884 <turn>
}
     2a4:	08 95       	ret

000002a6 <turn_reverse>:

void turn_reverse()
{
	//stop();
	//_delay_ms(500);
	forward();
     2a6:	0e 94 28 0b 	call	0x1650	; 0x1650 <forward>
	velocity(35,35);
     2aa:	83 e2       	ldi	r24, 0x23	; 35
     2ac:	90 e0       	ldi	r25, 0x00	; 0
     2ae:	63 e2       	ldi	r22, 0x23	; 35
     2b0:	70 e0       	ldi	r23, 0x00	; 0
     2b2:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>
     2b6:	8f ef       	ldi	r24, 0xFF	; 255
     2b8:	9f e7       	ldi	r25, 0x7F	; 127
     2ba:	ad e0       	ldi	r26, 0x0D	; 13
     2bc:	81 50       	subi	r24, 0x01	; 1
     2be:	90 40       	sbci	r25, 0x00	; 0
     2c0:	a0 40       	sbci	r26, 0x00	; 0
     2c2:	e1 f7       	brne	.-8      	; 0x2bc <turn_reverse+0x16>
     2c4:	00 c0       	rjmp	.+0      	; 0x2c6 <turn_reverse+0x20>
     2c6:	00 00       	nop
	_delay_ms(600);
	//right();
	//_delay_ms(3450);
	turn(2);
     2c8:	82 e0       	ldi	r24, 0x02	; 2
     2ca:	90 e0       	ldi	r25, 0x00	; 0
     2cc:	0e 94 42 0c 	call	0x1884	; 0x1884 <turn>
}
     2d0:	08 95       	ret

000002d2 <rgb_led_pin_config>:
  * Example Call: rgb_led_pin_config()
  */

void rgb_led_pin_config(void)
{
	DDRC = DDRC | 0x07;
     2d2:	84 b3       	in	r24, 0x14	; 20
     2d4:	87 60       	ori	r24, 0x07	; 7
     2d6:	84 bb       	out	0x14, r24	; 20
	PORTC = PORTC & 0xF8;
     2d8:	85 b3       	in	r24, 0x15	; 21
     2da:	88 7f       	andi	r24, 0xF8	; 248
     2dc:	85 bb       	out	0x15, r24	; 21
}
     2de:	08 95       	ret

000002e0 <color_sensor_pin_config>:
  * Example Call: color_sensor_pin_config()
  */ 

void color_sensor_pin_config(void)
{
	DDRC  = DDRC | 0xFF; // CONFIGURING PINC 4-7 PINS AS OUTPUT FOR S0,S1,S2,S3.
     2e0:	84 b3       	in	r24, 0x14	; 20
     2e2:	8f ef       	ldi	r24, 0xFF	; 255
     2e4:	84 bb       	out	0x14, r24	; 20
	PORTC = PORTC | 0x00;// INITIALLY SET TO ZERO AS IN FIREBIRD V CODE
     2e6:	85 b3       	in	r24, 0x15	; 21
     2e8:	85 bb       	out	0x15, r24	; 21
	DDRD= DDRD | 0x32; // PIND6 CONFIGURED AS OUT OF COLOR SENSOR WHILE OTHERS ARE KEPT AT THEIR DEFAULT VALUES
     2ea:	81 b3       	in	r24, 0x11	; 17
     2ec:	82 63       	ori	r24, 0x32	; 50
     2ee:	81 bb       	out	0x11, r24	; 17
}
     2f0:	08 95       	ret

000002f2 <adc_pin_config>:
  * Example Call: adc_pin_config()
  */

void adc_pin_config (void)
{
	DDRA = 0x00;   //set PORTA direction as input
     2f2:	1a ba       	out	0x1a, r1	; 26
	PORTA = 0x00;  //set PORTA pins floating
     2f4:	1b ba       	out	0x1b, r1	; 27
}
     2f6:	08 95       	ret

000002f8 <timer1_init>:
  * Example Call: timer1_init()
  */

void timer1_init(void)
{
	TCCR1B = 0x00; //stop
     2f8:	1e bc       	out	0x2e, r1	; 46
	TCNT1H = 0xFF; //setup
     2fa:	8f ef       	ldi	r24, 0xFF	; 255
     2fc:	8d bd       	out	0x2d, r24	; 45
	TCNT1L = 0x01;
     2fe:	91 e0       	ldi	r25, 0x01	; 1
     300:	9c bd       	out	0x2c, r25	; 44
	OCR1AH = 0x00;
     302:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0xFF;
     304:	8a bd       	out	0x2a, r24	; 42
	OCR1BH = 0x00;
     306:	19 bc       	out	0x29, r1	; 41
	OCR1BL = 0xFF;
     308:	88 bd       	out	0x28, r24	; 40
	ICR1H  = 0x00;
     30a:	17 bc       	out	0x27, r1	; 39
	ICR1L  = 0xFF;
     30c:	86 bd       	out	0x26, r24	; 38
	TCCR1A = 0xA1;
     30e:	81 ea       	ldi	r24, 0xA1	; 161
     310:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0x0D; //start Timer
     312:	8d e0       	ldi	r24, 0x0D	; 13
     314:	8e bd       	out	0x2e, r24	; 46
}
     316:	08 95       	ret

00000318 <set_servo>:
  * Example Call: set_servo()
  */ 

void set_servo()
{
	DDRD  = DDRD | 0X80;
     318:	8f 9a       	sbi	0x11, 7	; 17
	TCCR0 = 0X02;
     31a:	82 e0       	ldi	r24, 0x02	; 2
     31c:	83 bf       	out	0x33, r24	; 51
	TCNT0 = 0XEB;
     31e:	8b ee       	ldi	r24, 0xEB	; 235
     320:	82 bf       	out	0x32, r24	; 50
	TIMSK = 0X01;
     322:	81 e0       	ldi	r24, 0x01	; 1
     324:	89 bf       	out	0x39, r24	; 57
}
     326:	08 95       	ret

00000328 <adc_init>:
  * Example Call: adc_init()
  */

void adc_init()
{
	ADCSRA = 0x00;
     328:	16 b8       	out	0x06, r1	; 6
	ADMUX = 0x20;
     32a:	80 e2       	ldi	r24, 0x20	; 32
     32c:	87 b9       	out	0x07, r24	; 7
	ACSR = 0x80;
     32e:	80 e8       	ldi	r24, 0x80	; 128
     330:	88 b9       	out	0x08, r24	; 8
	ADCSRA = 0x86;
     332:	86 e8       	ldi	r24, 0x86	; 134
     334:	86 b9       	out	0x06, r24	; 6
}
     336:	08 95       	ret

00000338 <motion_pin_config>:
  * Example Call: motion_pin_config()
  */ 

void motion_pin_config (void)
{
	DDRB = DDRB | 0x0F;   //set direction of the PORTB3 to PORTB0 pins as output
     338:	87 b3       	in	r24, 0x17	; 23
     33a:	8f 60       	ori	r24, 0x0F	; 15
     33c:	87 bb       	out	0x17, r24	; 23
	PORTB = PORTB & 0xF0; // set initial value of the PORTB3 to PORTB0 pins to logic 0
     33e:	88 b3       	in	r24, 0x18	; 24
     340:	80 7f       	andi	r24, 0xF0	; 240
     342:	88 bb       	out	0x18, r24	; 24
	DDRD = DDRD | 0x30;   //Setting PD4 and PD5 pins as output for PWM generation
     344:	81 b3       	in	r24, 0x11	; 17
     346:	80 63       	ori	r24, 0x30	; 48
     348:	81 bb       	out	0x11, r24	; 17
	PORTD = PORTD | 0x30; //PD4 and PD5 pins are for velocity control using PWM
     34a:	82 b3       	in	r24, 0x12	; 18
     34c:	80 63       	ori	r24, 0x30	; 48
     34e:	82 bb       	out	0x12, r24	; 18
}
     350:	08 95       	ret

00000352 <uart0_init>:
  * Example Call: uart0_init()
  */

void uart0_init()
{
	UCSRB = 0x00; //disable while setting baud rate
     352:	1a b8       	out	0x0a, r1	; 10
	UCSRA = 0x00;
     354:	1b b8       	out	0x0b, r1	; 11
	UCSRC = 0x86;
     356:	86 e8       	ldi	r24, 0x86	; 134
     358:	80 bd       	out	0x20, r24	; 32
	UBRRL = 0x2F; //set baud rate lo  //67 is for 16MHz 9600 baudrate
     35a:	8f e2       	ldi	r24, 0x2F	; 47
     35c:	89 b9       	out	0x09, r24	; 9
	UBRRH = 0x00; //set baud rate hi
     35e:	10 bc       	out	0x20, r1	; 32
	UCSRB = 0x98;
     360:	88 e9       	ldi	r24, 0x98	; 152
     362:	8a b9       	out	0x0a, r24	; 10
}
     364:	08 95       	ret

00000366 <left_encoder_pin_config>:
* Example Call: left_encoder_pin_config()
*/

 void left_encoder_pin_config(void)
{
	DDRD = DDRD & 0xFB;
     366:	8a 98       	cbi	0x11, 2	; 17
	PORTD = PORTD | 0x04;
     368:	92 9a       	sbi	0x12, 2	; 18
}
     36a:	08 95       	ret

0000036c <right_encoder_pin_config>:
* Example Call: right_encoder_pin_config()
*/

void right_encoder_pin_config(void)
 {
	 DDRD = DDRD & 0xF7;
     36c:	8b 98       	cbi	0x11, 3	; 17
	 PORTD = PORTD | 0x08;
     36e:	93 9a       	sbi	0x12, 3	; 18
 }
     370:	08 95       	ret

00000372 <buzzer_pin_config>:
  * Example Call: buzzer_pin_config()
  */ 

void buzzer_pin_config (void)
{
	DDRC = DDRC | 0x08;		//Setting PORTC 3 as output
     372:	a3 9a       	sbi	0x14, 3	; 20
	PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
     374:	ab 98       	cbi	0x15, 3	; 21
}
     376:	08 95       	ret

00000378 <right_position_encoder_interrupt_init>:
* Example Call: right_position_encoder_interrupt_init()
*/

void right_position_encoder_interrupt_init(void)
{
	MCUCR = MCUCR | 0x08;
     378:	85 b7       	in	r24, 0x35	; 53
     37a:	88 60       	ori	r24, 0x08	; 8
     37c:	85 bf       	out	0x35, r24	; 53
	GICR = GICR | 0x80;
     37e:	8b b7       	in	r24, 0x3b	; 59
     380:	80 68       	ori	r24, 0x80	; 128
     382:	8b bf       	out	0x3b, r24	; 59
}
     384:	08 95       	ret

00000386 <left_position_encoder_interrupt_init>:
* Example Call: right_position_encoder_interrupt_init()
*/

void left_position_encoder_interrupt_init(void)
{
	MCUCR = MCUCR | 0x02;
     386:	85 b7       	in	r24, 0x35	; 53
     388:	82 60       	ori	r24, 0x02	; 2
     38a:	85 bf       	out	0x35, r24	; 53
	GICR = GICR | 0x40;
     38c:	8b b7       	in	r24, 0x3b	; 59
     38e:	80 64       	ori	r24, 0x40	; 64
     390:	8b bf       	out	0x3b, r24	; 59
}
     392:	08 95       	ret

00000394 <lcd_port_config>:

void lcd_port_config (void)
{
	DDRC = DDRC | 0xF7;    //all the LCD pin's direction set as output
     394:	84 b3       	in	r24, 0x14	; 20
     396:	87 6f       	ori	r24, 0xF7	; 247
     398:	84 bb       	out	0x14, r24	; 20
	PORTC = PORTC & 0x80;  // all the LCD pins are set to logic 0 except PORTC 7
     39a:	85 b3       	in	r24, 0x15	; 21
     39c:	80 78       	andi	r24, 0x80	; 128
     39e:	85 bb       	out	0x15, r24	; 21
}
     3a0:	08 95       	ret

000003a2 <port_init>:
  * Example Call: port_init()
  */

void port_init(void)
{
	 motion_pin_config();
     3a2:	0e 94 9c 01 	call	0x338	; 0x338 <motion_pin_config>
	 buzzer_pin_config();
     3a6:	0e 94 b9 01 	call	0x372	; 0x372 <buzzer_pin_config>
	 uart0_init();
     3aa:	0e 94 a9 01 	call	0x352	; 0x352 <uart0_init>
	 left_encoder_pin_config();
     3ae:	0e 94 b3 01 	call	0x366	; 0x366 <left_encoder_pin_config>
	 right_encoder_pin_config();
     3b2:	0e 94 b6 01 	call	0x36c	; 0x36c <right_encoder_pin_config>
	 adc_pin_config();
     3b6:	0e 94 79 01 	call	0x2f2	; 0x2f2 <adc_pin_config>
	 color_sensor_pin_config();
     3ba:	0e 94 70 01 	call	0x2e0	; 0x2e0 <color_sensor_pin_config>
	 rgb_led_pin_config();
     3be:	0e 94 69 01 	call	0x2d2	; 0x2d2 <rgb_led_pin_config>
}
     3c2:	08 95       	ret

000003c4 <init_devices>:
  * Example Call: init_devices()
  */ 

void init_devices (void)
{
	cli(); //Clears the global interrupts
     3c4:	f8 94       	cli
	port_init();
     3c6:	0e 94 d1 01 	call	0x3a2	; 0x3a2 <port_init>
	timer1_init();
     3ca:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <timer1_init>
	adc_init();
     3ce:	0e 94 94 01 	call	0x328	; 0x328 <adc_init>
	left_position_encoder_interrupt_init();
     3d2:	0e 94 c3 01 	call	0x386	; 0x386 <left_position_encoder_interrupt_init>
	right_position_encoder_interrupt_init();
     3d6:	0e 94 bc 01 	call	0x378	; 0x378 <right_position_encoder_interrupt_init>
	set_servo();
     3da:	0e 94 8c 01 	call	0x318	; 0x318 <set_servo>
	sei(); //Enables the global interrupts
     3de:	78 94       	sei
}
     3e0:	08 95       	ret

000003e2 <ADC_Conversion>:
  */

unsigned char ADC_Conversion(unsigned char Ch)
{
	unsigned char a;
	Ch = Ch & 0x07;
     3e2:	87 70       	andi	r24, 0x07	; 7
	ADMUX= 0x20| Ch;
     3e4:	80 62       	ori	r24, 0x20	; 32
     3e6:	87 b9       	out	0x07, r24	; 7
	ADCSRA = ADCSRA | 0x40;	//Set start conversion bit
     3e8:	36 9a       	sbi	0x06, 6	; 6
	while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
     3ea:	34 9b       	sbis	0x06, 4	; 6
     3ec:	fe cf       	rjmp	.-4      	; 0x3ea <ADC_Conversion+0x8>
	a=ADCH;
     3ee:	85 b1       	in	r24, 0x05	; 5
	ADCSRA = ADCSRA|0x10;      //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     3f0:	34 9a       	sbi	0x06, 4	; 6
	return a;
}
     3f2:	08 95       	ret

000003f4 <buzzer_on>:
  */

void buzzer_on (void)
{
	unsigned char port_restore = 0;
	port_restore = PINC;
     3f4:	83 b3       	in	r24, 0x13	; 19
	port_restore = port_restore | 0x08;
     3f6:	88 60       	ori	r24, 0x08	; 8
	PORTC = port_restore;
     3f8:	85 bb       	out	0x15, r24	; 21
}
     3fa:	08 95       	ret

000003fc <buzzer_off>:
  */

void buzzer_off (void)
{
	unsigned char port_restore = 0;
	port_restore = PINC;
     3fc:	83 b3       	in	r24, 0x13	; 19
	port_restore = port_restore & 0xF7;
     3fe:	87 7f       	andi	r24, 0xF7	; 247
	PORTC = port_restore;
     400:	85 bb       	out	0x15, r24	; 21
}
     402:	08 95       	ret

00000404 <buzz>:
  * Example Call: buzz()
  */

void buzz()
{
	buzzer_on();
     404:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <buzzer_on>
     408:	8f ef       	ldi	r24, 0xFF	; 255
     40a:	9f e3       	ldi	r25, 0x3F	; 63
     40c:	a2 e0       	ldi	r26, 0x02	; 2
     40e:	81 50       	subi	r24, 0x01	; 1
     410:	90 40       	sbci	r25, 0x00	; 0
     412:	a0 40       	sbci	r26, 0x00	; 0
     414:	e1 f7       	brne	.-8      	; 0x40e <buzz+0xa>
     416:	00 c0       	rjmp	.+0      	; 0x418 <buzz+0x14>
     418:	00 00       	nop
	_delay_ms(100);
	buzzer_off();
     41a:	0e 94 fe 01 	call	0x3fc	; 0x3fc <buzzer_off>
}
     41e:	08 95       	ret

00000420 <run_home>:
  * Logic: This function is used for following the Dijkstra path sent over xbee by firebird V.
  * Example Call: run_home()
  */

void run_home()
{
     420:	2f 92       	push	r2
     422:	3f 92       	push	r3
     424:	4f 92       	push	r4
     426:	5f 92       	push	r5
     428:	6f 92       	push	r6
     42a:	7f 92       	push	r7
     42c:	8f 92       	push	r8
     42e:	9f 92       	push	r9
     430:	af 92       	push	r10
     432:	bf 92       	push	r11
     434:	cf 92       	push	r12
     436:	df 92       	push	r13
     438:	ef 92       	push	r14
     43a:	ff 92       	push	r15
     43c:	0f 93       	push	r16
     43e:	1f 93       	push	r17
     440:	cf 93       	push	r28
     442:	df 93       	push	r29
     444:	cd b7       	in	r28, 0x3d	; 61
     446:	de b7       	in	r29, 0x3e	; 62
     448:	28 97       	sbiw	r28, 0x08	; 8
     44a:	0f b6       	in	r0, 0x3f	; 63
     44c:	f8 94       	cli
     44e:	de bf       	out	0x3e, r29	; 62
     450:	0f be       	out	0x3f, r0	; 63
     452:	cd bf       	out	0x3d, r28	; 61
	int temp;
	if(orient==0)
     454:	80 91 f6 00 	lds	r24, 0x00F6
     458:	90 91 f7 00 	lds	r25, 0x00F7
     45c:	00 97       	sbiw	r24, 0x00	; 0
     45e:	39 f4       	brne	.+14     	; 0x46e <__stack+0xf>
	temp=initial_home_run[0]+7;
     460:	00 91 bb 00 	lds	r16, 0x00BB
     464:	10 91 bc 00 	lds	r17, 0x00BC
     468:	09 5f       	subi	r16, 0xF9	; 249
     46a:	1f 4f       	sbci	r17, 0xFF	; 255
     46c:	29 c0       	rjmp	.+82     	; 0x4c0 <__stack+0x61>
	else if(orient==1)
     46e:	80 91 f6 00 	lds	r24, 0x00F6
     472:	90 91 f7 00 	lds	r25, 0x00F7
     476:	81 30       	cpi	r24, 0x01	; 1
     478:	91 05       	cpc	r25, r1
     47a:	39 f4       	brne	.+14     	; 0x48a <__stack+0x2b>
	temp=initial_home_run[0]-1;
     47c:	00 91 bb 00 	lds	r16, 0x00BB
     480:	10 91 bc 00 	lds	r17, 0x00BC
     484:	01 50       	subi	r16, 0x01	; 1
     486:	10 40       	sbci	r17, 0x00	; 0
     488:	1b c0       	rjmp	.+54     	; 0x4c0 <__stack+0x61>
	else if(orient==2)
     48a:	80 91 f6 00 	lds	r24, 0x00F6
     48e:	90 91 f7 00 	lds	r25, 0x00F7
     492:	82 30       	cpi	r24, 0x02	; 2
     494:	91 05       	cpc	r25, r1
     496:	39 f4       	brne	.+14     	; 0x4a6 <__stack+0x47>
	temp=initial_home_run[0]-7;
     498:	00 91 bb 00 	lds	r16, 0x00BB
     49c:	10 91 bc 00 	lds	r17, 0x00BC
     4a0:	07 50       	subi	r16, 0x07	; 7
     4a2:	10 40       	sbci	r17, 0x00	; 0
     4a4:	0d c0       	rjmp	.+26     	; 0x4c0 <__stack+0x61>
	else if(orient==3)
     4a6:	80 91 f6 00 	lds	r24, 0x00F6
     4aa:	90 91 f7 00 	lds	r25, 0x00F7
     4ae:	83 30       	cpi	r24, 0x03	; 3
     4b0:	91 05       	cpc	r25, r1
     4b2:	31 f4       	brne	.+12     	; 0x4c0 <__stack+0x61>
	temp=initial_home_run[0]+1;
     4b4:	00 91 bb 00 	lds	r16, 0x00BB
     4b8:	10 91 bc 00 	lds	r17, 0x00BC
     4bc:	0f 5f       	subi	r16, 0xFF	; 255
     4be:	1f 4f       	sbci	r17, 0xFF	; 255
	
	shiftr(temp);
     4c0:	c8 01       	movw	r24, r16
     4c2:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <shiftr>
	curr_pos = temp;
     4c6:	10 93 b3 00 	sts	0x00B3, r17
     4ca:	00 93 b2 00 	sts	0x00B2, r16
	
	int prev,present,next,m;
	prev=initial_home_run[0];
     4ce:	20 91 bb 00 	lds	r18, 0x00BB
     4d2:	30 91 bc 00 	lds	r19, 0x00BC
     4d6:	3e 83       	std	Y+6, r19	; 0x06
     4d8:	2d 83       	std	Y+5, r18	; 0x05
	present=initial_home_run[1];
     4da:	40 91 bd 00 	lds	r20, 0x00BD
     4de:	50 91 be 00 	lds	r21, 0x00BE
     4e2:	5c 83       	std	Y+4, r21	; 0x04
     4e4:	4b 83       	std	Y+3, r20	; 0x03
	next=initial_home_run[2];
     4e6:	80 91 bf 00 	lds	r24, 0x00BF
     4ea:	90 91 c0 00 	lds	r25, 0x00C0
     4ee:	9a 83       	std	Y+2, r25	; 0x02
     4f0:	89 83       	std	Y+1, r24	; 0x01
	m=1;
     4f2:	66 24       	eor	r6, r6
     4f4:	77 24       	eor	r7, r7
     4f6:	63 94       	inc	r6
		present=initial_home_run[m];
		next=initial_home_run[m+1];
	}*/
	
	
	while(initial_home_run[m]!=99)
     4f8:	0f 2e       	mov	r0, r31
     4fa:	fb eb       	ldi	r31, 0xBB	; 187
     4fc:	4f 2e       	mov	r4, r31
     4fe:	f0 e0       	ldi	r31, 0x00	; 0
     500:	5f 2e       	mov	r5, r31
     502:	f0 2d       	mov	r31, r0
		if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
		if (rightMotorSpeed < 0) rightMotorSpeed = 0;
		if (leftMotorSpeed < 0) leftMotorSpeed = 0;

		forward();
		velocity(leftMotorSpeed,rightMotorSpeed);
     504:	22 24       	eor	r2, r2
     506:	33 24       	eor	r3, r3
		present=initial_home_run[m];
		next=initial_home_run[m+1];
	}*/
	
	
	while(initial_home_run[m]!=99)
     508:	c6 c1       	rjmp	.+908    	; 0x896 <__stack+0x437>
	{
		Left_white_line = ADC_Conversion(3);
     50a:	83 e0       	ldi	r24, 0x03	; 3
     50c:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     510:	80 93 77 00 	sts	0x0077, r24
		Center_white_line = ADC_Conversion(4);
     514:	84 e0       	ldi	r24, 0x04	; 4
     516:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     51a:	80 93 76 00 	sts	0x0076, r24
		Right_white_line = ADC_Conversion(5);
     51e:	85 e0       	ldi	r24, 0x05	; 5
     520:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     524:	80 93 75 00 	sts	0x0075, r24
		error = Right_white_line - Left_white_line;
     528:	90 e0       	ldi	r25, 0x00	; 0
     52a:	20 91 77 00 	lds	r18, 0x0077
     52e:	82 1b       	sub	r24, r18
     530:	91 09       	sbc	r25, r1
     532:	90 93 13 01 	sts	0x0113, r25
     536:	80 93 12 01 	sts	0x0112, r24
		int motorSpeed = Kp * error + Kd * (error - lastError);
     53a:	60 91 12 01 	lds	r22, 0x0112
     53e:	70 91 13 01 	lds	r23, 0x0113
     542:	c0 90 67 00 	lds	r12, 0x0067
     546:	d0 90 68 00 	lds	r13, 0x0068
     54a:	e0 90 69 00 	lds	r14, 0x0069
     54e:	f0 90 6a 00 	lds	r15, 0x006A
     552:	a0 91 12 01 	lds	r26, 0x0112
     556:	b0 91 13 01 	lds	r27, 0x0113
     55a:	b8 87       	std	Y+8, r27	; 0x08
     55c:	af 83       	std	Y+7, r26	; 0x07
     55e:	00 91 78 00 	lds	r16, 0x0078
     562:	10 91 79 00 	lds	r17, 0x0079
     566:	80 90 63 00 	lds	r8, 0x0063
     56a:	90 90 64 00 	lds	r9, 0x0064
     56e:	a0 90 65 00 	lds	r10, 0x0065
     572:	b0 90 66 00 	lds	r11, 0x0066
     576:	88 27       	eor	r24, r24
     578:	77 fd       	sbrc	r23, 7
     57a:	80 95       	com	r24
     57c:	98 2f       	mov	r25, r24
     57e:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__floatsisf>
     582:	a7 01       	movw	r20, r14
     584:	96 01       	movw	r18, r12
     586:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <__mulsf3>
     58a:	6b 01       	movw	r12, r22
     58c:	7c 01       	movw	r14, r24
     58e:	6f 81       	ldd	r22, Y+7	; 0x07
     590:	78 85       	ldd	r23, Y+8	; 0x08
     592:	60 1b       	sub	r22, r16
     594:	71 0b       	sbc	r23, r17
     596:	88 27       	eor	r24, r24
     598:	77 fd       	sbrc	r23, 7
     59a:	80 95       	com	r24
     59c:	98 2f       	mov	r25, r24
     59e:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__floatsisf>
     5a2:	a5 01       	movw	r20, r10
     5a4:	94 01       	movw	r18, r8
     5a6:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <__mulsf3>
     5aa:	9b 01       	movw	r18, r22
     5ac:	ac 01       	movw	r20, r24
     5ae:	c7 01       	movw	r24, r14
     5b0:	b6 01       	movw	r22, r12
     5b2:	0e 94 71 17 	call	0x2ee2	; 0x2ee2 <__addsf3>
     5b6:	0e 94 3d 18 	call	0x307a	; 0x307a <__fixsfsi>
     5ba:	dc 01       	movw	r26, r24
     5bc:	cb 01       	movw	r24, r22
		lastError = error;
     5be:	20 91 12 01 	lds	r18, 0x0112
     5c2:	30 91 13 01 	lds	r19, 0x0113
     5c6:	30 93 79 00 	sts	0x0079, r19
     5ca:	20 93 78 00 	sts	0x0078, r18
		int rightMotorSpeed = rightBaseSpeed - motorSpeed;
     5ce:	00 91 62 00 	lds	r16, 0x0062
     5d2:	10 e0       	ldi	r17, 0x00	; 0
		int leftMotorSpeed = leftBaseSpeed + motorSpeed;
     5d4:	20 91 61 00 	lds	r18, 0x0061
     5d8:	6c 01       	movw	r12, r24
     5da:	c2 0e       	add	r12, r18
     5dc:	d1 1c       	adc	r13, r1
     5de:	08 1b       	sub	r16, r24
     5e0:	19 0b       	sbc	r17, r25
     5e2:	0e 32       	cpi	r16, 0x2E	; 46
     5e4:	11 05       	cpc	r17, r1
     5e6:	14 f0       	brlt	.+4      	; 0x5ec <__stack+0x18d>
     5e8:	0d e2       	ldi	r16, 0x2D	; 45
     5ea:	10 e0       	ldi	r17, 0x00	; 0
     5ec:	be e2       	ldi	r27, 0x2E	; 46
     5ee:	cb 16       	cp	r12, r27
     5f0:	d1 04       	cpc	r13, r1
     5f2:	2c f0       	brlt	.+10     	; 0x5fe <__stack+0x19f>
     5f4:	0f 2e       	mov	r0, r31
     5f6:	fd e2       	ldi	r31, 0x2D	; 45
     5f8:	cf 2e       	mov	r12, r31
     5fa:	dd 24       	eor	r13, r13
     5fc:	f0 2d       	mov	r31, r0
		if (rightMotorSpeed > rightMaxSpeed ) rightMotorSpeed = rightMaxSpeed;
		if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
		if (rightMotorSpeed < 0) rightMotorSpeed = 0;
		if (leftMotorSpeed < 0) leftMotorSpeed = 0;

		forward();
     5fe:	0e 94 28 0b 	call	0x1650	; 0x1650 <forward>
		velocity(leftMotorSpeed,rightMotorSpeed);
     602:	c6 01       	movw	r24, r12
     604:	99 23       	and	r25, r25
     606:	0c f4       	brge	.+2      	; 0x60a <__stack+0x1ab>
     608:	c1 01       	movw	r24, r2
     60a:	b8 01       	movw	r22, r16
     60c:	11 23       	and	r17, r17
     60e:	0c f4       	brge	.+2      	; 0x612 <__stack+0x1b3>
     610:	b1 01       	movw	r22, r2
     612:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>

		if(Center_white_line>40 && Left_white_line>40 && Right_white_line>40)
     616:	80 91 76 00 	lds	r24, 0x0076
     61a:	89 32       	cpi	r24, 0x29	; 41
     61c:	08 f4       	brcc	.+2      	; 0x620 <__stack+0x1c1>
     61e:	3b c1       	rjmp	.+630    	; 0x896 <__stack+0x437>
     620:	80 91 77 00 	lds	r24, 0x0077
     624:	89 32       	cpi	r24, 0x29	; 41
     626:	08 f4       	brcc	.+2      	; 0x62a <__stack+0x1cb>
     628:	36 c1       	rjmp	.+620    	; 0x896 <__stack+0x437>
     62a:	80 91 75 00 	lds	r24, 0x0075
     62e:	89 32       	cpi	r24, 0x29	; 41
     630:	08 f4       	brcc	.+2      	; 0x634 <__stack+0x1d5>
     632:	31 c1       	rjmp	.+610    	; 0x896 <__stack+0x437>
		{
			update_curr_pos();
     634:	0e 94 8f 00 	call	0x11e	; 0x11e <update_curr_pos>
			
			//velocity(40,40);
			//_delay_ms(300);
			//just_forward();
			stop();
     638:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <stop>
			buzz();
     63c:	0e 94 02 02 	call	0x404	; 0x404 <buzz>
			
			if(next==99)
     640:	e9 81       	ldd	r30, Y+1	; 0x01
     642:	fa 81       	ldd	r31, Y+2	; 0x02
     644:	e3 36       	cpi	r30, 0x63	; 99
     646:	f1 05       	cpc	r31, r1
     648:	09 f4       	brne	.+2      	; 0x64c <__stack+0x1ed>
     64a:	32 c1       	rjmp	.+612    	; 0x8b0 <__stack+0x451>
			{
				break;
			}
			
			if(next-present==1)
     64c:	cf 01       	movw	r24, r30
     64e:	2b 81       	ldd	r18, Y+3	; 0x03
     650:	3c 81       	ldd	r19, Y+4	; 0x04
     652:	82 1b       	sub	r24, r18
     654:	93 0b       	sbc	r25, r19
     656:	81 30       	cpi	r24, 0x01	; 1
     658:	91 05       	cpc	r25, r1
     65a:	09 f0       	breq	.+2      	; 0x65e <__stack+0x1ff>
     65c:	43 c0       	rjmp	.+134    	; 0x6e4 <__stack+0x285>
			{
				if(present-prev==1)
     65e:	89 01       	movw	r16, r18
     660:	4d 81       	ldd	r20, Y+5	; 0x05
     662:	5e 81       	ldd	r21, Y+6	; 0x06
     664:	04 1b       	sub	r16, r20
     666:	15 0b       	sbc	r17, r21
     668:	01 30       	cpi	r16, 0x01	; 1
     66a:	11 05       	cpc	r17, r1
     66c:	19 f4       	brne	.+6      	; 0x674 <__stack+0x215>
				//forward();
				just_forward();
     66e:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
     672:	0d c0       	rjmp	.+26     	; 0x68e <__stack+0x22f>
				if(present-prev==7)
     674:	07 30       	cpi	r16, 0x07	; 7
     676:	11 05       	cpc	r17, r1
     678:	19 f4       	brne	.+6      	; 0x680 <__stack+0x221>
				//turn(0);
				turn_left();
     67a:	0e 94 3d 01 	call	0x27a	; 0x27a <turn_left>
     67e:	0d c0       	rjmp	.+26     	; 0x69a <__stack+0x23b>
				if(present-prev==-7)
     680:	5f ef       	ldi	r21, 0xFF	; 255
     682:	09 3f       	cpi	r16, 0xF9	; 249
     684:	15 07       	cpc	r17, r21
     686:	19 f4       	brne	.+6      	; 0x68e <__stack+0x22f>
				//turn(1);
				turn_right();
     688:	0e 94 27 01 	call	0x24e	; 0x24e <turn_right>
     68c:	06 c0       	rjmp	.+12     	; 0x69a <__stack+0x23b>
				if(present-prev==-1)
     68e:	8f ef       	ldi	r24, 0xFF	; 255
     690:	0f 3f       	cpi	r16, 0xFF	; 255
     692:	18 07       	cpc	r17, r24
     694:	11 f4       	brne	.+4      	; 0x69a <__stack+0x23b>
				{
					//turn(1);
					//turn(1);
					turn_reverse();
     696:	0e 94 53 01 	call	0x2a6	; 0x2a6 <turn_reverse>
				}
				
				m++;
     69a:	93 01       	movw	r18, r6
     69c:	2f 5f       	subi	r18, 0xFF	; 255
     69e:	3f 4f       	sbci	r19, 0xFF	; 255
				prev=initial_home_run[m-1];
     6a0:	f3 01       	movw	r30, r6
     6a2:	ee 0f       	add	r30, r30
     6a4:	ff 1f       	adc	r31, r31
     6a6:	e4 0d       	add	r30, r4
     6a8:	f5 1d       	adc	r31, r5
     6aa:	a0 81       	ld	r26, Z
     6ac:	b1 81       	ldd	r27, Z+1	; 0x01
     6ae:	be 83       	std	Y+6, r27	; 0x06
     6b0:	ad 83       	std	Y+5, r26	; 0x05
				present=initial_home_run[m];
     6b2:	c9 01       	movw	r24, r18
     6b4:	88 0f       	add	r24, r24
     6b6:	99 1f       	adc	r25, r25
     6b8:	84 0d       	add	r24, r4
     6ba:	95 1d       	adc	r25, r5
     6bc:	fc 01       	movw	r30, r24
     6be:	01 90       	ld	r0, Z+
     6c0:	f0 81       	ld	r31, Z
     6c2:	e0 2d       	mov	r30, r0
     6c4:	fc 83       	std	Y+4, r31	; 0x04
     6c6:	eb 83       	std	Y+3, r30	; 0x03
				next=initial_home_run[m+1];
     6c8:	c3 01       	movw	r24, r6
     6ca:	02 96       	adiw	r24, 0x02	; 2
     6cc:	88 0f       	add	r24, r24
     6ce:	99 1f       	adc	r25, r25
     6d0:	84 0d       	add	r24, r4
     6d2:	95 1d       	adc	r25, r5
     6d4:	dc 01       	movw	r26, r24
     6d6:	0d 90       	ld	r0, X+
     6d8:	bc 91       	ld	r27, X
     6da:	a0 2d       	mov	r26, r0
     6dc:	ba 83       	std	Y+2, r27	; 0x02
     6de:	a9 83       	std	Y+1, r26	; 0x01
					//turn(1);
					//turn(1);
					turn_reverse();
				}
				
				m++;
     6e0:	39 01       	movw	r6, r18
     6e2:	d9 c0       	rjmp	.+434    	; 0x896 <__stack+0x437>
				prev=initial_home_run[m-1];
				present=initial_home_run[m];
				next=initial_home_run[m+1];
			}
			
			else if(next-present==7)
     6e4:	87 30       	cpi	r24, 0x07	; 7
     6e6:	91 05       	cpc	r25, r1
     6e8:	09 f0       	breq	.+2      	; 0x6ec <__stack+0x28d>
     6ea:	44 c0       	rjmp	.+136    	; 0x774 <__stack+0x315>
			{
				if(present-prev==7)
     6ec:	0b 81       	ldd	r16, Y+3	; 0x03
     6ee:	1c 81       	ldd	r17, Y+4	; 0x04
     6f0:	ed 81       	ldd	r30, Y+5	; 0x05
     6f2:	fe 81       	ldd	r31, Y+6	; 0x06
     6f4:	0e 1b       	sub	r16, r30
     6f6:	1f 0b       	sbc	r17, r31
     6f8:	07 30       	cpi	r16, 0x07	; 7
     6fa:	11 05       	cpc	r17, r1
     6fc:	19 f4       	brne	.+6      	; 0x704 <__stack+0x2a5>
				//forward();
				just_forward();
     6fe:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
     702:	0d c0       	rjmp	.+26     	; 0x71e <__stack+0x2bf>
				if(present-prev==-1)
     704:	ff ef       	ldi	r31, 0xFF	; 255
     706:	0f 3f       	cpi	r16, 0xFF	; 255
     708:	1f 07       	cpc	r17, r31
     70a:	19 f4       	brne	.+6      	; 0x712 <__stack+0x2b3>
				//turn(0);
				turn_left();
     70c:	0e 94 3d 01 	call	0x27a	; 0x27a <turn_left>
     710:	0c c0       	rjmp	.+24     	; 0x72a <__stack+0x2cb>
				if(present-prev==1)
     712:	01 30       	cpi	r16, 0x01	; 1
     714:	11 05       	cpc	r17, r1
     716:	19 f4       	brne	.+6      	; 0x71e <__stack+0x2bf>
				//turn(1);
				turn_right();
     718:	0e 94 27 01 	call	0x24e	; 0x24e <turn_right>
     71c:	06 c0       	rjmp	.+12     	; 0x72a <__stack+0x2cb>
				if(present-prev==-7)
     71e:	2f ef       	ldi	r18, 0xFF	; 255
     720:	09 3f       	cpi	r16, 0xF9	; 249
     722:	12 07       	cpc	r17, r18
     724:	11 f4       	brne	.+4      	; 0x72a <__stack+0x2cb>
				{
					//turn(1);
					//turn(1);
					turn_reverse();
     726:	0e 94 53 01 	call	0x2a6	; 0x2a6 <turn_reverse>
				}
				
				m++;
     72a:	93 01       	movw	r18, r6
     72c:	2f 5f       	subi	r18, 0xFF	; 255
     72e:	3f 4f       	sbci	r19, 0xFF	; 255
				prev=initial_home_run[m-1];
     730:	f3 01       	movw	r30, r6
     732:	ee 0f       	add	r30, r30
     734:	ff 1f       	adc	r31, r31
     736:	e4 0d       	add	r30, r4
     738:	f5 1d       	adc	r31, r5
     73a:	40 81       	ld	r20, Z
     73c:	51 81       	ldd	r21, Z+1	; 0x01
     73e:	5e 83       	std	Y+6, r21	; 0x06
     740:	4d 83       	std	Y+5, r20	; 0x05
				present=initial_home_run[m];
     742:	c9 01       	movw	r24, r18
     744:	88 0f       	add	r24, r24
     746:	99 1f       	adc	r25, r25
     748:	84 0d       	add	r24, r4
     74a:	95 1d       	adc	r25, r5
     74c:	dc 01       	movw	r26, r24
     74e:	0d 90       	ld	r0, X+
     750:	bc 91       	ld	r27, X
     752:	a0 2d       	mov	r26, r0
     754:	bc 83       	std	Y+4, r27	; 0x04
     756:	ab 83       	std	Y+3, r26	; 0x03
				next=initial_home_run[m+1];
     758:	c3 01       	movw	r24, r6
     75a:	02 96       	adiw	r24, 0x02	; 2
     75c:	88 0f       	add	r24, r24
     75e:	99 1f       	adc	r25, r25
     760:	84 0d       	add	r24, r4
     762:	95 1d       	adc	r25, r5
     764:	fc 01       	movw	r30, r24
     766:	01 90       	ld	r0, Z+
     768:	f0 81       	ld	r31, Z
     76a:	e0 2d       	mov	r30, r0
     76c:	fa 83       	std	Y+2, r31	; 0x02
     76e:	e9 83       	std	Y+1, r30	; 0x01
					//turn(1);
					//turn(1);
					turn_reverse();
				}
				
				m++;
     770:	39 01       	movw	r6, r18
     772:	91 c0       	rjmp	.+290    	; 0x896 <__stack+0x437>
				prev=initial_home_run[m-1];
				present=initial_home_run[m];
				next=initial_home_run[m+1];
			}
			
			else if(next-present==-7)
     774:	ff ef       	ldi	r31, 0xFF	; 255
     776:	89 3f       	cpi	r24, 0xF9	; 249
     778:	9f 07       	cpc	r25, r31
     77a:	09 f0       	breq	.+2      	; 0x77e <__stack+0x31f>
     77c:	44 c0       	rjmp	.+136    	; 0x806 <__stack+0x3a7>
			{
				if(present-prev==-7)
     77e:	0b 81       	ldd	r16, Y+3	; 0x03
     780:	1c 81       	ldd	r17, Y+4	; 0x04
     782:	2d 81       	ldd	r18, Y+5	; 0x05
     784:	3e 81       	ldd	r19, Y+6	; 0x06
     786:	02 1b       	sub	r16, r18
     788:	13 0b       	sbc	r17, r19
     78a:	3f ef       	ldi	r19, 0xFF	; 255
     78c:	09 3f       	cpi	r16, 0xF9	; 249
     78e:	13 07       	cpc	r17, r19
     790:	19 f4       	brne	.+6      	; 0x798 <__stack+0x339>
				//forward();
				just_forward();
     792:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
     796:	0d c0       	rjmp	.+26     	; 0x7b2 <__stack+0x353>
				if(present-prev==1)
     798:	01 30       	cpi	r16, 0x01	; 1
     79a:	11 05       	cpc	r17, r1
     79c:	19 f4       	brne	.+6      	; 0x7a4 <__stack+0x345>
				//turn(0);
				turn_left();
     79e:	0e 94 3d 01 	call	0x27a	; 0x27a <turn_left>
     7a2:	0c c0       	rjmp	.+24     	; 0x7bc <__stack+0x35d>
				if(present-prev==-1)
     7a4:	4f ef       	ldi	r20, 0xFF	; 255
     7a6:	0f 3f       	cpi	r16, 0xFF	; 255
     7a8:	14 07       	cpc	r17, r20
     7aa:	19 f4       	brne	.+6      	; 0x7b2 <__stack+0x353>
				//turn(1);
				turn_right();
     7ac:	0e 94 27 01 	call	0x24e	; 0x24e <turn_right>
     7b0:	05 c0       	rjmp	.+10     	; 0x7bc <__stack+0x35d>
				if(present-prev==7)
     7b2:	07 30       	cpi	r16, 0x07	; 7
     7b4:	11 05       	cpc	r17, r1
     7b6:	11 f4       	brne	.+4      	; 0x7bc <__stack+0x35d>
				{
					//turn(1);
					//turn(1);
					turn_reverse();
     7b8:	0e 94 53 01 	call	0x2a6	; 0x2a6 <turn_reverse>
				}
				
				m=m+1;
     7bc:	93 01       	movw	r18, r6
     7be:	2f 5f       	subi	r18, 0xFF	; 255
     7c0:	3f 4f       	sbci	r19, 0xFF	; 255
				prev=initial_home_run[m-1];
     7c2:	f3 01       	movw	r30, r6
     7c4:	ee 0f       	add	r30, r30
     7c6:	ff 1f       	adc	r31, r31
     7c8:	e4 0d       	add	r30, r4
     7ca:	f5 1d       	adc	r31, r5
     7cc:	80 81       	ld	r24, Z
     7ce:	91 81       	ldd	r25, Z+1	; 0x01
     7d0:	9e 83       	std	Y+6, r25	; 0x06
     7d2:	8d 83       	std	Y+5, r24	; 0x05
				present=initial_home_run[m];
     7d4:	c9 01       	movw	r24, r18
     7d6:	88 0f       	add	r24, r24
     7d8:	99 1f       	adc	r25, r25
     7da:	84 0d       	add	r24, r4
     7dc:	95 1d       	adc	r25, r5
     7de:	dc 01       	movw	r26, r24
     7e0:	0d 90       	ld	r0, X+
     7e2:	bc 91       	ld	r27, X
     7e4:	a0 2d       	mov	r26, r0
     7e6:	bc 83       	std	Y+4, r27	; 0x04
     7e8:	ab 83       	std	Y+3, r26	; 0x03
				next=initial_home_run[m+1];
     7ea:	c3 01       	movw	r24, r6
     7ec:	02 96       	adiw	r24, 0x02	; 2
     7ee:	88 0f       	add	r24, r24
     7f0:	99 1f       	adc	r25, r25
     7f2:	84 0d       	add	r24, r4
     7f4:	95 1d       	adc	r25, r5
     7f6:	fc 01       	movw	r30, r24
     7f8:	01 90       	ld	r0, Z+
     7fa:	f0 81       	ld	r31, Z
     7fc:	e0 2d       	mov	r30, r0
     7fe:	fa 83       	std	Y+2, r31	; 0x02
     800:	e9 83       	std	Y+1, r30	; 0x01
					//turn(1);
					//turn(1);
					turn_reverse();
				}
				
				m=m+1;
     802:	39 01       	movw	r6, r18
     804:	48 c0       	rjmp	.+144    	; 0x896 <__stack+0x437>
				prev=initial_home_run[m-1];
				present=initial_home_run[m];
				next=initial_home_run[m+1];
			}
			
			else if(next-present==-1)
     806:	ff ef       	ldi	r31, 0xFF	; 255
     808:	8f 3f       	cpi	r24, 0xFF	; 255
     80a:	9f 07       	cpc	r25, r31
     80c:	09 f0       	breq	.+2      	; 0x810 <__stack+0x3b1>
     80e:	43 c0       	rjmp	.+134    	; 0x896 <__stack+0x437>
			{
				if(present-prev==-1)
     810:	0b 81       	ldd	r16, Y+3	; 0x03
     812:	1c 81       	ldd	r17, Y+4	; 0x04
     814:	2d 81       	ldd	r18, Y+5	; 0x05
     816:	3e 81       	ldd	r19, Y+6	; 0x06
     818:	02 1b       	sub	r16, r18
     81a:	13 0b       	sbc	r17, r19
     81c:	3f ef       	ldi	r19, 0xFF	; 255
     81e:	0f 3f       	cpi	r16, 0xFF	; 255
     820:	13 07       	cpc	r17, r19
     822:	19 f4       	brne	.+6      	; 0x82a <__stack+0x3cb>
				//forward();
				just_forward();
     824:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
     828:	0d c0       	rjmp	.+26     	; 0x844 <__stack+0x3e5>
				if(present-prev==-7)
     82a:	4f ef       	ldi	r20, 0xFF	; 255
     82c:	09 3f       	cpi	r16, 0xF9	; 249
     82e:	14 07       	cpc	r17, r20
     830:	19 f4       	brne	.+6      	; 0x838 <__stack+0x3d9>
				//turn(0);
				turn_left();
     832:	0e 94 3d 01 	call	0x27a	; 0x27a <turn_left>
     836:	0b c0       	rjmp	.+22     	; 0x84e <__stack+0x3ef>
				if(present-prev==7)
     838:	07 30       	cpi	r16, 0x07	; 7
     83a:	11 05       	cpc	r17, r1
     83c:	19 f4       	brne	.+6      	; 0x844 <__stack+0x3e5>
				//turn(1);
				turn_right();
     83e:	0e 94 27 01 	call	0x24e	; 0x24e <turn_right>
     842:	05 c0       	rjmp	.+10     	; 0x84e <__stack+0x3ef>
				if(present-prev==1)
     844:	01 30       	cpi	r16, 0x01	; 1
     846:	11 05       	cpc	r17, r1
     848:	11 f4       	brne	.+4      	; 0x84e <__stack+0x3ef>
				{
					//turn(1);
					//turn(1);
					turn_reverse();
     84a:	0e 94 53 01 	call	0x2a6	; 0x2a6 <turn_reverse>
				}

				m=m+1;
     84e:	93 01       	movw	r18, r6
     850:	2f 5f       	subi	r18, 0xFF	; 255
     852:	3f 4f       	sbci	r19, 0xFF	; 255
				prev=initial_home_run[m-1];
     854:	f3 01       	movw	r30, r6
     856:	ee 0f       	add	r30, r30
     858:	ff 1f       	adc	r31, r31
     85a:	e4 0d       	add	r30, r4
     85c:	f5 1d       	adc	r31, r5
     85e:	80 81       	ld	r24, Z
     860:	91 81       	ldd	r25, Z+1	; 0x01
     862:	9e 83       	std	Y+6, r25	; 0x06
     864:	8d 83       	std	Y+5, r24	; 0x05
				present=initial_home_run[m];
     866:	c9 01       	movw	r24, r18
     868:	88 0f       	add	r24, r24
     86a:	99 1f       	adc	r25, r25
     86c:	84 0d       	add	r24, r4
     86e:	95 1d       	adc	r25, r5
     870:	dc 01       	movw	r26, r24
     872:	0d 90       	ld	r0, X+
     874:	bc 91       	ld	r27, X
     876:	a0 2d       	mov	r26, r0
     878:	bc 83       	std	Y+4, r27	; 0x04
     87a:	ab 83       	std	Y+3, r26	; 0x03
				next=initial_home_run[m+1];
     87c:	c3 01       	movw	r24, r6
     87e:	02 96       	adiw	r24, 0x02	; 2
     880:	88 0f       	add	r24, r24
     882:	99 1f       	adc	r25, r25
     884:	84 0d       	add	r24, r4
     886:	95 1d       	adc	r25, r5
     888:	fc 01       	movw	r30, r24
     88a:	01 90       	ld	r0, Z+
     88c:	f0 81       	ld	r31, Z
     88e:	e0 2d       	mov	r30, r0
     890:	fa 83       	std	Y+2, r31	; 0x02
     892:	e9 83       	std	Y+1, r30	; 0x01
					//turn(1);
					//turn(1);
					turn_reverse();
				}

				m=m+1;
     894:	39 01       	movw	r6, r18
		present=initial_home_run[m];
		next=initial_home_run[m+1];
	}*/
	
	
	while(initial_home_run[m]!=99)
     896:	c3 01       	movw	r24, r6
     898:	88 0f       	add	r24, r24
     89a:	99 1f       	adc	r25, r25
     89c:	84 0d       	add	r24, r4
     89e:	95 1d       	adc	r25, r5
     8a0:	dc 01       	movw	r26, r24
     8a2:	8d 91       	ld	r24, X+
     8a4:	9c 91       	ld	r25, X
     8a6:	11 97       	sbiw	r26, 0x01	; 1
     8a8:	83 36       	cpi	r24, 0x63	; 99
     8aa:	91 05       	cpc	r25, r1
     8ac:	09 f0       	breq	.+2      	; 0x8b0 <__stack+0x451>
     8ae:	2d ce       	rjmp	.-934    	; 0x50a <__stack+0xab>
			//velocity(20,20);
		//	_delay_ms(400);
		}
		//ir_check();
	}
	++event;
     8b0:	80 91 9a 00 	lds	r24, 0x009A
     8b4:	90 91 9b 00 	lds	r25, 0x009B
     8b8:	01 96       	adiw	r24, 0x01	; 1
     8ba:	90 93 9b 00 	sts	0x009B, r25
     8be:	80 93 9a 00 	sts	0x009A, r24
    ensure_orient(3);
     8c2:	83 e0       	ldi	r24, 0x03	; 3
     8c4:	90 e0       	ldi	r25, 0x00	; 0
     8c6:	0e 94 03 0b 	call	0x1606	; 0x1606 <ensure_orient>
     8ca:	2f ef       	ldi	r18, 0xFF	; 255
     8cc:	3f e3       	ldi	r19, 0x3F	; 63
     8ce:	4b e0       	ldi	r20, 0x0B	; 11
     8d0:	21 50       	subi	r18, 0x01	; 1
     8d2:	30 40       	sbci	r19, 0x00	; 0
     8d4:	40 40       	sbci	r20, 0x00	; 0
     8d6:	e1 f7       	brne	.-8      	; 0x8d0 <__stack+0x471>
     8d8:	00 c0       	rjmp	.+0      	; 0x8da <__stack+0x47b>
     8da:	00 00       	nop
	_delay_ms(500);
	UDR= 0x80;
     8dc:	80 e8       	ldi	r24, 0x80	; 128
     8de:	8c b9       	out	0x0c, r24	; 12
     8e0:	2f ef       	ldi	r18, 0xFF	; 255
     8e2:	3f e3       	ldi	r19, 0x3F	; 63
     8e4:	42 e0       	ldi	r20, 0x02	; 2
     8e6:	21 50       	subi	r18, 0x01	; 1
     8e8:	30 40       	sbci	r19, 0x00	; 0
     8ea:	40 40       	sbci	r20, 0x00	; 0
     8ec:	e1 f7       	brne	.-8      	; 0x8e6 <__stack+0x487>
     8ee:	00 c0       	rjmp	.+0      	; 0x8f0 <__stack+0x491>
     8f0:	00 00       	nop
	_delay_ms(100);
	UDR = 0x80;
     8f2:	8c b9       	out	0x0c, r24	; 12
     8f4:	2f ef       	ldi	r18, 0xFF	; 255
     8f6:	3f e3       	ldi	r19, 0x3F	; 63
     8f8:	42 e0       	ldi	r20, 0x02	; 2
     8fa:	21 50       	subi	r18, 0x01	; 1
     8fc:	30 40       	sbci	r19, 0x00	; 0
     8fe:	40 40       	sbci	r20, 0x00	; 0
     900:	e1 f7       	brne	.-8      	; 0x8fa <__stack+0x49b>
     902:	00 c0       	rjmp	.+0      	; 0x904 <__stack+0x4a5>
     904:	00 00       	nop
	_delay_ms(100);
	UDR = 0x80;
     906:	8c b9       	out	0x0c, r24	; 12
	home_bit[0]=1;
     908:	81 e0       	ldi	r24, 0x01	; 1
     90a:	90 e0       	ldi	r25, 0x00	; 0
     90c:	90 93 a3 00 	sts	0x00A3, r25
     910:	80 93 a2 00 	sts	0x00A2, r24
}
     914:	28 96       	adiw	r28, 0x08	; 8
     916:	0f b6       	in	r0, 0x3f	; 63
     918:	f8 94       	cli
     91a:	de bf       	out	0x3e, r29	; 62
     91c:	0f be       	out	0x3f, r0	; 63
     91e:	cd bf       	out	0x3d, r28	; 61
     920:	df 91       	pop	r29
     922:	cf 91       	pop	r28
     924:	1f 91       	pop	r17
     926:	0f 91       	pop	r16
     928:	ff 90       	pop	r15
     92a:	ef 90       	pop	r14
     92c:	df 90       	pop	r13
     92e:	cf 90       	pop	r12
     930:	bf 90       	pop	r11
     932:	af 90       	pop	r10
     934:	9f 90       	pop	r9
     936:	8f 90       	pop	r8
     938:	7f 90       	pop	r7
     93a:	6f 90       	pop	r6
     93c:	5f 90       	pop	r5
     93e:	4f 90       	pop	r4
     940:	3f 90       	pop	r3
     942:	2f 90       	pop	r2
     944:	08 95       	ret

00000946 <turn_right_ensure>:
	//stop();
	//_delay_ms(500);
	//forward();
	//velocity(35,35);
	//_delay_ms(600);
	turn(1);
     946:	81 e0       	ldi	r24, 0x01	; 1
     948:	90 e0       	ldi	r25, 0x00	; 0
     94a:	0e 94 42 0c 	call	0x1884	; 0x1884 <turn>
}
     94e:	08 95       	ret

00000950 <final_home_run>:
  * Logic: This function upon being called starts the robots final run for its parking at its respective home position, i.e., from node 13 to red home.
  * Example Call: final_home_run()
  */

void final_home_run(void)
{
     950:	6f 92       	push	r6
     952:	7f 92       	push	r7
     954:	8f 92       	push	r8
     956:	9f 92       	push	r9
     958:	af 92       	push	r10
     95a:	bf 92       	push	r11
     95c:	cf 92       	push	r12
     95e:	df 92       	push	r13
     960:	ef 92       	push	r14
     962:	ff 92       	push	r15
     964:	0f 93       	push	r16
     966:	1f 93       	push	r17
     968:	cf 93       	push	r28
     96a:	df 93       	push	r29
		if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
		if (rightMotorSpeed < 0) rightMotorSpeed = 0;
		if (leftMotorSpeed < 0) leftMotorSpeed = 0;

		forward();
		velocity(leftMotorSpeed,rightMotorSpeed);
     96c:	66 24       	eor	r6, r6
     96e:	77 24       	eor	r7, r7
  * Example Call: final_home_run()
  */

void final_home_run(void)
{
	while(curr_pos!=13)
     970:	9f c0       	rjmp	.+318    	; 0xab0 <final_home_run+0x160>
	{
		Left_white_line = ADC_Conversion(3);
     972:	83 e0       	ldi	r24, 0x03	; 3
     974:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     978:	80 93 77 00 	sts	0x0077, r24
		Center_white_line = ADC_Conversion(4);
     97c:	84 e0       	ldi	r24, 0x04	; 4
     97e:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     982:	80 93 76 00 	sts	0x0076, r24
		Right_white_line = ADC_Conversion(5);
     986:	85 e0       	ldi	r24, 0x05	; 5
     988:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     98c:	80 93 75 00 	sts	0x0075, r24
		error = Right_white_line - Left_white_line;
     990:	90 e0       	ldi	r25, 0x00	; 0
     992:	20 91 77 00 	lds	r18, 0x0077
     996:	82 1b       	sub	r24, r18
     998:	91 09       	sbc	r25, r1
     99a:	90 93 13 01 	sts	0x0113, r25
     99e:	80 93 12 01 	sts	0x0112, r24
		int motorSpeed = Kp * error + Kd * (error - lastError);
     9a2:	60 91 12 01 	lds	r22, 0x0112
     9a6:	70 91 13 01 	lds	r23, 0x0113
     9aa:	c0 90 67 00 	lds	r12, 0x0067
     9ae:	d0 90 68 00 	lds	r13, 0x0068
     9b2:	e0 90 69 00 	lds	r14, 0x0069
     9b6:	f0 90 6a 00 	lds	r15, 0x006A
     9ba:	c0 91 12 01 	lds	r28, 0x0112
     9be:	d0 91 13 01 	lds	r29, 0x0113
     9c2:	00 91 78 00 	lds	r16, 0x0078
     9c6:	10 91 79 00 	lds	r17, 0x0079
     9ca:	80 90 63 00 	lds	r8, 0x0063
     9ce:	90 90 64 00 	lds	r9, 0x0064
     9d2:	a0 90 65 00 	lds	r10, 0x0065
     9d6:	b0 90 66 00 	lds	r11, 0x0066
     9da:	88 27       	eor	r24, r24
     9dc:	77 fd       	sbrc	r23, 7
     9de:	80 95       	com	r24
     9e0:	98 2f       	mov	r25, r24
     9e2:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__floatsisf>
     9e6:	a7 01       	movw	r20, r14
     9e8:	96 01       	movw	r18, r12
     9ea:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <__mulsf3>
     9ee:	6b 01       	movw	r12, r22
     9f0:	7c 01       	movw	r14, r24
     9f2:	be 01       	movw	r22, r28
     9f4:	60 1b       	sub	r22, r16
     9f6:	71 0b       	sbc	r23, r17
     9f8:	88 27       	eor	r24, r24
     9fa:	77 fd       	sbrc	r23, 7
     9fc:	80 95       	com	r24
     9fe:	98 2f       	mov	r25, r24
     a00:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__floatsisf>
     a04:	a5 01       	movw	r20, r10
     a06:	94 01       	movw	r18, r8
     a08:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <__mulsf3>
     a0c:	9b 01       	movw	r18, r22
     a0e:	ac 01       	movw	r20, r24
     a10:	c7 01       	movw	r24, r14
     a12:	b6 01       	movw	r22, r12
     a14:	0e 94 71 17 	call	0x2ee2	; 0x2ee2 <__addsf3>
     a18:	0e 94 3d 18 	call	0x307a	; 0x307a <__fixsfsi>
		lastError = error;
     a1c:	80 91 12 01 	lds	r24, 0x0112
     a20:	90 91 13 01 	lds	r25, 0x0113
     a24:	90 93 79 00 	sts	0x0079, r25
     a28:	80 93 78 00 	sts	0x0078, r24
		int rightMotorSpeed = rightBaseSpeed - motorSpeed;
     a2c:	00 91 62 00 	lds	r16, 0x0062
     a30:	10 e0       	ldi	r17, 0x00	; 0
		int leftMotorSpeed = leftBaseSpeed + motorSpeed;
     a32:	80 91 61 00 	lds	r24, 0x0061
     a36:	eb 01       	movw	r28, r22
     a38:	c8 0f       	add	r28, r24
     a3a:	d1 1d       	adc	r29, r1
     a3c:	06 1b       	sub	r16, r22
     a3e:	17 0b       	sbc	r17, r23
     a40:	0e 32       	cpi	r16, 0x2E	; 46
     a42:	11 05       	cpc	r17, r1
     a44:	14 f0       	brlt	.+4      	; 0xa4a <final_home_run+0xfa>
     a46:	0d e2       	ldi	r16, 0x2D	; 45
     a48:	10 e0       	ldi	r17, 0x00	; 0
     a4a:	ce 32       	cpi	r28, 0x2E	; 46
     a4c:	d1 05       	cpc	r29, r1
     a4e:	14 f0       	brlt	.+4      	; 0xa54 <final_home_run+0x104>
     a50:	cd e2       	ldi	r28, 0x2D	; 45
     a52:	d0 e0       	ldi	r29, 0x00	; 0
		if (rightMotorSpeed > rightMaxSpeed ) rightMotorSpeed = rightMaxSpeed;
		if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
		if (rightMotorSpeed < 0) rightMotorSpeed = 0;
		if (leftMotorSpeed < 0) leftMotorSpeed = 0;

		forward();
     a54:	0e 94 28 0b 	call	0x1650	; 0x1650 <forward>
		velocity(leftMotorSpeed,rightMotorSpeed);
     a58:	ce 01       	movw	r24, r28
     a5a:	dd 23       	and	r29, r29
     a5c:	0c f4       	brge	.+2      	; 0xa60 <final_home_run+0x110>
     a5e:	c3 01       	movw	r24, r6
     a60:	b8 01       	movw	r22, r16
     a62:	11 23       	and	r17, r17
     a64:	0c f4       	brge	.+2      	; 0xa68 <final_home_run+0x118>
     a66:	b3 01       	movw	r22, r6
     a68:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>

		if(Center_white_line>40 && Left_white_line>40 && Right_white_line>40)
     a6c:	80 91 76 00 	lds	r24, 0x0076
     a70:	89 32       	cpi	r24, 0x29	; 41
     a72:	f0 f0       	brcs	.+60     	; 0xab0 <final_home_run+0x160>
     a74:	80 91 77 00 	lds	r24, 0x0077
     a78:	89 32       	cpi	r24, 0x29	; 41
     a7a:	d0 f0       	brcs	.+52     	; 0xab0 <final_home_run+0x160>
     a7c:	80 91 75 00 	lds	r24, 0x0075
     a80:	89 32       	cpi	r24, 0x29	; 41
     a82:	b0 f0       	brcs	.+44     	; 0xab0 <final_home_run+0x160>
		{
			update_curr_pos();
     a84:	0e 94 8f 00 	call	0x11e	; 0x11e <update_curr_pos>
			
		//	velocity(40,40);
	     //_delay_ms(300);
		 //just_forward();
			stop();
     a88:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <stop>
			buzz(); 
     a8c:	0e 94 02 02 	call	0x404	; 0x404 <buzz>
			 
			 if(curr_pos==13)
     a90:	80 91 b2 00 	lds	r24, 0x00B2
     a94:	90 91 b3 00 	lds	r25, 0x00B3
     a98:	8d 30       	cpi	r24, 0x0D	; 13
     a9a:	91 05       	cpc	r25, r1
     a9c:	39 f4       	brne	.+14     	; 0xaac <final_home_run+0x15c>
			 {
				// turn(1);
				turn_right();
     a9e:	0e 94 27 01 	call	0x24e	; 0x24e <turn_right>
				 forward_mm(130);
     aa2:	82 e8       	ldi	r24, 0x82	; 130
     aa4:	90 e0       	ldi	r25, 0x00	; 0
     aa6:	0e 94 a5 0b 	call	0x174a	; 0x174a <forward_mm>
     aaa:	02 c0       	rjmp	.+4      	; 0xab0 <final_home_run+0x160>
			 }
			 else
			 {
				 // forward();
				 // velocity(100,100);
				 just_forward();
     aac:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
  * Example Call: final_home_run()
  */

void final_home_run(void)
{
	while(curr_pos!=13)
     ab0:	80 91 b2 00 	lds	r24, 0x00B2
     ab4:	90 91 b3 00 	lds	r25, 0x00B3
     ab8:	8d 30       	cpi	r24, 0x0D	; 13
     aba:	91 05       	cpc	r25, r1
     abc:	09 f0       	breq	.+2      	; 0xac0 <final_home_run+0x170>
     abe:	59 cf       	rjmp	.-334    	; 0x972 <final_home_run+0x22>
				 just_forward();
				  //_delay_ms(300);
			 }
		}			
	}
}
     ac0:	df 91       	pop	r29
     ac2:	cf 91       	pop	r28
     ac4:	1f 91       	pop	r17
     ac6:	0f 91       	pop	r16
     ac8:	ff 90       	pop	r15
     aca:	ef 90       	pop	r14
     acc:	df 90       	pop	r13
     ace:	cf 90       	pop	r12
     ad0:	bf 90       	pop	r11
     ad2:	af 90       	pop	r10
     ad4:	9f 90       	pop	r9
     ad6:	8f 90       	pop	r8
     ad8:	7f 90       	pop	r7
     ada:	6f 90       	pop	r6
     adc:	08 95       	ret

00000ade <navigate_0>:
  * Logic: This function upon being called makes the robot traverse path for changing set1 to set2, i.e, from node 41 to node 13.
  * Example Call: navigate_1()
  */

void navigate_0(void)
{
     ade:	3f 92       	push	r3
     ae0:	4f 92       	push	r4
     ae2:	5f 92       	push	r5
     ae4:	6f 92       	push	r6
     ae6:	7f 92       	push	r7
     ae8:	8f 92       	push	r8
     aea:	9f 92       	push	r9
     aec:	af 92       	push	r10
     aee:	bf 92       	push	r11
     af0:	cf 92       	push	r12
     af2:	df 92       	push	r13
     af4:	ef 92       	push	r14
     af6:	ff 92       	push	r15
     af8:	0f 93       	push	r16
     afa:	1f 93       	push	r17
     afc:	cf 93       	push	r28
     afe:	df 93       	push	r29
			if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
			if (rightMotorSpeed < 0) rightMotorSpeed = 0;
			if (leftMotorSpeed < 0) leftMotorSpeed = 0;

			forward();
			velocity(leftMotorSpeed,rightMotorSpeed);
     b00:	66 24       	eor	r6, r6
     b02:	77 24       	eor	r7, r7
				
				  if(curr_pos == 40)
				  {
					  all_xbee_clear();
				  }
				 if((curr_pos== 40) | (curr_pos==12)) 
     b04:	55 24       	eor	r5, r5
     b06:	53 94       	inc	r5
					 ensure_orient(3);
					 event = 0;
					 array_index = 0;
					 set_cover=0;
					 ++set;
					 xbee_com=-1;
     b08:	33 24       	eor	r3, r3
     b0a:	3a 94       	dec	r3
				
				  if(curr_pos == 40)
				  {
					  all_xbee_clear();
				  }
				 if((curr_pos== 40) | (curr_pos==12)) 
     b0c:	44 24       	eor	r4, r4
  * Example Call: navigate_1()
  */

void navigate_0(void)
{
	while(curr_pos != 13)
     b0e:	dd c0       	rjmp	.+442    	; 0xcca <navigate_0+0x1ec>
	{
		
		
			Left_white_line = ADC_Conversion(3);
     b10:	83 e0       	ldi	r24, 0x03	; 3
     b12:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     b16:	80 93 77 00 	sts	0x0077, r24
			Center_white_line = ADC_Conversion(4);
     b1a:	84 e0       	ldi	r24, 0x04	; 4
     b1c:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     b20:	80 93 76 00 	sts	0x0076, r24
			Right_white_line = ADC_Conversion(5);
     b24:	85 e0       	ldi	r24, 0x05	; 5
     b26:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     b2a:	80 93 75 00 	sts	0x0075, r24
			error = Right_white_line - Left_white_line;
     b2e:	90 e0       	ldi	r25, 0x00	; 0
     b30:	20 91 77 00 	lds	r18, 0x0077
     b34:	82 1b       	sub	r24, r18
     b36:	91 09       	sbc	r25, r1
     b38:	90 93 13 01 	sts	0x0113, r25
     b3c:	80 93 12 01 	sts	0x0112, r24
			int motorSpeed = Kp * error + Kd * (error - lastError);
     b40:	60 91 12 01 	lds	r22, 0x0112
     b44:	70 91 13 01 	lds	r23, 0x0113
     b48:	c0 90 67 00 	lds	r12, 0x0067
     b4c:	d0 90 68 00 	lds	r13, 0x0068
     b50:	e0 90 69 00 	lds	r14, 0x0069
     b54:	f0 90 6a 00 	lds	r15, 0x006A
     b58:	c0 91 12 01 	lds	r28, 0x0112
     b5c:	d0 91 13 01 	lds	r29, 0x0113
     b60:	00 91 78 00 	lds	r16, 0x0078
     b64:	10 91 79 00 	lds	r17, 0x0079
     b68:	80 90 63 00 	lds	r8, 0x0063
     b6c:	90 90 64 00 	lds	r9, 0x0064
     b70:	a0 90 65 00 	lds	r10, 0x0065
     b74:	b0 90 66 00 	lds	r11, 0x0066
     b78:	88 27       	eor	r24, r24
     b7a:	77 fd       	sbrc	r23, 7
     b7c:	80 95       	com	r24
     b7e:	98 2f       	mov	r25, r24
     b80:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__floatsisf>
     b84:	a7 01       	movw	r20, r14
     b86:	96 01       	movw	r18, r12
     b88:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <__mulsf3>
     b8c:	6b 01       	movw	r12, r22
     b8e:	7c 01       	movw	r14, r24
     b90:	be 01       	movw	r22, r28
     b92:	60 1b       	sub	r22, r16
     b94:	71 0b       	sbc	r23, r17
     b96:	88 27       	eor	r24, r24
     b98:	77 fd       	sbrc	r23, 7
     b9a:	80 95       	com	r24
     b9c:	98 2f       	mov	r25, r24
     b9e:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__floatsisf>
     ba2:	a5 01       	movw	r20, r10
     ba4:	94 01       	movw	r18, r8
     ba6:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <__mulsf3>
     baa:	9b 01       	movw	r18, r22
     bac:	ac 01       	movw	r20, r24
     bae:	c7 01       	movw	r24, r14
     bb0:	b6 01       	movw	r22, r12
     bb2:	0e 94 71 17 	call	0x2ee2	; 0x2ee2 <__addsf3>
     bb6:	0e 94 3d 18 	call	0x307a	; 0x307a <__fixsfsi>
			lastError = error;
     bba:	80 91 12 01 	lds	r24, 0x0112
     bbe:	90 91 13 01 	lds	r25, 0x0113
     bc2:	90 93 79 00 	sts	0x0079, r25
     bc6:	80 93 78 00 	sts	0x0078, r24
			int rightMotorSpeed = rightBaseSpeed - motorSpeed;
     bca:	00 91 62 00 	lds	r16, 0x0062
     bce:	10 e0       	ldi	r17, 0x00	; 0
			int leftMotorSpeed = leftBaseSpeed + motorSpeed;
     bd0:	80 91 61 00 	lds	r24, 0x0061
     bd4:	eb 01       	movw	r28, r22
     bd6:	c8 0f       	add	r28, r24
     bd8:	d1 1d       	adc	r29, r1
     bda:	06 1b       	sub	r16, r22
     bdc:	17 0b       	sbc	r17, r23
     bde:	0e 32       	cpi	r16, 0x2E	; 46
     be0:	11 05       	cpc	r17, r1
     be2:	14 f0       	brlt	.+4      	; 0xbe8 <navigate_0+0x10a>
     be4:	0d e2       	ldi	r16, 0x2D	; 45
     be6:	10 e0       	ldi	r17, 0x00	; 0
     be8:	ce 32       	cpi	r28, 0x2E	; 46
     bea:	d1 05       	cpc	r29, r1
     bec:	14 f0       	brlt	.+4      	; 0xbf2 <navigate_0+0x114>
     bee:	cd e2       	ldi	r28, 0x2D	; 45
     bf0:	d0 e0       	ldi	r29, 0x00	; 0
			if (rightMotorSpeed > rightMaxSpeed ) rightMotorSpeed = rightMaxSpeed;
			if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
			if (rightMotorSpeed < 0) rightMotorSpeed = 0;
			if (leftMotorSpeed < 0) leftMotorSpeed = 0;

			forward();
     bf2:	0e 94 28 0b 	call	0x1650	; 0x1650 <forward>
			velocity(leftMotorSpeed,rightMotorSpeed);
     bf6:	ce 01       	movw	r24, r28
     bf8:	dd 23       	and	r29, r29
     bfa:	0c f4       	brge	.+2      	; 0xbfe <navigate_0+0x120>
     bfc:	c3 01       	movw	r24, r6
     bfe:	b8 01       	movw	r22, r16
     c00:	11 23       	and	r17, r17
     c02:	0c f4       	brge	.+2      	; 0xc06 <navigate_0+0x128>
     c04:	b3 01       	movw	r22, r6
     c06:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>

			if(Center_white_line>40 && Left_white_line>40 && Right_white_line>40)
     c0a:	80 91 76 00 	lds	r24, 0x0076
     c0e:	89 32       	cpi	r24, 0x29	; 41
     c10:	08 f4       	brcc	.+2      	; 0xc14 <navigate_0+0x136>
     c12:	5b c0       	rjmp	.+182    	; 0xcca <navigate_0+0x1ec>
     c14:	80 91 77 00 	lds	r24, 0x0077
     c18:	89 32       	cpi	r24, 0x29	; 41
     c1a:	08 f4       	brcc	.+2      	; 0xc1e <navigate_0+0x140>
     c1c:	56 c0       	rjmp	.+172    	; 0xcca <navigate_0+0x1ec>
     c1e:	80 91 75 00 	lds	r24, 0x0075
     c22:	89 32       	cpi	r24, 0x29	; 41
     c24:	08 f4       	brcc	.+2      	; 0xc28 <navigate_0+0x14a>
     c26:	51 c0       	rjmp	.+162    	; 0xcca <navigate_0+0x1ec>
			{
				update_curr_pos();
     c28:	0e 94 8f 00 	call	0x11e	; 0x11e <update_curr_pos>
				
				//velocity(40,40);
				//_delay_ms(300);
				//just_forward();
				stop();
     c2c:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <stop>
				buzz();
     c30:	0e 94 02 02 	call	0x404	; 0x404 <buzz>
				
				  if(curr_pos == 40)
     c34:	80 91 b2 00 	lds	r24, 0x00B2
     c38:	90 91 b3 00 	lds	r25, 0x00B3
     c3c:	88 32       	cpi	r24, 0x28	; 40
     c3e:	91 05       	cpc	r25, r1
     c40:	11 f4       	brne	.+4      	; 0xc46 <navigate_0+0x168>
				  {
					  all_xbee_clear();
     c42:	0e 94 df 00 	call	0x1be	; 0x1be <all_xbee_clear>
				  }
				 if((curr_pos== 40) | (curr_pos==12)) 
     c46:	80 91 b2 00 	lds	r24, 0x00B2
     c4a:	90 91 b3 00 	lds	r25, 0x00B3
     c4e:	20 91 b2 00 	lds	r18, 0x00B2
     c52:	30 91 b3 00 	lds	r19, 0x00B3
     c56:	45 2d       	mov	r20, r5
     c58:	88 32       	cpi	r24, 0x28	; 40
     c5a:	91 05       	cpc	r25, r1
     c5c:	09 f0       	breq	.+2      	; 0xc60 <navigate_0+0x182>
     c5e:	44 2d       	mov	r20, r4
     c60:	44 23       	and	r20, r20
     c62:	39 f4       	brne	.+14     	; 0xc72 <navigate_0+0x194>
     c64:	85 2d       	mov	r24, r5
     c66:	2c 30       	cpi	r18, 0x0C	; 12
     c68:	31 05       	cpc	r19, r1
     c6a:	09 f0       	breq	.+2      	; 0xc6e <navigate_0+0x190>
     c6c:	84 2d       	mov	r24, r4
     c6e:	88 23       	and	r24, r24
     c70:	19 f0       	breq	.+6      	; 0xc78 <navigate_0+0x19a>
				 //turn(1);
				 turn_right();
     c72:	0e 94 27 01 	call	0x24e	; 0x24e <turn_right>
     c76:	29 c0       	rjmp	.+82     	; 0xcca <navigate_0+0x1ec>
				 else if(curr_pos==13)
     c78:	80 91 b2 00 	lds	r24, 0x00B2
     c7c:	90 91 b3 00 	lds	r25, 0x00B3
     c80:	8d 30       	cpi	r24, 0x0D	; 13
     c82:	91 05       	cpc	r25, r1
     c84:	01 f5       	brne	.+64     	; 0xcc6 <navigate_0+0x1e8>
				 {
					 ensure_orient(3);
     c86:	83 e0       	ldi	r24, 0x03	; 3
     c88:	90 e0       	ldi	r25, 0x00	; 0
     c8a:	0e 94 03 0b 	call	0x1606	; 0x1606 <ensure_orient>
					 event = 0;
     c8e:	70 92 9b 00 	sts	0x009B, r7
     c92:	60 92 9a 00 	sts	0x009A, r6
					 array_index = 0;
     c96:	70 92 8b 00 	sts	0x008B, r7
     c9a:	60 92 8a 00 	sts	0x008A, r6
					 set_cover=0;
     c9e:	70 92 9d 00 	sts	0x009D, r7
     ca2:	60 92 9c 00 	sts	0x009C, r6
					 ++set;
     ca6:	80 91 9e 00 	lds	r24, 0x009E
     caa:	90 91 9f 00 	lds	r25, 0x009F
     cae:	01 96       	adiw	r24, 0x01	; 1
     cb0:	90 93 9f 00 	sts	0x009F, r25
     cb4:	80 93 9e 00 	sts	0x009E, r24
					 xbee_com=-1;
     cb8:	30 92 96 00 	sts	0x0096, r3
					 event=0;
     cbc:	70 92 9b 00 	sts	0x009B, r7
     cc0:	60 92 9a 00 	sts	0x009A, r6
     cc4:	02 c0       	rjmp	.+4      	; 0xcca <navigate_0+0x1ec>
				 else
				 {
					// forward();
					//velocity(100,100);
					// _delay_ms(300);
					just_forward();
     cc6:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
  * Example Call: navigate_1()
  */

void navigate_0(void)
{
	while(curr_pos != 13)
     cca:	80 91 b2 00 	lds	r24, 0x00B2
     cce:	90 91 b3 00 	lds	r25, 0x00B3
     cd2:	8d 30       	cpi	r24, 0x0D	; 13
     cd4:	91 05       	cpc	r25, r1
     cd6:	09 f0       	breq	.+2      	; 0xcda <navigate_0+0x1fc>
     cd8:	1b cf       	rjmp	.-458    	; 0xb10 <navigate_0+0x32>
				 }
									 					 					 
			 }				 
		
	}	       
}
     cda:	df 91       	pop	r29
     cdc:	cf 91       	pop	r28
     cde:	1f 91       	pop	r17
     ce0:	0f 91       	pop	r16
     ce2:	ff 90       	pop	r15
     ce4:	ef 90       	pop	r14
     ce6:	df 90       	pop	r13
     ce8:	cf 90       	pop	r12
     cea:	bf 90       	pop	r11
     cec:	af 90       	pop	r10
     cee:	9f 90       	pop	r9
     cf0:	8f 90       	pop	r8
     cf2:	7f 90       	pop	r7
     cf4:	6f 90       	pop	r6
     cf6:	5f 90       	pop	r5
     cf8:	4f 90       	pop	r4
     cfa:	3f 90       	pop	r3
     cfc:	08 95       	ret

00000cfe <navigate_1>:
  * Logic: This function upon being called makes the robot traverse path for changing set0 to set1, i.e, from node 41 to node 13.
  * Example Call: navigate_0()
  */

void navigate_1()
{
     cfe:	5f 92       	push	r5
     d00:	6f 92       	push	r6
     d02:	7f 92       	push	r7
     d04:	8f 92       	push	r8
     d06:	9f 92       	push	r9
     d08:	af 92       	push	r10
     d0a:	bf 92       	push	r11
     d0c:	cf 92       	push	r12
     d0e:	df 92       	push	r13
     d10:	ef 92       	push	r14
     d12:	ff 92       	push	r15
     d14:	0f 93       	push	r16
     d16:	1f 93       	push	r17
     d18:	cf 93       	push	r28
     d1a:	df 93       	push	r29
		 if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
		 if (rightMotorSpeed < 0) rightMotorSpeed = 0;
		 if (leftMotorSpeed < 0) leftMotorSpeed = 0;

		 forward();
		 velocity(leftMotorSpeed,rightMotorSpeed);
     d1c:	66 24       	eor	r6, r6
     d1e:	77 24       	eor	r7, r7
			{
				ensure_orient(3);
				array_index = 0;
				set_cover=0;
				++set;
				xbee_com=-1;
     d20:	55 24       	eor	r5, r5
     d22:	5a 94       	dec	r5
  * Example Call: navigate_0()
  */

void navigate_1()
{
	while(curr_pos != 27)
     d24:	bd c0       	rjmp	.+378    	; 0xea0 <navigate_1+0x1a2>
	{ 
		 Left_white_line = ADC_Conversion(3);
     d26:	83 e0       	ldi	r24, 0x03	; 3
     d28:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     d2c:	80 93 77 00 	sts	0x0077, r24
		 Center_white_line = ADC_Conversion(4);
     d30:	84 e0       	ldi	r24, 0x04	; 4
     d32:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     d36:	80 93 76 00 	sts	0x0076, r24
		 Right_white_line = ADC_Conversion(5);
     d3a:	85 e0       	ldi	r24, 0x05	; 5
     d3c:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     d40:	80 93 75 00 	sts	0x0075, r24
		 error = Right_white_line - Left_white_line;
     d44:	90 e0       	ldi	r25, 0x00	; 0
     d46:	20 91 77 00 	lds	r18, 0x0077
     d4a:	82 1b       	sub	r24, r18
     d4c:	91 09       	sbc	r25, r1
     d4e:	90 93 13 01 	sts	0x0113, r25
     d52:	80 93 12 01 	sts	0x0112, r24
		 int motorSpeed = Kp * error + Kd * (error - lastError);
     d56:	60 91 12 01 	lds	r22, 0x0112
     d5a:	70 91 13 01 	lds	r23, 0x0113
     d5e:	c0 90 67 00 	lds	r12, 0x0067
     d62:	d0 90 68 00 	lds	r13, 0x0068
     d66:	e0 90 69 00 	lds	r14, 0x0069
     d6a:	f0 90 6a 00 	lds	r15, 0x006A
     d6e:	c0 91 12 01 	lds	r28, 0x0112
     d72:	d0 91 13 01 	lds	r29, 0x0113
     d76:	00 91 78 00 	lds	r16, 0x0078
     d7a:	10 91 79 00 	lds	r17, 0x0079
     d7e:	80 90 63 00 	lds	r8, 0x0063
     d82:	90 90 64 00 	lds	r9, 0x0064
     d86:	a0 90 65 00 	lds	r10, 0x0065
     d8a:	b0 90 66 00 	lds	r11, 0x0066
     d8e:	88 27       	eor	r24, r24
     d90:	77 fd       	sbrc	r23, 7
     d92:	80 95       	com	r24
     d94:	98 2f       	mov	r25, r24
     d96:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__floatsisf>
     d9a:	a7 01       	movw	r20, r14
     d9c:	96 01       	movw	r18, r12
     d9e:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <__mulsf3>
     da2:	6b 01       	movw	r12, r22
     da4:	7c 01       	movw	r14, r24
     da6:	be 01       	movw	r22, r28
     da8:	60 1b       	sub	r22, r16
     daa:	71 0b       	sbc	r23, r17
     dac:	88 27       	eor	r24, r24
     dae:	77 fd       	sbrc	r23, 7
     db0:	80 95       	com	r24
     db2:	98 2f       	mov	r25, r24
     db4:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__floatsisf>
     db8:	a5 01       	movw	r20, r10
     dba:	94 01       	movw	r18, r8
     dbc:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <__mulsf3>
     dc0:	9b 01       	movw	r18, r22
     dc2:	ac 01       	movw	r20, r24
     dc4:	c7 01       	movw	r24, r14
     dc6:	b6 01       	movw	r22, r12
     dc8:	0e 94 71 17 	call	0x2ee2	; 0x2ee2 <__addsf3>
     dcc:	0e 94 3d 18 	call	0x307a	; 0x307a <__fixsfsi>
		 lastError = error;
     dd0:	80 91 12 01 	lds	r24, 0x0112
     dd4:	90 91 13 01 	lds	r25, 0x0113
     dd8:	90 93 79 00 	sts	0x0079, r25
     ddc:	80 93 78 00 	sts	0x0078, r24
		 int rightMotorSpeed = rightBaseSpeed - motorSpeed;
     de0:	00 91 62 00 	lds	r16, 0x0062
     de4:	10 e0       	ldi	r17, 0x00	; 0
		 int leftMotorSpeed = leftBaseSpeed + motorSpeed;
     de6:	80 91 61 00 	lds	r24, 0x0061
     dea:	eb 01       	movw	r28, r22
     dec:	c8 0f       	add	r28, r24
     dee:	d1 1d       	adc	r29, r1
     df0:	06 1b       	sub	r16, r22
     df2:	17 0b       	sbc	r17, r23
     df4:	0e 32       	cpi	r16, 0x2E	; 46
     df6:	11 05       	cpc	r17, r1
     df8:	14 f0       	brlt	.+4      	; 0xdfe <navigate_1+0x100>
     dfa:	0d e2       	ldi	r16, 0x2D	; 45
     dfc:	10 e0       	ldi	r17, 0x00	; 0
     dfe:	ce 32       	cpi	r28, 0x2E	; 46
     e00:	d1 05       	cpc	r29, r1
     e02:	14 f0       	brlt	.+4      	; 0xe08 <navigate_1+0x10a>
     e04:	cd e2       	ldi	r28, 0x2D	; 45
     e06:	d0 e0       	ldi	r29, 0x00	; 0
		 if (rightMotorSpeed > rightMaxSpeed ) rightMotorSpeed = rightMaxSpeed;
		 if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
		 if (rightMotorSpeed < 0) rightMotorSpeed = 0;
		 if (leftMotorSpeed < 0) leftMotorSpeed = 0;

		 forward();
     e08:	0e 94 28 0b 	call	0x1650	; 0x1650 <forward>
		 velocity(leftMotorSpeed,rightMotorSpeed);
     e0c:	ce 01       	movw	r24, r28
     e0e:	dd 23       	and	r29, r29
     e10:	0c f4       	brge	.+2      	; 0xe14 <navigate_1+0x116>
     e12:	c3 01       	movw	r24, r6
     e14:	b8 01       	movw	r22, r16
     e16:	11 23       	and	r17, r17
     e18:	0c f4       	brge	.+2      	; 0xe1c <navigate_1+0x11e>
     e1a:	b3 01       	movw	r22, r6
     e1c:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>

		 if(Center_white_line>40 && Left_white_line>40 && Right_white_line>40)
     e20:	80 91 76 00 	lds	r24, 0x0076
     e24:	89 32       	cpi	r24, 0x29	; 41
     e26:	e0 f1       	brcs	.+120    	; 0xea0 <navigate_1+0x1a2>
     e28:	80 91 77 00 	lds	r24, 0x0077
     e2c:	89 32       	cpi	r24, 0x29	; 41
     e2e:	c0 f1       	brcs	.+112    	; 0xea0 <navigate_1+0x1a2>
     e30:	80 91 75 00 	lds	r24, 0x0075
     e34:	89 32       	cpi	r24, 0x29	; 41
     e36:	a0 f1       	brcs	.+104    	; 0xea0 <navigate_1+0x1a2>
		 {
			  update_curr_pos();
     e38:	0e 94 8f 00 	call	0x11e	; 0x11e <update_curr_pos>
			  
			 // velocity(40,40);
			  //_delay_ms(300);
			  //just_forward();
			  stop();
     e3c:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <stop>
			  buzz();
     e40:	0e 94 02 02 	call	0x404	; 0x404 <buzz>
			  if(curr_pos == 20)
     e44:	80 91 b2 00 	lds	r24, 0x00B2
     e48:	90 91 b3 00 	lds	r25, 0x00B3
     e4c:	84 31       	cpi	r24, 0x14	; 20
     e4e:	91 05       	cpc	r25, r1
     e50:	11 f4       	brne	.+4      	; 0xe56 <navigate_1+0x158>
			  {
				  all_xbee_clear();
     e52:	0e 94 df 00 	call	0x1be	; 0x1be <all_xbee_clear>
			  }
			if(curr_pos!=27)
     e56:	80 91 b2 00 	lds	r24, 0x00B2
     e5a:	90 91 b3 00 	lds	r25, 0x00B3
     e5e:	8b 31       	cpi	r24, 0x1B	; 27
     e60:	91 05       	cpc	r25, r1
     e62:	19 f0       	breq	.+6      	; 0xe6a <navigate_1+0x16c>
			{ 
				//forward();
				//velocity(100,100);
				//_delay_ms(300);
				just_forward();
     e64:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
     e68:	1b c0       	rjmp	.+54     	; 0xea0 <navigate_1+0x1a2>
			}
			else
			{
				ensure_orient(3);
     e6a:	83 e0       	ldi	r24, 0x03	; 3
     e6c:	90 e0       	ldi	r25, 0x00	; 0
     e6e:	0e 94 03 0b 	call	0x1606	; 0x1606 <ensure_orient>
				array_index = 0;
     e72:	70 92 8b 00 	sts	0x008B, r7
     e76:	60 92 8a 00 	sts	0x008A, r6
				set_cover=0;
     e7a:	70 92 9d 00 	sts	0x009D, r7
     e7e:	60 92 9c 00 	sts	0x009C, r6
				++set;
     e82:	80 91 9e 00 	lds	r24, 0x009E
     e86:	90 91 9f 00 	lds	r25, 0x009F
     e8a:	01 96       	adiw	r24, 0x01	; 1
     e8c:	90 93 9f 00 	sts	0x009F, r25
     e90:	80 93 9e 00 	sts	0x009E, r24
				xbee_com=-1;
     e94:	50 92 96 00 	sts	0x0096, r5
				event=0;
     e98:	70 92 9b 00 	sts	0x009B, r7
     e9c:	60 92 9a 00 	sts	0x009A, r6
  * Example Call: navigate_0()
  */

void navigate_1()
{
	while(curr_pos != 27)
     ea0:	80 91 b2 00 	lds	r24, 0x00B2
     ea4:	90 91 b3 00 	lds	r25, 0x00B3
     ea8:	8b 31       	cpi	r24, 0x1B	; 27
     eaa:	91 05       	cpc	r25, r1
     eac:	09 f0       	breq	.+2      	; 0xeb0 <navigate_1+0x1b2>
     eae:	3b cf       	rjmp	.-394    	; 0xd26 <navigate_1+0x28>
		    }	
					
		  }
	    	 
     }		
}
     eb0:	df 91       	pop	r29
     eb2:	cf 91       	pop	r28
     eb4:	1f 91       	pop	r17
     eb6:	0f 91       	pop	r16
     eb8:	ff 90       	pop	r15
     eba:	ef 90       	pop	r14
     ebc:	df 90       	pop	r13
     ebe:	cf 90       	pop	r12
     ec0:	bf 90       	pop	r11
     ec2:	af 90       	pop	r10
     ec4:	9f 90       	pop	r9
     ec6:	8f 90       	pop	r8
     ec8:	7f 90       	pop	r7
     eca:	6f 90       	pop	r6
     ecc:	5f 90       	pop	r5
     ece:	08 95       	ret

00000ed0 <line_follow_till_1>:
           If their are no plants it will simply traverse the other end of the set and come back to the start of the start, i.e., node 13.
  * Example Call: line_follow_till_2()
  */ 

void line_follow_till_1(unsigned int req_pos)
{
     ed0:	3f 92       	push	r3
     ed2:	4f 92       	push	r4
     ed4:	5f 92       	push	r5
     ed6:	6f 92       	push	r6
     ed8:	7f 92       	push	r7
     eda:	8f 92       	push	r8
     edc:	9f 92       	push	r9
     ede:	af 92       	push	r10
     ee0:	bf 92       	push	r11
     ee2:	cf 92       	push	r12
     ee4:	df 92       	push	r13
     ee6:	ef 92       	push	r14
     ee8:	ff 92       	push	r15
     eea:	0f 93       	push	r16
     eec:	1f 93       	push	r17
     eee:	cf 93       	push	r28
     ef0:	df 93       	push	r29
     ef2:	3c 01       	movw	r6, r24
	if(((req_pos == 13) && (set_cover == 0)) || ((req_pos == 7) && (set_cover == 50)))
     ef4:	8d e0       	ldi	r24, 0x0D	; 13
     ef6:	68 16       	cp	r6, r24
     ef8:	71 04       	cpc	r7, r1
     efa:	41 f4       	brne	.+16     	; 0xf0c <line_follow_till_1+0x3c>
     efc:	80 91 9c 00 	lds	r24, 0x009C
     f00:	90 91 9d 00 	lds	r25, 0x009D
     f04:	00 97       	sbiw	r24, 0x00	; 0
     f06:	09 f0       	breq	.+2      	; 0xf0a <line_follow_till_1+0x3a>
     f08:	40 c1       	rjmp	.+640    	; 0x118a <line_follow_till_1+0x2ba>
     f0a:	0d c0       	rjmp	.+26     	; 0xf26 <line_follow_till_1+0x56>
     f0c:	97 e0       	ldi	r25, 0x07	; 7
     f0e:	69 16       	cp	r6, r25
     f10:	71 04       	cpc	r7, r1
     f12:	09 f0       	breq	.+2      	; 0xf16 <line_follow_till_1+0x46>
     f14:	3a c1       	rjmp	.+628    	; 0x118a <line_follow_till_1+0x2ba>
     f16:	80 91 9c 00 	lds	r24, 0x009C
     f1a:	90 91 9d 00 	lds	r25, 0x009D
     f1e:	82 33       	cpi	r24, 0x32	; 50
     f20:	91 05       	cpc	r25, r1
     f22:	09 f0       	breq	.+2      	; 0xf26 <line_follow_till_1+0x56>
     f24:	32 c1       	rjmp	.+612    	; 0x118a <line_follow_till_1+0x2ba>
	{
		forward_mm(150);
     f26:	86 e9       	ldi	r24, 0x96	; 150
     f28:	90 e0       	ldi	r25, 0x00	; 0
     f2a:	0e 94 a5 0b 	call	0x174a	; 0x174a <forward_mm>
		event=1;
     f2e:	81 e0       	ldi	r24, 0x01	; 1
     f30:	90 e0       	ldi	r25, 0x00	; 0
     f32:	90 93 9b 00 	sts	0x009B, r25
     f36:	80 93 9a 00 	sts	0x009A, r24
  */ 

void line_follow_till_1(unsigned int req_pos)
{
	if(((req_pos == 13) && (set_cover == 0)) || ((req_pos == 7) && (set_cover == 50)))
	{
     f3a:	35 c1       	rjmp	.+618    	; 0x11a6 <line_follow_till_1+0x2d6>
	}
	else
	{
		while(curr_pos!=req_pos)
	{
		Left_white_line = ADC_Conversion(3);
     f3c:	83 e0       	ldi	r24, 0x03	; 3
     f3e:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     f42:	80 93 77 00 	sts	0x0077, r24
		Center_white_line = ADC_Conversion(4);
     f46:	84 e0       	ldi	r24, 0x04	; 4
     f48:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     f4c:	80 93 76 00 	sts	0x0076, r24
		Right_white_line = ADC_Conversion(5);
     f50:	85 e0       	ldi	r24, 0x05	; 5
     f52:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
     f56:	80 93 75 00 	sts	0x0075, r24
		error = Right_white_line - Left_white_line;
     f5a:	90 e0       	ldi	r25, 0x00	; 0
     f5c:	20 91 77 00 	lds	r18, 0x0077
     f60:	82 1b       	sub	r24, r18
     f62:	91 09       	sbc	r25, r1
     f64:	90 93 13 01 	sts	0x0113, r25
     f68:	80 93 12 01 	sts	0x0112, r24
		int motorSpeed = Kp * error + Kd * (error - lastError);
     f6c:	60 91 12 01 	lds	r22, 0x0112
     f70:	70 91 13 01 	lds	r23, 0x0113
     f74:	c0 90 67 00 	lds	r12, 0x0067
     f78:	d0 90 68 00 	lds	r13, 0x0068
     f7c:	e0 90 69 00 	lds	r14, 0x0069
     f80:	f0 90 6a 00 	lds	r15, 0x006A
     f84:	c0 91 12 01 	lds	r28, 0x0112
     f88:	d0 91 13 01 	lds	r29, 0x0113
     f8c:	00 91 78 00 	lds	r16, 0x0078
     f90:	10 91 79 00 	lds	r17, 0x0079
     f94:	80 90 63 00 	lds	r8, 0x0063
     f98:	90 90 64 00 	lds	r9, 0x0064
     f9c:	a0 90 65 00 	lds	r10, 0x0065
     fa0:	b0 90 66 00 	lds	r11, 0x0066
     fa4:	88 27       	eor	r24, r24
     fa6:	77 fd       	sbrc	r23, 7
     fa8:	80 95       	com	r24
     faa:	98 2f       	mov	r25, r24
     fac:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__floatsisf>
     fb0:	a7 01       	movw	r20, r14
     fb2:	96 01       	movw	r18, r12
     fb4:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <__mulsf3>
     fb8:	6b 01       	movw	r12, r22
     fba:	7c 01       	movw	r14, r24
     fbc:	be 01       	movw	r22, r28
     fbe:	60 1b       	sub	r22, r16
     fc0:	71 0b       	sbc	r23, r17
     fc2:	88 27       	eor	r24, r24
     fc4:	77 fd       	sbrc	r23, 7
     fc6:	80 95       	com	r24
     fc8:	98 2f       	mov	r25, r24
     fca:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__floatsisf>
     fce:	a5 01       	movw	r20, r10
     fd0:	94 01       	movw	r18, r8
     fd2:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <__mulsf3>
     fd6:	9b 01       	movw	r18, r22
     fd8:	ac 01       	movw	r20, r24
     fda:	c7 01       	movw	r24, r14
     fdc:	b6 01       	movw	r22, r12
     fde:	0e 94 71 17 	call	0x2ee2	; 0x2ee2 <__addsf3>
     fe2:	0e 94 3d 18 	call	0x307a	; 0x307a <__fixsfsi>
     fe6:	dc 01       	movw	r26, r24
     fe8:	cb 01       	movw	r24, r22
		lastError = error;
     fea:	20 91 12 01 	lds	r18, 0x0112
     fee:	30 91 13 01 	lds	r19, 0x0113
     ff2:	30 93 79 00 	sts	0x0079, r19
     ff6:	20 93 78 00 	sts	0x0078, r18
		int rightMotorSpeed = rightBaseSpeed - motorSpeed;
     ffa:	00 91 62 00 	lds	r16, 0x0062
     ffe:	10 e0       	ldi	r17, 0x00	; 0
		int leftMotorSpeed = leftBaseSpeed + motorSpeed;
    1000:	20 91 61 00 	lds	r18, 0x0061
    1004:	ec 01       	movw	r28, r24
    1006:	c2 0f       	add	r28, r18
    1008:	d1 1d       	adc	r29, r1
    100a:	08 1b       	sub	r16, r24
    100c:	19 0b       	sbc	r17, r25
    100e:	0e 32       	cpi	r16, 0x2E	; 46
    1010:	11 05       	cpc	r17, r1
    1012:	14 f0       	brlt	.+4      	; 0x1018 <line_follow_till_1+0x148>
    1014:	0d e2       	ldi	r16, 0x2D	; 45
    1016:	10 e0       	ldi	r17, 0x00	; 0
    1018:	ce 32       	cpi	r28, 0x2E	; 46
    101a:	d1 05       	cpc	r29, r1
    101c:	14 f0       	brlt	.+4      	; 0x1022 <line_follow_till_1+0x152>
    101e:	cd e2       	ldi	r28, 0x2D	; 45
    1020:	d0 e0       	ldi	r29, 0x00	; 0
		if (rightMotorSpeed > rightMaxSpeed ) rightMotorSpeed = rightMaxSpeed;
		if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
		if (rightMotorSpeed < 0) rightMotorSpeed = 0;
		if (leftMotorSpeed < 0) leftMotorSpeed = 0;

		forward();
    1022:	0e 94 28 0b 	call	0x1650	; 0x1650 <forward>
		velocity(leftMotorSpeed,rightMotorSpeed);
    1026:	ce 01       	movw	r24, r28
    1028:	dd 23       	and	r29, r29
    102a:	0c f4       	brge	.+2      	; 0x102e <line_follow_till_1+0x15e>
    102c:	c2 01       	movw	r24, r4
    102e:	b8 01       	movw	r22, r16
    1030:	11 23       	and	r17, r17
    1032:	0c f4       	brge	.+2      	; 0x1036 <line_follow_till_1+0x166>
    1034:	b2 01       	movw	r22, r4
    1036:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>

		if(Center_white_line>40 && Left_white_line>40 && Right_white_line>40)
    103a:	80 91 76 00 	lds	r24, 0x0076
    103e:	89 32       	cpi	r24, 0x29	; 41
    1040:	08 f4       	brcc	.+2      	; 0x1044 <line_follow_till_1+0x174>
    1042:	a9 c0       	rjmp	.+338    	; 0x1196 <line_follow_till_1+0x2c6>
    1044:	80 91 77 00 	lds	r24, 0x0077
    1048:	89 32       	cpi	r24, 0x29	; 41
    104a:	08 f4       	brcc	.+2      	; 0x104e <line_follow_till_1+0x17e>
    104c:	a4 c0       	rjmp	.+328    	; 0x1196 <line_follow_till_1+0x2c6>
    104e:	80 91 75 00 	lds	r24, 0x0075
    1052:	89 32       	cpi	r24, 0x29	; 41
    1054:	08 f4       	brcc	.+2      	; 0x1058 <line_follow_till_1+0x188>
    1056:	9f c0       	rjmp	.+318    	; 0x1196 <line_follow_till_1+0x2c6>
		{
			update_curr_pos();
    1058:	0e 94 8f 00 	call	0x11e	; 0x11e <update_curr_pos>
			//velocity(40,40);
			//_delay_ms(300);
			//just_forward();
			stop();
    105c:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <stop>
			buzz();
    1060:	0e 94 02 02 	call	0x404	; 0x404 <buzz>
			
			
			if((curr_pos==req_pos) && (curr_pos!=13) && (curr_pos!=7))
    1064:	80 91 b2 00 	lds	r24, 0x00B2
    1068:	90 91 b3 00 	lds	r25, 0x00B3
    106c:	86 15       	cp	r24, r6
    106e:	97 05       	cpc	r25, r7
    1070:	c9 f4       	brne	.+50     	; 0x10a4 <line_follow_till_1+0x1d4>
    1072:	80 91 b2 00 	lds	r24, 0x00B2
    1076:	90 91 b3 00 	lds	r25, 0x00B3
    107a:	8d 30       	cpi	r24, 0x0D	; 13
    107c:	91 05       	cpc	r25, r1
    107e:	91 f0       	breq	.+36     	; 0x10a4 <line_follow_till_1+0x1d4>
    1080:	80 91 b2 00 	lds	r24, 0x00B2
    1084:	90 91 b3 00 	lds	r25, 0x00B3
    1088:	87 30       	cpi	r24, 0x07	; 7
    108a:	91 05       	cpc	r25, r1
    108c:	59 f0       	breq	.+22     	; 0x10a4 <line_follow_till_1+0x1d4>
			{
				forward_mm(210);
    108e:	82 ed       	ldi	r24, 0xD2	; 210
    1090:	90 e0       	ldi	r25, 0x00	; 0
    1092:	0e 94 a5 0b 	call	0x174a	; 0x174a <forward_mm>
				event=1;
    1096:	a1 e0       	ldi	r26, 0x01	; 1
    1098:	b0 e0       	ldi	r27, 0x00	; 0
    109a:	b0 93 9b 00 	sts	0x009B, r27
    109e:	a0 93 9a 00 	sts	0x009A, r26
			stop();
			buzz();
			
			
			if((curr_pos==req_pos) && (curr_pos!=13) && (curr_pos!=7))
			{
    10a2:	69 c0       	rjmp	.+210    	; 0x1176 <line_follow_till_1+0x2a6>
				forward_mm(210);
				event=1;
			}
			else if((curr_pos==req_pos) && (curr_pos==7) && (set_cover == 0))
    10a4:	80 91 b2 00 	lds	r24, 0x00B2
    10a8:	90 91 b3 00 	lds	r25, 0x00B3
    10ac:	86 15       	cp	r24, r6
    10ae:	97 05       	cpc	r25, r7
    10b0:	01 f5       	brne	.+64     	; 0x10f2 <line_follow_till_1+0x222>
    10b2:	80 91 b2 00 	lds	r24, 0x00B2
    10b6:	90 91 b3 00 	lds	r25, 0x00B3
    10ba:	87 30       	cpi	r24, 0x07	; 7
    10bc:	91 05       	cpc	r25, r1
    10be:	c9 f4       	brne	.+50     	; 0x10f2 <line_follow_till_1+0x222>
    10c0:	80 91 9c 00 	lds	r24, 0x009C
    10c4:	90 91 9d 00 	lds	r25, 0x009D
    10c8:	00 97       	sbiw	r24, 0x00	; 0
    10ca:	99 f4       	brne	.+38     	; 0x10f2 <line_follow_till_1+0x222>
			{
				ensure_orient(1);
    10cc:	81 e0       	ldi	r24, 0x01	; 1
    10ce:	90 e0       	ldi	r25, 0x00	; 0
    10d0:	0e 94 03 0b 	call	0x1606	; 0x1606 <ensure_orient>
				set_cover = 50;
    10d4:	e2 e3       	ldi	r30, 0x32	; 50
    10d6:	f0 e0       	ldi	r31, 0x00	; 0
    10d8:	f0 93 9d 00 	sts	0x009D, r31
    10dc:	e0 93 9c 00 	sts	0x009C, r30
				array_index = 0;
    10e0:	50 92 8b 00 	sts	0x008B, r5
    10e4:	40 92 8a 00 	sts	0x008A, r4
				event=0;
    10e8:	50 92 9b 00 	sts	0x009B, r5
    10ec:	40 92 9a 00 	sts	0x009A, r4
			{
				forward_mm(210);
				event=1;
			}
			else if((curr_pos==req_pos) && (curr_pos==7) && (set_cover == 0))
			{
    10f0:	42 c0       	rjmp	.+132    	; 0x1176 <line_follow_till_1+0x2a6>
				ensure_orient(1);
				set_cover = 50;
				array_index = 0;
				event=0;
			}
			else if((curr_pos==req_pos) && (curr_pos==13) && (set_cover == 50))
    10f2:	80 91 b2 00 	lds	r24, 0x00B2
    10f6:	90 91 b3 00 	lds	r25, 0x00B3
    10fa:	86 15       	cp	r24, r6
    10fc:	97 05       	cpc	r25, r7
    10fe:	c9 f5       	brne	.+114    	; 0x1172 <line_follow_till_1+0x2a2>
    1100:	80 91 b2 00 	lds	r24, 0x00B2
    1104:	90 91 b3 00 	lds	r25, 0x00B3
    1108:	8d 30       	cpi	r24, 0x0D	; 13
    110a:	91 05       	cpc	r25, r1
    110c:	91 f5       	brne	.+100    	; 0x1172 <line_follow_till_1+0x2a2>
    110e:	80 91 9c 00 	lds	r24, 0x009C
    1112:	90 91 9d 00 	lds	r25, 0x009D
    1116:	82 33       	cpi	r24, 0x32	; 50
    1118:	91 05       	cpc	r25, r1
    111a:	59 f5       	brne	.+86     	; 0x1172 <line_follow_till_1+0x2a2>
			{
				ensure_orient(2);
    111c:	82 e0       	ldi	r24, 0x02	; 2
    111e:	90 e0       	ldi	r25, 0x00	; 0
    1120:	0e 94 03 0b 	call	0x1606	; 0x1606 <ensure_orient>
				UDR = 0x80;
    1124:	3c b8       	out	0x0c, r3	; 12
    1126:	8f ef       	ldi	r24, 0xFF	; 255
    1128:	9f e3       	ldi	r25, 0x3F	; 63
    112a:	a2 e0       	ldi	r26, 0x02	; 2
    112c:	81 50       	subi	r24, 0x01	; 1
    112e:	90 40       	sbci	r25, 0x00	; 0
    1130:	a0 40       	sbci	r26, 0x00	; 0
    1132:	e1 f7       	brne	.-8      	; 0x112c <line_follow_till_1+0x25c>
    1134:	00 c0       	rjmp	.+0      	; 0x1136 <line_follow_till_1+0x266>
    1136:	00 00       	nop
				_delay_ms(100);
				UDR = 0x80;
    1138:	3c b8       	out	0x0c, r3	; 12
    113a:	8f ef       	ldi	r24, 0xFF	; 255
    113c:	9f e3       	ldi	r25, 0x3F	; 63
    113e:	a2 e0       	ldi	r26, 0x02	; 2
    1140:	81 50       	subi	r24, 0x01	; 1
    1142:	90 40       	sbci	r25, 0x00	; 0
    1144:	a0 40       	sbci	r26, 0x00	; 0
    1146:	e1 f7       	brne	.-8      	; 0x1140 <line_follow_till_1+0x270>
    1148:	00 c0       	rjmp	.+0      	; 0x114a <line_follow_till_1+0x27a>
    114a:	00 00       	nop
				_delay_ms(100);
				UDR = 0x80;
    114c:	3c b8       	out	0x0c, r3	; 12
				home_bit[0]=1;
    114e:	e1 e0       	ldi	r30, 0x01	; 1
    1150:	f0 e0       	ldi	r31, 0x00	; 0
    1152:	a2 ea       	ldi	r26, 0xA2	; 162
    1154:	b0 e0       	ldi	r27, 0x00	; 0
    1156:	11 96       	adiw	r26, 0x01	; 1
    1158:	fc 93       	st	X, r31
    115a:	ee 93       	st	-X, r30
				event=2;
    115c:	82 e0       	ldi	r24, 0x02	; 2
    115e:	90 e0       	ldi	r25, 0x00	; 0
    1160:	90 93 9b 00 	sts	0x009B, r25
    1164:	80 93 9a 00 	sts	0x009A, r24
				start_flag = 1;
    1168:	f0 93 18 01 	sts	0x0118, r31
    116c:	e0 93 17 01 	sts	0x0117, r30
				set_cover = 50;
				array_index = 0;
				event=0;
			}
			else if((curr_pos==req_pos) && (curr_pos==13) && (set_cover == 50))
			{
    1170:	02 c0       	rjmp	.+4      	; 0x1176 <line_follow_till_1+0x2a6>
			else
			{
				//forward();
				//velocity(100,100);
				//_delay_ms(300);
				just_forward();
    1172:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
			}
			if(curr_pos == 11)
    1176:	80 91 b2 00 	lds	r24, 0x00B2
    117a:	90 91 b3 00 	lds	r25, 0x00B3
    117e:	8b 30       	cpi	r24, 0x0B	; 11
    1180:	91 05       	cpc	r25, r1
    1182:	49 f4       	brne	.+18     	; 0x1196 <line_follow_till_1+0x2c6>
			{
				all_xbee_clear();
    1184:	0e 94 df 00 	call	0x1be	; 0x1be <all_xbee_clear>
    1188:	06 c0       	rjmp	.+12     	; 0x1196 <line_follow_till_1+0x2c6>
		if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
		if (rightMotorSpeed < 0) rightMotorSpeed = 0;
		if (leftMotorSpeed < 0) leftMotorSpeed = 0;

		forward();
		velocity(leftMotorSpeed,rightMotorSpeed);
    118a:	44 24       	eor	r4, r4
    118c:	55 24       	eor	r5, r5
				event=0;
			}
			else if((curr_pos==req_pos) && (curr_pos==13) && (set_cover == 50))
			{
				ensure_orient(2);
				UDR = 0x80;
    118e:	0f 2e       	mov	r0, r31
    1190:	f0 e8       	ldi	r31, 0x80	; 128
    1192:	3f 2e       	mov	r3, r31
    1194:	f0 2d       	mov	r31, r0
		forward_mm(150);
		event=1;
	}
	else
	{
		while(curr_pos!=req_pos)
    1196:	80 91 b2 00 	lds	r24, 0x00B2
    119a:	90 91 b3 00 	lds	r25, 0x00B3
    119e:	86 15       	cp	r24, r6
    11a0:	97 05       	cpc	r25, r7
    11a2:	09 f0       	breq	.+2      	; 0x11a6 <line_follow_till_1+0x2d6>
    11a4:	cb ce       	rjmp	.-618    	; 0xf3c <line_follow_till_1+0x6c>
				all_xbee_clear();
			}
		}
	}
  }  	
}
    11a6:	df 91       	pop	r29
    11a8:	cf 91       	pop	r28
    11aa:	1f 91       	pop	r17
    11ac:	0f 91       	pop	r16
    11ae:	ff 90       	pop	r15
    11b0:	ef 90       	pop	r14
    11b2:	df 90       	pop	r13
    11b4:	cf 90       	pop	r12
    11b6:	bf 90       	pop	r11
    11b8:	af 90       	pop	r10
    11ba:	9f 90       	pop	r9
    11bc:	8f 90       	pop	r8
    11be:	7f 90       	pop	r7
    11c0:	6f 90       	pop	r6
    11c2:	5f 90       	pop	r5
    11c4:	4f 90       	pop	r4
    11c6:	3f 90       	pop	r3
    11c8:	08 95       	ret

000011ca <line_follow_till_2>:
           If their are no plants it will simply traverse the other end of the set and come back to the start of the start, i.e., node 41.
  * Example Call: line_follow_till_1()
  */ 

void line_follow_till_2(unsigned int req_pos)
{
    11ca:	3f 92       	push	r3
    11cc:	4f 92       	push	r4
    11ce:	5f 92       	push	r5
    11d0:	6f 92       	push	r6
    11d2:	7f 92       	push	r7
    11d4:	8f 92       	push	r8
    11d6:	9f 92       	push	r9
    11d8:	af 92       	push	r10
    11da:	bf 92       	push	r11
    11dc:	cf 92       	push	r12
    11de:	df 92       	push	r13
    11e0:	ef 92       	push	r14
    11e2:	ff 92       	push	r15
    11e4:	0f 93       	push	r16
    11e6:	1f 93       	push	r17
    11e8:	cf 93       	push	r28
    11ea:	df 93       	push	r29
    11ec:	3c 01       	movw	r6, r24
	if(((req_pos == 27) && (set_cover == 0)) || ((req_pos == 21) && (set_cover == 50)))
    11ee:	8b e1       	ldi	r24, 0x1B	; 27
    11f0:	68 16       	cp	r6, r24
    11f2:	71 04       	cpc	r7, r1
    11f4:	41 f4       	brne	.+16     	; 0x1206 <line_follow_till_2+0x3c>
    11f6:	80 91 9c 00 	lds	r24, 0x009C
    11fa:	90 91 9d 00 	lds	r25, 0x009D
    11fe:	00 97       	sbiw	r24, 0x00	; 0
    1200:	09 f0       	breq	.+2      	; 0x1204 <line_follow_till_2+0x3a>
    1202:	3f c1       	rjmp	.+638    	; 0x1482 <line_follow_till_2+0x2b8>
    1204:	0d c0       	rjmp	.+26     	; 0x1220 <line_follow_till_2+0x56>
    1206:	95 e1       	ldi	r25, 0x15	; 21
    1208:	69 16       	cp	r6, r25
    120a:	71 04       	cpc	r7, r1
    120c:	09 f0       	breq	.+2      	; 0x1210 <line_follow_till_2+0x46>
    120e:	39 c1       	rjmp	.+626    	; 0x1482 <line_follow_till_2+0x2b8>
    1210:	80 91 9c 00 	lds	r24, 0x009C
    1214:	90 91 9d 00 	lds	r25, 0x009D
    1218:	82 33       	cpi	r24, 0x32	; 50
    121a:	91 05       	cpc	r25, r1
    121c:	09 f0       	breq	.+2      	; 0x1220 <line_follow_till_2+0x56>
    121e:	31 c1       	rjmp	.+610    	; 0x1482 <line_follow_till_2+0x2b8>
	{
		forward_mm(150);
    1220:	86 e9       	ldi	r24, 0x96	; 150
    1222:	90 e0       	ldi	r25, 0x00	; 0
    1224:	0e 94 a5 0b 	call	0x174a	; 0x174a <forward_mm>
		event=1;
    1228:	81 e0       	ldi	r24, 0x01	; 1
    122a:	90 e0       	ldi	r25, 0x00	; 0
    122c:	90 93 9b 00 	sts	0x009B, r25
    1230:	80 93 9a 00 	sts	0x009A, r24
  */ 

void line_follow_till_2(unsigned int req_pos)
{
	if(((req_pos == 27) && (set_cover == 0)) || ((req_pos == 21) && (set_cover == 50)))
	{
    1234:	34 c1       	rjmp	.+616    	; 0x149e <line_follow_till_2+0x2d4>
	}
	else
	{
		while(curr_pos!=req_pos)
		{
			Left_white_line = ADC_Conversion(3);
    1236:	83 e0       	ldi	r24, 0x03	; 3
    1238:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    123c:	80 93 77 00 	sts	0x0077, r24
			Center_white_line = ADC_Conversion(4);
    1240:	84 e0       	ldi	r24, 0x04	; 4
    1242:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    1246:	80 93 76 00 	sts	0x0076, r24
			Right_white_line = ADC_Conversion(5);
    124a:	85 e0       	ldi	r24, 0x05	; 5
    124c:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    1250:	80 93 75 00 	sts	0x0075, r24
			error = Right_white_line - Left_white_line;
    1254:	90 e0       	ldi	r25, 0x00	; 0
    1256:	20 91 77 00 	lds	r18, 0x0077
    125a:	82 1b       	sub	r24, r18
    125c:	91 09       	sbc	r25, r1
    125e:	90 93 13 01 	sts	0x0113, r25
    1262:	80 93 12 01 	sts	0x0112, r24
			int motorSpeed = Kp * error + Kd * (error - lastError);
    1266:	60 91 12 01 	lds	r22, 0x0112
    126a:	70 91 13 01 	lds	r23, 0x0113
    126e:	c0 90 67 00 	lds	r12, 0x0067
    1272:	d0 90 68 00 	lds	r13, 0x0068
    1276:	e0 90 69 00 	lds	r14, 0x0069
    127a:	f0 90 6a 00 	lds	r15, 0x006A
    127e:	c0 91 12 01 	lds	r28, 0x0112
    1282:	d0 91 13 01 	lds	r29, 0x0113
    1286:	00 91 78 00 	lds	r16, 0x0078
    128a:	10 91 79 00 	lds	r17, 0x0079
    128e:	80 90 63 00 	lds	r8, 0x0063
    1292:	90 90 64 00 	lds	r9, 0x0064
    1296:	a0 90 65 00 	lds	r10, 0x0065
    129a:	b0 90 66 00 	lds	r11, 0x0066
    129e:	88 27       	eor	r24, r24
    12a0:	77 fd       	sbrc	r23, 7
    12a2:	80 95       	com	r24
    12a4:	98 2f       	mov	r25, r24
    12a6:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__floatsisf>
    12aa:	a7 01       	movw	r20, r14
    12ac:	96 01       	movw	r18, r12
    12ae:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <__mulsf3>
    12b2:	6b 01       	movw	r12, r22
    12b4:	7c 01       	movw	r14, r24
    12b6:	be 01       	movw	r22, r28
    12b8:	60 1b       	sub	r22, r16
    12ba:	71 0b       	sbc	r23, r17
    12bc:	88 27       	eor	r24, r24
    12be:	77 fd       	sbrc	r23, 7
    12c0:	80 95       	com	r24
    12c2:	98 2f       	mov	r25, r24
    12c4:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__floatsisf>
    12c8:	a5 01       	movw	r20, r10
    12ca:	94 01       	movw	r18, r8
    12cc:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <__mulsf3>
    12d0:	9b 01       	movw	r18, r22
    12d2:	ac 01       	movw	r20, r24
    12d4:	c7 01       	movw	r24, r14
    12d6:	b6 01       	movw	r22, r12
    12d8:	0e 94 71 17 	call	0x2ee2	; 0x2ee2 <__addsf3>
    12dc:	0e 94 3d 18 	call	0x307a	; 0x307a <__fixsfsi>
    12e0:	dc 01       	movw	r26, r24
    12e2:	cb 01       	movw	r24, r22
			lastError = error;
    12e4:	20 91 12 01 	lds	r18, 0x0112
    12e8:	30 91 13 01 	lds	r19, 0x0113
    12ec:	30 93 79 00 	sts	0x0079, r19
    12f0:	20 93 78 00 	sts	0x0078, r18
			int rightMotorSpeed = rightBaseSpeed - motorSpeed;
    12f4:	00 91 62 00 	lds	r16, 0x0062
    12f8:	10 e0       	ldi	r17, 0x00	; 0
			int leftMotorSpeed = leftBaseSpeed + motorSpeed;
    12fa:	20 91 61 00 	lds	r18, 0x0061
    12fe:	ec 01       	movw	r28, r24
    1300:	c2 0f       	add	r28, r18
    1302:	d1 1d       	adc	r29, r1
    1304:	08 1b       	sub	r16, r24
    1306:	19 0b       	sbc	r17, r25
    1308:	0e 32       	cpi	r16, 0x2E	; 46
    130a:	11 05       	cpc	r17, r1
    130c:	14 f0       	brlt	.+4      	; 0x1312 <line_follow_till_2+0x148>
    130e:	0d e2       	ldi	r16, 0x2D	; 45
    1310:	10 e0       	ldi	r17, 0x00	; 0
    1312:	ce 32       	cpi	r28, 0x2E	; 46
    1314:	d1 05       	cpc	r29, r1
    1316:	14 f0       	brlt	.+4      	; 0x131c <line_follow_till_2+0x152>
    1318:	cd e2       	ldi	r28, 0x2D	; 45
    131a:	d0 e0       	ldi	r29, 0x00	; 0
			if (rightMotorSpeed > rightMaxSpeed ) rightMotorSpeed = rightMaxSpeed;
			if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
			if (rightMotorSpeed < 0) rightMotorSpeed = 0;
			if (leftMotorSpeed < 0) leftMotorSpeed = 0;

			forward();
    131c:	0e 94 28 0b 	call	0x1650	; 0x1650 <forward>
			velocity(leftMotorSpeed,rightMotorSpeed);
    1320:	ce 01       	movw	r24, r28
    1322:	dd 23       	and	r29, r29
    1324:	0c f4       	brge	.+2      	; 0x1328 <line_follow_till_2+0x15e>
    1326:	c2 01       	movw	r24, r4
    1328:	b8 01       	movw	r22, r16
    132a:	11 23       	and	r17, r17
    132c:	0c f4       	brge	.+2      	; 0x1330 <line_follow_till_2+0x166>
    132e:	b2 01       	movw	r22, r4
    1330:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>

			if(Center_white_line>40 && Left_white_line>40 && Right_white_line>40)
    1334:	80 91 76 00 	lds	r24, 0x0076
    1338:	89 32       	cpi	r24, 0x29	; 41
    133a:	08 f4       	brcc	.+2      	; 0x133e <line_follow_till_2+0x174>
    133c:	a8 c0       	rjmp	.+336    	; 0x148e <line_follow_till_2+0x2c4>
    133e:	80 91 77 00 	lds	r24, 0x0077
    1342:	89 32       	cpi	r24, 0x29	; 41
    1344:	08 f4       	brcc	.+2      	; 0x1348 <line_follow_till_2+0x17e>
    1346:	a3 c0       	rjmp	.+326    	; 0x148e <line_follow_till_2+0x2c4>
    1348:	80 91 75 00 	lds	r24, 0x0075
    134c:	89 32       	cpi	r24, 0x29	; 41
    134e:	08 f4       	brcc	.+2      	; 0x1352 <line_follow_till_2+0x188>
    1350:	9e c0       	rjmp	.+316    	; 0x148e <line_follow_till_2+0x2c4>
			{
				update_curr_pos();
    1352:	0e 94 8f 00 	call	0x11e	; 0x11e <update_curr_pos>
				
				//velocity(40,40);
				//_delay_ms(300);
				//just_forward();
				stop();
    1356:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <stop>
				buzz();
    135a:	0e 94 02 02 	call	0x404	; 0x404 <buzz>
				
				
				if((curr_pos==req_pos) && (curr_pos!=27) && (curr_pos!=21))
    135e:	80 91 b2 00 	lds	r24, 0x00B2
    1362:	90 91 b3 00 	lds	r25, 0x00B3
    1366:	86 15       	cp	r24, r6
    1368:	97 05       	cpc	r25, r7
    136a:	c9 f4       	brne	.+50     	; 0x139e <line_follow_till_2+0x1d4>
    136c:	80 91 b2 00 	lds	r24, 0x00B2
    1370:	90 91 b3 00 	lds	r25, 0x00B3
    1374:	8b 31       	cpi	r24, 0x1B	; 27
    1376:	91 05       	cpc	r25, r1
    1378:	91 f0       	breq	.+36     	; 0x139e <line_follow_till_2+0x1d4>
    137a:	80 91 b2 00 	lds	r24, 0x00B2
    137e:	90 91 b3 00 	lds	r25, 0x00B3
    1382:	85 31       	cpi	r24, 0x15	; 21
    1384:	91 05       	cpc	r25, r1
    1386:	59 f0       	breq	.+22     	; 0x139e <line_follow_till_2+0x1d4>
				{
					forward_mm(210);
    1388:	82 ed       	ldi	r24, 0xD2	; 210
    138a:	90 e0       	ldi	r25, 0x00	; 0
    138c:	0e 94 a5 0b 	call	0x174a	; 0x174a <forward_mm>
					event=1;
    1390:	a1 e0       	ldi	r26, 0x01	; 1
    1392:	b0 e0       	ldi	r27, 0x00	; 0
    1394:	b0 93 9b 00 	sts	0x009B, r27
    1398:	a0 93 9a 00 	sts	0x009A, r26
				stop();
				buzz();
				
				
				if((curr_pos==req_pos) && (curr_pos!=27) && (curr_pos!=21))
				{
    139c:	68 c0       	rjmp	.+208    	; 0x146e <line_follow_till_2+0x2a4>
					forward_mm(210);
					event=1;
				}
				else if((curr_pos==req_pos) && (curr_pos==21) && (set_cover == 0))
    139e:	80 91 b2 00 	lds	r24, 0x00B2
    13a2:	90 91 b3 00 	lds	r25, 0x00B3
    13a6:	86 15       	cp	r24, r6
    13a8:	97 05       	cpc	r25, r7
    13aa:	01 f5       	brne	.+64     	; 0x13ec <line_follow_till_2+0x222>
    13ac:	80 91 b2 00 	lds	r24, 0x00B2
    13b0:	90 91 b3 00 	lds	r25, 0x00B3
    13b4:	85 31       	cpi	r24, 0x15	; 21
    13b6:	91 05       	cpc	r25, r1
    13b8:	c9 f4       	brne	.+50     	; 0x13ec <line_follow_till_2+0x222>
    13ba:	80 91 9c 00 	lds	r24, 0x009C
    13be:	90 91 9d 00 	lds	r25, 0x009D
    13c2:	00 97       	sbiw	r24, 0x00	; 0
    13c4:	99 f4       	brne	.+38     	; 0x13ec <line_follow_till_2+0x222>
				{
					ensure_orient(1);
    13c6:	81 e0       	ldi	r24, 0x01	; 1
    13c8:	90 e0       	ldi	r25, 0x00	; 0
    13ca:	0e 94 03 0b 	call	0x1606	; 0x1606 <ensure_orient>
					event = 0;
    13ce:	50 92 9b 00 	sts	0x009B, r5
    13d2:	40 92 9a 00 	sts	0x009A, r4
					set_cover = 50;
    13d6:	e2 e3       	ldi	r30, 0x32	; 50
    13d8:	f0 e0       	ldi	r31, 0x00	; 0
    13da:	f0 93 9d 00 	sts	0x009D, r31
    13de:	e0 93 9c 00 	sts	0x009C, r30
					array_index = 0;
    13e2:	50 92 8b 00 	sts	0x008B, r5
    13e6:	40 92 8a 00 	sts	0x008A, r4
				{
					forward_mm(210);
					event=1;
				}
				else if((curr_pos==req_pos) && (curr_pos==21) && (set_cover == 0))
				{
    13ea:	41 c0       	rjmp	.+130    	; 0x146e <line_follow_till_2+0x2a4>
					ensure_orient(1);
					event = 0;
					set_cover = 50;
					array_index = 0;
				}
				else if((curr_pos==req_pos) && (curr_pos==27) && (set_cover == 50))
    13ec:	80 91 b2 00 	lds	r24, 0x00B2
    13f0:	90 91 b3 00 	lds	r25, 0x00B3
    13f4:	86 15       	cp	r24, r6
    13f6:	97 05       	cpc	r25, r7
    13f8:	c1 f5       	brne	.+112    	; 0x146a <line_follow_till_2+0x2a0>
    13fa:	80 91 b2 00 	lds	r24, 0x00B2
    13fe:	90 91 b3 00 	lds	r25, 0x00B3
    1402:	8b 31       	cpi	r24, 0x1B	; 27
    1404:	91 05       	cpc	r25, r1
    1406:	89 f5       	brne	.+98     	; 0x146a <line_follow_till_2+0x2a0>
    1408:	80 91 9c 00 	lds	r24, 0x009C
    140c:	90 91 9d 00 	lds	r25, 0x009D
    1410:	82 33       	cpi	r24, 0x32	; 50
    1412:	91 05       	cpc	r25, r1
    1414:	51 f5       	brne	.+84     	; 0x146a <line_follow_till_2+0x2a0>
				{
					ensure_orient(0);
    1416:	c2 01       	movw	r24, r4
    1418:	0e 94 03 0b 	call	0x1606	; 0x1606 <ensure_orient>
					UDR = 0x80;
    141c:	3c b8       	out	0x0c, r3	; 12
    141e:	8f ef       	ldi	r24, 0xFF	; 255
    1420:	9f e3       	ldi	r25, 0x3F	; 63
    1422:	a2 e0       	ldi	r26, 0x02	; 2
    1424:	81 50       	subi	r24, 0x01	; 1
    1426:	90 40       	sbci	r25, 0x00	; 0
    1428:	a0 40       	sbci	r26, 0x00	; 0
    142a:	e1 f7       	brne	.-8      	; 0x1424 <line_follow_till_2+0x25a>
    142c:	00 c0       	rjmp	.+0      	; 0x142e <line_follow_till_2+0x264>
    142e:	00 00       	nop
					_delay_ms(100);
					UDR = 0x80;
    1430:	3c b8       	out	0x0c, r3	; 12
    1432:	8f ef       	ldi	r24, 0xFF	; 255
    1434:	9f e3       	ldi	r25, 0x3F	; 63
    1436:	a2 e0       	ldi	r26, 0x02	; 2
    1438:	81 50       	subi	r24, 0x01	; 1
    143a:	90 40       	sbci	r25, 0x00	; 0
    143c:	a0 40       	sbci	r26, 0x00	; 0
    143e:	e1 f7       	brne	.-8      	; 0x1438 <line_follow_till_2+0x26e>
    1440:	00 c0       	rjmp	.+0      	; 0x1442 <line_follow_till_2+0x278>
    1442:	00 00       	nop
					_delay_ms(100);
					UDR = 0x80;
    1444:	3c b8       	out	0x0c, r3	; 12
					home_bit[0]=1;
    1446:	e1 e0       	ldi	r30, 0x01	; 1
    1448:	f0 e0       	ldi	r31, 0x00	; 0
    144a:	a2 ea       	ldi	r26, 0xA2	; 162
    144c:	b0 e0       	ldi	r27, 0x00	; 0
    144e:	11 96       	adiw	r26, 0x01	; 1
    1450:	fc 93       	st	X, r31
    1452:	ee 93       	st	-X, r30
					event=2;
    1454:	82 e0       	ldi	r24, 0x02	; 2
    1456:	90 e0       	ldi	r25, 0x00	; 0
    1458:	90 93 9b 00 	sts	0x009B, r25
    145c:	80 93 9a 00 	sts	0x009A, r24
					start_flag = 1;
    1460:	f0 93 18 01 	sts	0x0118, r31
    1464:	e0 93 17 01 	sts	0x0117, r30
					event = 0;
					set_cover = 50;
					array_index = 0;
				}
				else if((curr_pos==req_pos) && (curr_pos==27) && (set_cover == 50))
				{
    1468:	02 c0       	rjmp	.+4      	; 0x146e <line_follow_till_2+0x2a4>
				else
				{
					//forward();
					//velocity(100,100);
					//_delay_ms(300);
					just_forward();
    146a:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
				}
				if(curr_pos == 25)
    146e:	80 91 b2 00 	lds	r24, 0x00B2
    1472:	90 91 b3 00 	lds	r25, 0x00B3
    1476:	89 31       	cpi	r24, 0x19	; 25
    1478:	91 05       	cpc	r25, r1
    147a:	49 f4       	brne	.+18     	; 0x148e <line_follow_till_2+0x2c4>
				{
					all_xbee_clear();
    147c:	0e 94 df 00 	call	0x1be	; 0x1be <all_xbee_clear>
    1480:	06 c0       	rjmp	.+12     	; 0x148e <line_follow_till_2+0x2c4>
			if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
			if (rightMotorSpeed < 0) rightMotorSpeed = 0;
			if (leftMotorSpeed < 0) leftMotorSpeed = 0;

			forward();
			velocity(leftMotorSpeed,rightMotorSpeed);
    1482:	44 24       	eor	r4, r4
    1484:	55 24       	eor	r5, r5
					array_index = 0;
				}
				else if((curr_pos==req_pos) && (curr_pos==27) && (set_cover == 50))
				{
					ensure_orient(0);
					UDR = 0x80;
    1486:	0f 2e       	mov	r0, r31
    1488:	f0 e8       	ldi	r31, 0x80	; 128
    148a:	3f 2e       	mov	r3, r31
    148c:	f0 2d       	mov	r31, r0
		forward_mm(150);
		event=1;
	}
	else
	{
		while(curr_pos!=req_pos)
    148e:	80 91 b2 00 	lds	r24, 0x00B2
    1492:	90 91 b3 00 	lds	r25, 0x00B3
    1496:	86 15       	cp	r24, r6
    1498:	97 05       	cpc	r25, r7
    149a:	09 f0       	breq	.+2      	; 0x149e <line_follow_till_2+0x2d4>
    149c:	cc ce       	rjmp	.-616    	; 0x1236 <line_follow_till_2+0x6c>
				}
			}
		}
	}
	
}
    149e:	df 91       	pop	r29
    14a0:	cf 91       	pop	r28
    14a2:	1f 91       	pop	r17
    14a4:	0f 91       	pop	r16
    14a6:	ff 90       	pop	r15
    14a8:	ef 90       	pop	r14
    14aa:	df 90       	pop	r13
    14ac:	cf 90       	pop	r12
    14ae:	bf 90       	pop	r11
    14b0:	af 90       	pop	r10
    14b2:	9f 90       	pop	r9
    14b4:	8f 90       	pop	r8
    14b6:	7f 90       	pop	r7
    14b8:	6f 90       	pop	r6
    14ba:	5f 90       	pop	r5
    14bc:	4f 90       	pop	r4
    14be:	3f 90       	pop	r3
    14c0:	08 95       	ret

000014c2 <just_line>:
		}
	}	 
}

void just_line()
{
    14c2:	8f 92       	push	r8
    14c4:	9f 92       	push	r9
    14c6:	af 92       	push	r10
    14c8:	bf 92       	push	r11
    14ca:	cf 92       	push	r12
    14cc:	df 92       	push	r13
    14ce:	ef 92       	push	r14
    14d0:	ff 92       	push	r15
    14d2:	0f 93       	push	r16
    14d4:	1f 93       	push	r17
    14d6:	cf 93       	push	r28
    14d8:	df 93       	push	r29
	Left_white_line = ADC_Conversion(3);
    14da:	83 e0       	ldi	r24, 0x03	; 3
    14dc:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    14e0:	80 93 77 00 	sts	0x0077, r24
	Center_white_line = ADC_Conversion(4);
    14e4:	84 e0       	ldi	r24, 0x04	; 4
    14e6:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    14ea:	80 93 76 00 	sts	0x0076, r24
	Right_white_line = ADC_Conversion(5);
    14ee:	85 e0       	ldi	r24, 0x05	; 5
    14f0:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    14f4:	80 93 75 00 	sts	0x0075, r24
	error = Right_white_line - Left_white_line;
    14f8:	90 e0       	ldi	r25, 0x00	; 0
    14fa:	20 91 77 00 	lds	r18, 0x0077
    14fe:	82 1b       	sub	r24, r18
    1500:	91 09       	sbc	r25, r1
    1502:	90 93 13 01 	sts	0x0113, r25
    1506:	80 93 12 01 	sts	0x0112, r24
	int motorSpeed = Kp * error + Kd * (error - lastError);
    150a:	60 91 12 01 	lds	r22, 0x0112
    150e:	70 91 13 01 	lds	r23, 0x0113
    1512:	c0 90 67 00 	lds	r12, 0x0067
    1516:	d0 90 68 00 	lds	r13, 0x0068
    151a:	e0 90 69 00 	lds	r14, 0x0069
    151e:	f0 90 6a 00 	lds	r15, 0x006A
    1522:	c0 91 12 01 	lds	r28, 0x0112
    1526:	d0 91 13 01 	lds	r29, 0x0113
    152a:	00 91 78 00 	lds	r16, 0x0078
    152e:	10 91 79 00 	lds	r17, 0x0079
    1532:	80 90 63 00 	lds	r8, 0x0063
    1536:	90 90 64 00 	lds	r9, 0x0064
    153a:	a0 90 65 00 	lds	r10, 0x0065
    153e:	b0 90 66 00 	lds	r11, 0x0066
    1542:	88 27       	eor	r24, r24
    1544:	77 fd       	sbrc	r23, 7
    1546:	80 95       	com	r24
    1548:	98 2f       	mov	r25, r24
    154a:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__floatsisf>
    154e:	a7 01       	movw	r20, r14
    1550:	96 01       	movw	r18, r12
    1552:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <__mulsf3>
    1556:	6b 01       	movw	r12, r22
    1558:	7c 01       	movw	r14, r24
    155a:	be 01       	movw	r22, r28
    155c:	60 1b       	sub	r22, r16
    155e:	71 0b       	sbc	r23, r17
    1560:	88 27       	eor	r24, r24
    1562:	77 fd       	sbrc	r23, 7
    1564:	80 95       	com	r24
    1566:	98 2f       	mov	r25, r24
    1568:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__floatsisf>
    156c:	a5 01       	movw	r20, r10
    156e:	94 01       	movw	r18, r8
    1570:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <__mulsf3>
    1574:	9b 01       	movw	r18, r22
    1576:	ac 01       	movw	r20, r24
    1578:	c7 01       	movw	r24, r14
    157a:	b6 01       	movw	r22, r12
    157c:	0e 94 71 17 	call	0x2ee2	; 0x2ee2 <__addsf3>
    1580:	0e 94 3d 18 	call	0x307a	; 0x307a <__fixsfsi>
	lastError = error;
    1584:	80 91 12 01 	lds	r24, 0x0112
    1588:	90 91 13 01 	lds	r25, 0x0113
    158c:	90 93 79 00 	sts	0x0079, r25
    1590:	80 93 78 00 	sts	0x0078, r24
	int rightMotorSpeed = rightBaseSpeed - motorSpeed;
    1594:	00 91 62 00 	lds	r16, 0x0062
    1598:	10 e0       	ldi	r17, 0x00	; 0
	int leftMotorSpeed = leftBaseSpeed + motorSpeed;
    159a:	80 91 61 00 	lds	r24, 0x0061
    159e:	eb 01       	movw	r28, r22
    15a0:	c8 0f       	add	r28, r24
    15a2:	d1 1d       	adc	r29, r1
    15a4:	06 1b       	sub	r16, r22
    15a6:	17 0b       	sbc	r17, r23
    15a8:	0e 32       	cpi	r16, 0x2E	; 46
    15aa:	11 05       	cpc	r17, r1
    15ac:	14 f0       	brlt	.+4      	; 0x15b2 <just_line+0xf0>
    15ae:	0d e2       	ldi	r16, 0x2D	; 45
    15b0:	10 e0       	ldi	r17, 0x00	; 0
    15b2:	ce 32       	cpi	r28, 0x2E	; 46
    15b4:	d1 05       	cpc	r29, r1
    15b6:	14 f0       	brlt	.+4      	; 0x15bc <just_line+0xfa>
    15b8:	cd e2       	ldi	r28, 0x2D	; 45
    15ba:	d0 e0       	ldi	r29, 0x00	; 0
	if (rightMotorSpeed > rightMaxSpeed ) rightMotorSpeed = rightMaxSpeed;
	if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
	if (rightMotorSpeed < 0) rightMotorSpeed = 0;
	if (leftMotorSpeed < 0) leftMotorSpeed = 0;

	forward();
    15bc:	0e 94 28 0b 	call	0x1650	; 0x1650 <forward>
	velocity(leftMotorSpeed,rightMotorSpeed);
    15c0:	ce 01       	movw	r24, r28
    15c2:	dd 23       	and	r29, r29
    15c4:	14 f4       	brge	.+4      	; 0x15ca <just_line+0x108>
    15c6:	80 e0       	ldi	r24, 0x00	; 0
    15c8:	90 e0       	ldi	r25, 0x00	; 0
    15ca:	b8 01       	movw	r22, r16
    15cc:	11 23       	and	r17, r17
    15ce:	14 f4       	brge	.+4      	; 0x15d4 <just_line+0x112>
    15d0:	60 e0       	ldi	r22, 0x00	; 0
    15d2:	70 e0       	ldi	r23, 0x00	; 0
    15d4:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>
}
    15d8:	df 91       	pop	r29
    15da:	cf 91       	pop	r28
    15dc:	1f 91       	pop	r17
    15de:	0f 91       	pop	r16
    15e0:	ff 90       	pop	r15
    15e2:	ef 90       	pop	r14
    15e4:	df 90       	pop	r13
    15e6:	cf 90       	pop	r12
    15e8:	bf 90       	pop	r11
    15ea:	af 90       	pop	r10
    15ec:	9f 90       	pop	r9
    15ee:	8f 90       	pop	r8
    15f0:	08 95       	ret

000015f2 <motion_set>:
void motion_set (unsigned char Direction)
{
	unsigned char PortBRestore = 0;

	Direction &= 0x0F; 			// removing upper nibbel as it is not needed
	PortBRestore = PORTB; 			// reading the PORTB's original status
    15f2:	98 b3       	in	r25, 0x18	; 24
	PortBRestore &= 0xF0; 			// setting lower direction nibbel to 0
    15f4:	90 7f       	andi	r25, 0xF0	; 240

void motion_set (unsigned char Direction)
{
	unsigned char PortBRestore = 0;

	Direction &= 0x0F; 			// removing upper nibbel as it is not needed
    15f6:	8f 70       	andi	r24, 0x0F	; 15
	PortBRestore = PORTB; 			// reading the PORTB's original status
	PortBRestore &= 0xF0; 			// setting lower direction nibbel to 0
	PortBRestore |= Direction; 	// adding lower nibbel for direction command and restoring the PORTB status
    15f8:	98 2b       	or	r25, r24
	PORTB = PortBRestore; 			// setting the command to the port
    15fa:	98 bb       	out	0x18, r25	; 24
}
    15fc:	08 95       	ret

000015fe <stop>:
  * Logic: This function sets up the motion pins of the bot so that the bot stops
  * Example Call: stop()
  */ 
void stop (void)
{
  motion_set(0x00);
    15fe:	80 e0       	ldi	r24, 0x00	; 0
    1600:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <motion_set>
}
    1604:	08 95       	ret

00001606 <ensure_orient>:
  * Logic: This function is used for rotating the bot by 90 degrees right till the required orientation is achieved. 
  * Example Call: ensure_orient(0)
  */

void ensure_orient(unsigned int req_orient)
{
    1606:	ef 92       	push	r14
    1608:	ff 92       	push	r15
    160a:	0f 93       	push	r16
    160c:	1f 93       	push	r17
    160e:	cf 93       	push	r28
    1610:	df 93       	push	r29
    1612:	8c 01       	movw	r16, r24
	stop();
    1614:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <stop>
	int chethan=0;
    1618:	c0 e0       	ldi	r28, 0x00	; 0
    161a:	d0 e0       	ldi	r29, 0x00	; 0
	{   
		if(chethan==0)
		{
			//turn(1);
			turn_right();
			chethan=1;
    161c:	ee 24       	eor	r14, r14
    161e:	ff 24       	eor	r15, r15
    1620:	e3 94       	inc	r14

void ensure_orient(unsigned int req_orient)
{
	stop();
	int chethan=0;
	while(req_orient!=orient)
    1622:	08 c0       	rjmp	.+16     	; 0x1634 <ensure_orient+0x2e>
	{   
		if(chethan==0)
    1624:	20 97       	sbiw	r28, 0x00	; 0
    1626:	21 f4       	brne	.+8      	; 0x1630 <ensure_orient+0x2a>
		{
			//turn(1);
			turn_right();
    1628:	0e 94 27 01 	call	0x24e	; 0x24e <turn_right>
			chethan=1;
    162c:	e7 01       	movw	r28, r14
    162e:	02 c0       	rjmp	.+4      	; 0x1634 <ensure_orient+0x2e>
		}		
		else
		{
			
			turn_right_ensure();
    1630:	0e 94 a3 04 	call	0x946	; 0x946 <turn_right_ensure>

void ensure_orient(unsigned int req_orient)
{
	stop();
	int chethan=0;
	while(req_orient!=orient)
    1634:	80 91 f6 00 	lds	r24, 0x00F6
    1638:	90 91 f7 00 	lds	r25, 0x00F7
    163c:	08 17       	cp	r16, r24
    163e:	19 07       	cpc	r17, r25
    1640:	89 f7       	brne	.-30     	; 0x1624 <ensure_orient+0x1e>
		{
			
			turn_right_ensure();
		}
	}
}
    1642:	df 91       	pop	r29
    1644:	cf 91       	pop	r28
    1646:	1f 91       	pop	r17
    1648:	0f 91       	pop	r16
    164a:	ff 90       	pop	r15
    164c:	ef 90       	pop	r14
    164e:	08 95       	ret

00001650 <forward>:
  * Example Call: forward()
  */ 

void forward (void)         //both wheels forward
{
	motion_set(0x06);
    1650:	86 e0       	ldi	r24, 0x06	; 6
    1652:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <motion_set>
}
    1656:	08 95       	ret

00001658 <__vector_2>:
  * Logic: This interrupt service routine is called on receiving pulses from right position encoder.
  * Example Call: N.A
  */

ISR(INT1_vect)
{
    1658:	1f 92       	push	r1
    165a:	0f 92       	push	r0
    165c:	0f b6       	in	r0, 0x3f	; 63
    165e:	0f 92       	push	r0
    1660:	11 24       	eor	r1, r1
    1662:	8f 93       	push	r24
    1664:	9f 93       	push	r25
	++shaft_count_right;
    1666:	80 91 7e 00 	lds	r24, 0x007E
    166a:	90 91 7f 00 	lds	r25, 0x007F
    166e:	01 96       	adiw	r24, 0x01	; 1
    1670:	90 93 7f 00 	sts	0x007F, r25
    1674:	80 93 7e 00 	sts	0x007E, r24
}
    1678:	9f 91       	pop	r25
    167a:	8f 91       	pop	r24
    167c:	0f 90       	pop	r0
    167e:	0f be       	out	0x3f, r0	; 63
    1680:	0f 90       	pop	r0
    1682:	1f 90       	pop	r1
    1684:	18 95       	reti

00001686 <__vector_1>:
  * Logic: This interrupt service routine is called on receiving pulses from left position encoder.
  * Example Call: N.A
  */

ISR(INT0_vect)
{
    1686:	1f 92       	push	r1
    1688:	0f 92       	push	r0
    168a:	0f b6       	in	r0, 0x3f	; 63
    168c:	0f 92       	push	r0
    168e:	11 24       	eor	r1, r1
    1690:	8f 93       	push	r24
    1692:	9f 93       	push	r25
    1694:	af 93       	push	r26
    1696:	bf 93       	push	r27
	++shaft_count_left;
    1698:	80 91 7a 00 	lds	r24, 0x007A
    169c:	90 91 7b 00 	lds	r25, 0x007B
    16a0:	a0 91 7c 00 	lds	r26, 0x007C
    16a4:	b0 91 7d 00 	lds	r27, 0x007D
    16a8:	01 96       	adiw	r24, 0x01	; 1
    16aa:	a1 1d       	adc	r26, r1
    16ac:	b1 1d       	adc	r27, r1
    16ae:	80 93 7a 00 	sts	0x007A, r24
    16b2:	90 93 7b 00 	sts	0x007B, r25
    16b6:	a0 93 7c 00 	sts	0x007C, r26
    16ba:	b0 93 7d 00 	sts	0x007D, r27
}
    16be:	bf 91       	pop	r27
    16c0:	af 91       	pop	r26
    16c2:	9f 91       	pop	r25
    16c4:	8f 91       	pop	r24
    16c6:	0f 90       	pop	r0
    16c8:	0f be       	out	0x3f, r0	; 63
    16ca:	0f 90       	pop	r0
    16cc:	1f 90       	pop	r1
    16ce:	18 95       	reti

000016d0 <linear_distance_mm>:
void linear_distance_mm(unsigned int DistanceInMM)
{
 	req_shaft_count=0;
	req_shaft_count_int=0;

 	req_shaft_count = (float)(DistanceInMM / 12.92);
    16d0:	bc 01       	movw	r22, r24
    16d2:	80 e0       	ldi	r24, 0x00	; 0
    16d4:	90 e0       	ldi	r25, 0x00	; 0
    16d6:	0e 94 6e 18 	call	0x30dc	; 0x30dc <__floatunsisf>
    16da:	22 e5       	ldi	r18, 0x52	; 82
    16dc:	38 eb       	ldi	r19, 0xB8	; 184
    16de:	4e e4       	ldi	r20, 0x4E	; 78
    16e0:	51 e4       	ldi	r21, 0x41	; 65
    16e2:	0e 94 d5 17 	call	0x2faa	; 0x2faa <__divsf3>
    16e6:	26 2f       	mov	r18, r22
    16e8:	37 2f       	mov	r19, r23
    16ea:	f8 2f       	mov	r31, r24
    16ec:	e9 2f       	mov	r30, r25
    16ee:	46 2f       	mov	r20, r22
    16f0:	57 2f       	mov	r21, r23
    16f2:	68 2f       	mov	r22, r24
    16f4:	79 2f       	mov	r23, r25
    16f6:	40 93 82 00 	sts	0x0082, r20
    16fa:	50 93 83 00 	sts	0x0083, r21
    16fe:	60 93 84 00 	sts	0x0084, r22
    1702:	70 93 85 00 	sts	0x0085, r23
 	req_shaft_count_int = (unsigned long int)req_shaft_count;
    1706:	82 2f       	mov	r24, r18
    1708:	93 2f       	mov	r25, r19
    170a:	af 2f       	mov	r26, r31
    170c:	be 2f       	mov	r27, r30
    170e:	bc 01       	movw	r22, r24
    1710:	cd 01       	movw	r24, r26
    1712:	0e 94 42 18 	call	0x3084	; 0x3084 <__fixunssfsi>
    1716:	dc 01       	movw	r26, r24
    1718:	cb 01       	movw	r24, r22
    171a:	90 93 81 00 	sts	0x0081, r25
    171e:	80 93 80 00 	sts	0x0080, r24

 	shaft_count_right=0;
    1722:	10 92 7f 00 	sts	0x007F, r1
    1726:	10 92 7e 00 	sts	0x007E, r1
 	while(1)
 	{
		 just_line();
    172a:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <just_line>
  		if(shaft_count_right > req_shaft_count_int)
    172e:	20 91 7e 00 	lds	r18, 0x007E
    1732:	30 91 7f 00 	lds	r19, 0x007F
    1736:	80 91 80 00 	lds	r24, 0x0080
    173a:	90 91 81 00 	lds	r25, 0x0081
    173e:	82 17       	cp	r24, r18
    1740:	93 07       	cpc	r25, r19
    1742:	98 f7       	brcc	.-26     	; 0x172a <linear_distance_mm+0x5a>
  		{
  			break;
  		}
 	}
 	stop(); //Stop robot
    1744:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <stop>
}
    1748:	08 95       	ret

0000174a <forward_mm>:
  * Logic: This function sets up the motion pins of the bot for forward movement and calls linear_distance_mm("distance in mm") function for the bot to move by a specific distance.
  * Example Call: forward_mm(100)
  */ 

void forward_mm(unsigned int DistanceInMM)
{
    174a:	cf 93       	push	r28
    174c:	df 93       	push	r29
    174e:	ec 01       	movw	r28, r24
 	forward();
    1750:	0e 94 28 0b 	call	0x1650	; 0x1650 <forward>
 	linear_distance_mm(DistanceInMM);
    1754:	ce 01       	movw	r24, r28
    1756:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <linear_distance_mm>
}
    175a:	df 91       	pop	r29
    175c:	cf 91       	pop	r28
    175e:	08 95       	ret

00001760 <angle_rotate>:
  * Logic: This function is used for rotating the bot by a specific angle.
  * Example Call: angle_rotate(100)
  */

void angle_rotate(unsigned int deg)
{
    1760:	1f 93       	push	r17
    1762:	cf 93       	push	r28
    1764:	df 93       	push	r29
	req_shaft_count=0;
	req_shaft_count_int=0;

	req_shaft_count=(float)(deg/12.85);
    1766:	bc 01       	movw	r22, r24
    1768:	80 e0       	ldi	r24, 0x00	; 0
    176a:	90 e0       	ldi	r25, 0x00	; 0
    176c:	0e 94 6e 18 	call	0x30dc	; 0x30dc <__floatunsisf>
    1770:	2a e9       	ldi	r18, 0x9A	; 154
    1772:	39 e9       	ldi	r19, 0x99	; 153
    1774:	4d e4       	ldi	r20, 0x4D	; 77
    1776:	51 e4       	ldi	r21, 0x41	; 65
    1778:	0e 94 d5 17 	call	0x2faa	; 0x2faa <__divsf3>
    177c:	26 2f       	mov	r18, r22
    177e:	37 2f       	mov	r19, r23
    1780:	f8 2f       	mov	r31, r24
    1782:	e9 2f       	mov	r30, r25
    1784:	46 2f       	mov	r20, r22
    1786:	57 2f       	mov	r21, r23
    1788:	68 2f       	mov	r22, r24
    178a:	79 2f       	mov	r23, r25
    178c:	40 93 82 00 	sts	0x0082, r20
    1790:	50 93 83 00 	sts	0x0083, r21
    1794:	60 93 84 00 	sts	0x0084, r22
    1798:	70 93 85 00 	sts	0x0085, r23
	req_shaft_count_int=(unsigned long int)req_shaft_count;
    179c:	82 2f       	mov	r24, r18
    179e:	93 2f       	mov	r25, r19
    17a0:	af 2f       	mov	r26, r31
    17a2:	be 2f       	mov	r27, r30
    17a4:	bc 01       	movw	r22, r24
    17a6:	cd 01       	movw	r24, r26
    17a8:	0e 94 42 18 	call	0x3084	; 0x3084 <__fixunssfsi>
    17ac:	dc 01       	movw	r26, r24
    17ae:	cb 01       	movw	r24, r22
    17b0:	fc 01       	movw	r30, r24
    17b2:	90 93 81 00 	sts	0x0081, r25
    17b6:	80 93 80 00 	sts	0x0080, r24
	shaft_count_left=0;
    17ba:	10 92 7a 00 	sts	0x007A, r1
    17be:	10 92 7b 00 	sts	0x007B, r1
    17c2:	10 92 7c 00 	sts	0x007C, r1
    17c6:	10 92 7d 00 	sts	0x007D, r1
	shaft_count_right=0;
    17ca:	10 92 7f 00 	sts	0x007F, r1
    17ce:	10 92 7e 00 	sts	0x007E, r1

	while(1)
	{
		if((shaft_count_right >= req_shaft_count_int)|(shaft_count_left >= req_shaft_count_int))
    17d2:	d1 e0       	ldi	r29, 0x01	; 1
    17d4:	10 e0       	ldi	r17, 0x00	; 0
    17d6:	ac 01       	movw	r20, r24
    17d8:	60 e0       	ldi	r22, 0x00	; 0
    17da:	70 e0       	ldi	r23, 0x00	; 0
    17dc:	20 91 7e 00 	lds	r18, 0x007E
    17e0:	30 91 7f 00 	lds	r19, 0x007F
    17e4:	80 91 7a 00 	lds	r24, 0x007A
    17e8:	90 91 7b 00 	lds	r25, 0x007B
    17ec:	a0 91 7c 00 	lds	r26, 0x007C
    17f0:	b0 91 7d 00 	lds	r27, 0x007D
    17f4:	cd 2f       	mov	r28, r29
    17f6:	2e 17       	cp	r18, r30
    17f8:	3f 07       	cpc	r19, r31
    17fa:	08 f4       	brcc	.+2      	; 0x17fe <angle_rotate+0x9e>
    17fc:	c1 2f       	mov	r28, r17
    17fe:	cc 23       	and	r28, r28
    1800:	49 f4       	brne	.+18     	; 0x1814 <angle_rotate+0xb4>
    1802:	2d 2f       	mov	r18, r29
    1804:	84 17       	cp	r24, r20
    1806:	95 07       	cpc	r25, r21
    1808:	a6 07       	cpc	r26, r22
    180a:	b7 07       	cpc	r27, r23
    180c:	08 f4       	brcc	.+2      	; 0x1810 <angle_rotate+0xb0>
    180e:	21 2f       	mov	r18, r17
    1810:	22 23       	and	r18, r18
    1812:	21 f3       	breq	.-56     	; 0x17dc <angle_rotate+0x7c>
		break;
 	}
	stop();
    1814:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <stop>
}
    1818:	df 91       	pop	r29
    181a:	cf 91       	pop	r28
    181c:	1f 91       	pop	r17
    181e:	08 95       	ret

00001820 <back>:
  * Example Call: back()
  */ 

void back (void)
{
	motion_set(0x09);
    1820:	89 e0       	ldi	r24, 0x09	; 9
    1822:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <motion_set>
}
    1826:	08 95       	ret

00001828 <left>:
  * Logic: This function sets up the motion pins of the bot to set the bot so that it turns left
  * Example Call: left()
  */ 
void left (void) 
{
  motion_set(0x05);
    1828:	85 e0       	ldi	r24, 0x05	; 5
    182a:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <motion_set>
}
    182e:	08 95       	ret

00001830 <right>:
  * Logic: This function sets up the motion pins of the bot so that the bot turns right
  * Example Call: right()
  */ 
void right (void) 
{
  motion_set(0x0A);
    1830:	8a e0       	ldi	r24, 0x0A	; 10
    1832:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <motion_set>
}
    1836:	08 95       	ret

00001838 <soft_left>:
  * Logic: This function sets up the motion pins of the bot so that the bot takes a soft left turn
  * Example Call: soft_left()
  */ 
void soft_left (void) //Left wheel stationary, Right wheel forward
{
 motion_set(0x04);
    1838:	84 e0       	ldi	r24, 0x04	; 4
    183a:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <motion_set>
}
    183e:	08 95       	ret

00001840 <soft_right>:
  * Logic: This function sets up the motion pins of the bot so that the bot takes a soft right turn
  * Example Call: soft_right()
  */ 
void soft_right (void) //Left wheel forward, Right wheel is stationary
{
 motion_set(0x02);
    1840:	82 e0       	ldi	r24, 0x02	; 2
    1842:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <motion_set>
}
    1846:	08 95       	ret

00001848 <soft_left_2>:
  * Logic: This function sets up the motion pins of the bot so that the bot takes a soft left turn in the reverse direction
  * Example Call: soft_left_2()
  */ 
void soft_left_2 (void) //Left wheel backward, right wheel stationary
{
 motion_set(0x01);
    1848:	81 e0       	ldi	r24, 0x01	; 1
    184a:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <motion_set>
}
    184e:	08 95       	ret

00001850 <soft_right_2>:
  * Logic: This function sets up the motion pins of the bot so that the bot takes a soft right turn in the reverse direction
  * Example Call: soft_right_2()
  */ 
void soft_right_2 (void) //Left wheel stationary, Right wheel backward
{
 motion_set(0x08);
    1850:	88 e0       	ldi	r24, 0x08	; 8
    1852:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <motion_set>
}
    1856:	08 95       	ret

00001858 <left_degrees>:
  * Logic: This function is used for setting pins for left turn and rotating the bot by a specific angle.
  * Example Call: left_degrees(100)
  */

void left_degrees(unsigned int Degrees)
{
    1858:	cf 93       	push	r28
    185a:	df 93       	push	r29
    185c:	ec 01       	movw	r28, r24
 	left();
    185e:	0e 94 14 0c 	call	0x1828	; 0x1828 <left>
 	angle_rotate(Degrees);
    1862:	ce 01       	movw	r24, r28
    1864:	0e 94 b0 0b 	call	0x1760	; 0x1760 <angle_rotate>
}
    1868:	df 91       	pop	r29
    186a:	cf 91       	pop	r28
    186c:	08 95       	ret

0000186e <right_degrees>:
  * Logic: This function is used for setting pins for right turn and rotating the bot by a specific angle.
  * Example Call: right_degrees(100)
  */

void right_degrees(unsigned int Degrees)
{
    186e:	cf 93       	push	r28
    1870:	df 93       	push	r29
    1872:	ec 01       	movw	r28, r24

 	right();
    1874:	0e 94 18 0c 	call	0x1830	; 0x1830 <right>
 	angle_rotate(Degrees);
    1878:	ce 01       	movw	r24, r28
    187a:	0e 94 b0 0b 	call	0x1760	; 0x1760 <angle_rotate>
}
    187e:	df 91       	pop	r29
    1880:	cf 91       	pop	r28
    1882:	08 95       	ret

00001884 <turn>:
void turn(unsigned int direction)
{
    //0 for left
    //1 for right

    if(direction==0)
    1884:	00 97       	sbiw	r24, 0x00	; 0
    1886:	69 f5       	brne	.+90     	; 0x18e2 <turn+0x5e>
    {
        left_degrees(80);
    1888:	80 e5       	ldi	r24, 0x50	; 80
    188a:	90 e0       	ldi	r25, 0x00	; 0
    188c:	0e 94 2c 0c 	call	0x1858	; 0x1858 <left_degrees>
        Center_white_line = ADC_Conversion(4);	//Getting data of Center WL Sensor
    1890:	84 e0       	ldi	r24, 0x04	; 4
    1892:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    1896:	80 93 76 00 	sts	0x0076, r24
        while(Center_white_line < 60)
    189a:	8c 33       	cpi	r24, 0x3C	; 60
    189c:	48 f4       	brcc	.+18     	; 0x18b0 <turn+0x2c>
        {
            left();
    189e:	0e 94 14 0c 	call	0x1828	; 0x1828 <left>
            Center_white_line = ADC_Conversion(4);
    18a2:	84 e0       	ldi	r24, 0x04	; 4
    18a4:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    18a8:	80 93 76 00 	sts	0x0076, r24

    if(direction==0)
    {
        left_degrees(80);
        Center_white_line = ADC_Conversion(4);	//Getting data of Center WL Sensor
        while(Center_white_line < 60)
    18ac:	8c 33       	cpi	r24, 0x3C	; 60
    18ae:	b8 f3       	brcs	.-18     	; 0x189e <turn+0x1a>
        {
            left();
            Center_white_line = ADC_Conversion(4);
        }
        stop();
    18b0:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <stop>
		if(orient==0)orient=3;
    18b4:	80 91 f6 00 	lds	r24, 0x00F6
    18b8:	90 91 f7 00 	lds	r25, 0x00F7
    18bc:	00 97       	sbiw	r24, 0x00	; 0
    18be:	39 f4       	brne	.+14     	; 0x18ce <turn+0x4a>
    18c0:	83 e0       	ldi	r24, 0x03	; 3
    18c2:	90 e0       	ldi	r25, 0x00	; 0
    18c4:	90 93 f7 00 	sts	0x00F7, r25
    18c8:	80 93 f6 00 	sts	0x00F6, r24
    18cc:	08 95       	ret
		else
		orient=orient-1;
    18ce:	80 91 f6 00 	lds	r24, 0x00F6
    18d2:	90 91 f7 00 	lds	r25, 0x00F7
    18d6:	01 97       	sbiw	r24, 0x01	; 1
    18d8:	90 93 f7 00 	sts	0x00F7, r25
    18dc:	80 93 f6 00 	sts	0x00F6, r24
    18e0:	08 95       	ret
    }
    else if(direction == 1)
    18e2:	81 30       	cpi	r24, 0x01	; 1
    18e4:	91 05       	cpc	r25, r1
    18e6:	11 f5       	brne	.+68     	; 0x192c <turn+0xa8>
    {
        right_degrees(80);
    18e8:	80 e5       	ldi	r24, 0x50	; 80
    18ea:	90 e0       	ldi	r25, 0x00	; 0
    18ec:	0e 94 37 0c 	call	0x186e	; 0x186e <right_degrees>
        Center_white_line = ADC_Conversion(4);	//Getting data of Center WL Sensor
    18f0:	84 e0       	ldi	r24, 0x04	; 4
    18f2:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    18f6:	80 93 76 00 	sts	0x0076, r24
        while(Center_white_line < 60)
    18fa:	8c 33       	cpi	r24, 0x3C	; 60
    18fc:	48 f4       	brcc	.+18     	; 0x1910 <turn+0x8c>
        {
            right();
    18fe:	0e 94 18 0c 	call	0x1830	; 0x1830 <right>
            Center_white_line = ADC_Conversion(4);
    1902:	84 e0       	ldi	r24, 0x04	; 4
    1904:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    1908:	80 93 76 00 	sts	0x0076, r24
    }
    else if(direction == 1)
    {
        right_degrees(80);
        Center_white_line = ADC_Conversion(4);	//Getting data of Center WL Sensor
        while(Center_white_line < 60)
    190c:	8c 33       	cpi	r24, 0x3C	; 60
    190e:	b8 f3       	brcs	.-18     	; 0x18fe <turn+0x7a>
        {
            right();
            Center_white_line = ADC_Conversion(4);
        }
        stop();
    1910:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <stop>
		orient=(orient+1)%4;
    1914:	80 91 f6 00 	lds	r24, 0x00F6
    1918:	90 91 f7 00 	lds	r25, 0x00F7
    191c:	01 96       	adiw	r24, 0x01	; 1
    191e:	83 70       	andi	r24, 0x03	; 3
    1920:	90 70       	andi	r25, 0x00	; 0
    1922:	90 93 f7 00 	sts	0x00F7, r25
    1926:	80 93 f6 00 	sts	0x00F6, r24
    192a:	08 95       	ret
    }
	else if(direction == 2)
    192c:	82 30       	cpi	r24, 0x02	; 2
    192e:	91 05       	cpc	r25, r1
    1930:	09 f5       	brne	.+66     	; 0x1974 <turn+0xf0>
	{
		right_degrees(150);
    1932:	86 e9       	ldi	r24, 0x96	; 150
    1934:	90 e0       	ldi	r25, 0x00	; 0
    1936:	0e 94 37 0c 	call	0x186e	; 0x186e <right_degrees>
		Center_white_line = ADC_Conversion(4);	//Getting data of Center WL Sensor
    193a:	84 e0       	ldi	r24, 0x04	; 4
    193c:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    1940:	80 93 76 00 	sts	0x0076, r24
		while(Center_white_line < 60)
    1944:	8c 33       	cpi	r24, 0x3C	; 60
    1946:	48 f4       	brcc	.+18     	; 0x195a <turn+0xd6>
		{
			right();
    1948:	0e 94 18 0c 	call	0x1830	; 0x1830 <right>
			Center_white_line = ADC_Conversion(4);
    194c:	84 e0       	ldi	r24, 0x04	; 4
    194e:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    1952:	80 93 76 00 	sts	0x0076, r24
    }
	else if(direction == 2)
	{
		right_degrees(150);
		Center_white_line = ADC_Conversion(4);	//Getting data of Center WL Sensor
		while(Center_white_line < 60)
    1956:	8c 33       	cpi	r24, 0x3C	; 60
    1958:	b8 f3       	brcs	.-18     	; 0x1948 <turn+0xc4>
		{
			right();
			Center_white_line = ADC_Conversion(4);
		}
		stop();
    195a:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <stop>
		orient=(orient+2)%4;
    195e:	80 91 f6 00 	lds	r24, 0x00F6
    1962:	90 91 f7 00 	lds	r25, 0x00F7
    1966:	02 96       	adiw	r24, 0x02	; 2
    1968:	83 70       	andi	r24, 0x03	; 3
    196a:	90 70       	andi	r25, 0x00	; 0
    196c:	90 93 f7 00 	sts	0x00F7, r25
    1970:	80 93 f6 00 	sts	0x00F6, r24
    1974:	08 95       	ret

00001976 <ir_check>:
  * Example Call: ir_check()
  */

void ir_check(void)
{
	Side_IR_Sensor = ADC_Conversion(1);    //Getting data of Side IR Proximity Sensor Sensor
    1976:	81 e0       	ldi	r24, 0x01	; 1
    1978:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    197c:	80 93 73 00 	sts	0x0073, r24

	if((Side_IR_Sensor > IR_THRESHOLD_MIN) && (Side_IR_Sensor < IR_THRESHOLD_MAX))
    1980:	85 56       	subi	r24, 0x65	; 101
    1982:	84 30       	cpi	r24, 0x04	; 4
    1984:	78 f4       	brcc	.+30     	; 0x19a4 <ir_check+0x2e>
	{
		stop();
    1986:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <stop>
		buzz();
    198a:	0e 94 02 02 	call	0x404	; 0x404 <buzz>
    198e:	8f ef       	ldi	r24, 0xFF	; 255
    1990:	9f ef       	ldi	r25, 0xFF	; 255
    1992:	a9 e5       	ldi	r26, 0x59	; 89
    1994:	81 50       	subi	r24, 0x01	; 1
    1996:	90 40       	sbci	r25, 0x00	; 0
    1998:	a0 40       	sbci	r26, 0x00	; 0
    199a:	e1 f7       	brne	.-8      	; 0x1994 <ir_check+0x1e>
    199c:	00 c0       	rjmp	.+0      	; 0x199e <ir_check+0x28>
    199e:	00 00       	nop
		_delay_ms(4000);
		forward();
    19a0:	0e 94 28 0b 	call	0x1650	; 0x1650 <forward>
    19a4:	08 95       	ret

000019a6 <timer1_init_color>:
  * Example Call: timer1_init_color()
  */ 

void timer1_init_color(void)
{
 TCCR1B = 0x00; //stop
    19a6:	1e bc       	out	0x2e, r1	; 46
 TCNT1H = 0xE3; //setup
    19a8:	83 ee       	ldi	r24, 0xE3	; 227
    19aa:	8d bd       	out	0x2d, r24	; 45
 TCNT1L = 0xE1;
    19ac:	81 ee       	ldi	r24, 0xE1	; 225
    19ae:	8c bd       	out	0x2c, r24	; 44
 OCR1AH = 0x1C;
    19b0:	9c e1       	ldi	r25, 0x1C	; 28
    19b2:	9b bd       	out	0x2b, r25	; 43
 OCR1AL = 0x1F;
    19b4:	8f e1       	ldi	r24, 0x1F	; 31
    19b6:	8a bd       	out	0x2a, r24	; 42
 OCR1BH = 0x1C;
    19b8:	99 bd       	out	0x29, r25	; 41
 OCR1BL = 0x1F;
    19ba:	88 bd       	out	0x28, r24	; 40
 ICR1H  = 0x1C;
    19bc:	97 bd       	out	0x27, r25	; 39
 ICR1L  = 0x1F;
    19be:	86 bd       	out	0x26, r24	; 38
 TCCR1A = 0x00;
    19c0:	1f bc       	out	0x2f, r1	; 47
 TCCR1B = 0x05; //start Timer, INTERRUPT FOR COLOR SENSOR CONFIGURED FOR FALLING EDGE THROUGH BIT6 OF TCCR1B (ICES1 BIT)
    19c2:	85 e0       	ldi	r24, 0x05	; 5
    19c4:	8e bd       	out	0x2e, r24	; 46
}
    19c6:	08 95       	ret

000019c8 <__vector_5>:
  * Output: None
  * Logic: Increment the pulse count on receiving pulse from the color sensor
  */ 

ISR(TIMER1_CAPT_vect)// INPUT CAPTURE ROUTINE
{
    19c8:	1f 92       	push	r1
    19ca:	0f 92       	push	r0
    19cc:	0f b6       	in	r0, 0x3f	; 63
    19ce:	0f 92       	push	r0
    19d0:	11 24       	eor	r1, r1
    19d2:	8f 93       	push	r24
    19d4:	9f 93       	push	r25
    19d6:	af 93       	push	r26
    19d8:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
    19da:	80 91 6f 00 	lds	r24, 0x006F
    19de:	90 91 70 00 	lds	r25, 0x0070
    19e2:	a0 91 71 00 	lds	r26, 0x0071
    19e6:	b0 91 72 00 	lds	r27, 0x0072
    19ea:	01 96       	adiw	r24, 0x01	; 1
    19ec:	a1 1d       	adc	r26, r1
    19ee:	b1 1d       	adc	r27, r1
    19f0:	80 93 6f 00 	sts	0x006F, r24
    19f4:	90 93 70 00 	sts	0x0070, r25
    19f8:	a0 93 71 00 	sts	0x0071, r26
    19fc:	b0 93 72 00 	sts	0x0072, r27
}
    1a00:	bf 91       	pop	r27
    1a02:	af 91       	pop	r26
    1a04:	9f 91       	pop	r25
    1a06:	8f 91       	pop	r24
    1a08:	0f 90       	pop	r0
    1a0a:	0f be       	out	0x3f, r0	; 63
    1a0c:	0f 90       	pop	r0
    1a0e:	1f 90       	pop	r1
    1a10:	18 95       	reti

00001a12 <filter_red>:
  */ 

void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTC = PORTC & 0xBF; //set S2 low
    1a12:	ae 98       	cbi	0x15, 6	; 21
	PORTC = PORTC & 0x7F; //set S3 low
    1a14:	af 98       	cbi	0x15, 7	; 21
}
    1a16:	08 95       	ret

00001a18 <filter_green>:
  */ 

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTC = PORTC | 0x40; //set S2 High
    1a18:	ae 9a       	sbi	0x15, 6	; 21
	PORTC = PORTC | 0x80; //set S3 High
    1a1a:	af 9a       	sbi	0x15, 7	; 21
}
    1a1c:	08 95       	ret

00001a1e <filter_blue>:
  */ 

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTC = PORTC & 0xBF; //set S2 low
    1a1e:	ae 98       	cbi	0x15, 6	; 21
	PORTC = PORTC | 0x80; //set S3 High
    1a20:	af 9a       	sbi	0x15, 7	; 21
}
    1a22:	08 95       	ret

00001a24 <filter_clear>:
  */ 

void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	PORTC = PORTC | 0x40; //set S2 High
    1a24:	ae 9a       	sbi	0x15, 6	; 21
	PORTC = PORTC & 0x7F; //set S3 Low
    1a26:	af 98       	cbi	0x15, 7	; 21
}
    1a28:	08 95       	ret

00001a2a <color_sensor_scaling_20>:
  */

void color_sensor_scaling_20()		
{
	//Output Scaling 20% from datasheet
	PORTC = PORTC | 0x10; //set S0 high
    1a2a:	ac 9a       	sbi	0x15, 4	; 21
	PORTC = PORTC & 0xDF; //set S1 LOW
    1a2c:	ad 98       	cbi	0x15, 5	; 21
}
    1a2e:	08 95       	ret

00001a30 <color_sensor_scaling_2>:
  */

void color_sensor_scaling_2()	
{
	//Output Scaling 2% from datasheet
	PORTC = PORTC & 0xEF; //set S0 low
    1a30:	ac 98       	cbi	0x15, 4	; 21
	PORTC = PORTC | 0x20; //set S1 high
    1a32:	ad 9a       	sbi	0x15, 5	; 21
}
    1a34:	08 95       	ret

00001a36 <red_read>:
  */

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
    1a36:	0e 94 09 0d 	call	0x1a12	; 0x1a12 <filter_red>
	pulse=0; //reset the count to 0
    1a3a:	10 92 6f 00 	sts	0x006F, r1
    1a3e:	10 92 70 00 	sts	0x0070, r1
    1a42:	10 92 71 00 	sts	0x0071, r1
    1a46:	10 92 72 00 	sts	0x0072, r1
    1a4a:	8f ef       	ldi	r24, 0xFF	; 255
    1a4c:	9f e3       	ldi	r25, 0x3F	; 63
    1a4e:	a2 e0       	ldi	r26, 0x02	; 2
    1a50:	81 50       	subi	r24, 0x01	; 1
    1a52:	90 40       	sbci	r25, 0x00	; 0
    1a54:	a0 40       	sbci	r26, 0x00	; 0
    1a56:	e1 f7       	brne	.-8      	; 0x1a50 <red_read+0x1a>
    1a58:	00 c0       	rjmp	.+0      	; 0x1a5a <red_read+0x24>
    1a5a:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
    1a5c:	80 91 6f 00 	lds	r24, 0x006F
    1a60:	90 91 70 00 	lds	r25, 0x0070
    1a64:	a0 91 71 00 	lds	r26, 0x0071
    1a68:	b0 91 72 00 	lds	r27, 0x0072
    1a6c:	80 93 e7 00 	sts	0x00E7, r24
    1a70:	90 93 e8 00 	sts	0x00E8, r25
    1a74:	a0 93 e9 00 	sts	0x00E9, r26
    1a78:	b0 93 ea 00 	sts	0x00EA, r27
}
    1a7c:	08 95       	ret

00001a7e <green_read>:
  */

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
    1a7e:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <filter_green>
	pulse=0; //reset the count to 0
    1a82:	10 92 6f 00 	sts	0x006F, r1
    1a86:	10 92 70 00 	sts	0x0070, r1
    1a8a:	10 92 71 00 	sts	0x0071, r1
    1a8e:	10 92 72 00 	sts	0x0072, r1
    1a92:	8f ef       	ldi	r24, 0xFF	; 255
    1a94:	9f e3       	ldi	r25, 0x3F	; 63
    1a96:	a2 e0       	ldi	r26, 0x02	; 2
    1a98:	81 50       	subi	r24, 0x01	; 1
    1a9a:	90 40       	sbci	r25, 0x00	; 0
    1a9c:	a0 40       	sbci	r26, 0x00	; 0
    1a9e:	e1 f7       	brne	.-8      	; 0x1a98 <green_read+0x1a>
    1aa0:	00 c0       	rjmp	.+0      	; 0x1aa2 <green_read+0x24>
    1aa2:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
    1aa4:	80 91 6f 00 	lds	r24, 0x006F
    1aa8:	90 91 70 00 	lds	r25, 0x0070
    1aac:	a0 91 71 00 	lds	r26, 0x0071
    1ab0:	b0 91 72 00 	lds	r27, 0x0072
    1ab4:	80 93 e3 00 	sts	0x00E3, r24
    1ab8:	90 93 e4 00 	sts	0x00E4, r25
    1abc:	a0 93 e5 00 	sts	0x00E5, r26
    1ac0:	b0 93 e6 00 	sts	0x00E6, r27
}
    1ac4:	08 95       	ret

00001ac6 <blue_read>:
  */ 

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
    1ac6:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <filter_blue>
	pulse=0; //reset the count to 0
    1aca:	10 92 6f 00 	sts	0x006F, r1
    1ace:	10 92 70 00 	sts	0x0070, r1
    1ad2:	10 92 71 00 	sts	0x0071, r1
    1ad6:	10 92 72 00 	sts	0x0072, r1
    1ada:	8f ef       	ldi	r24, 0xFF	; 255
    1adc:	9f e3       	ldi	r25, 0x3F	; 63
    1ade:	a2 e0       	ldi	r26, 0x02	; 2
    1ae0:	81 50       	subi	r24, 0x01	; 1
    1ae2:	90 40       	sbci	r25, 0x00	; 0
    1ae4:	a0 40       	sbci	r26, 0x00	; 0
    1ae6:	e1 f7       	brne	.-8      	; 0x1ae0 <blue_read+0x1a>
    1ae8:	00 c0       	rjmp	.+0      	; 0x1aea <blue_read+0x24>
    1aea:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
    1aec:	80 91 6f 00 	lds	r24, 0x006F
    1af0:	90 91 70 00 	lds	r25, 0x0070
    1af4:	a0 91 71 00 	lds	r26, 0x0071
    1af8:	b0 91 72 00 	lds	r27, 0x0072
    1afc:	80 93 b5 00 	sts	0x00B5, r24
    1b00:	90 93 b6 00 	sts	0x00B6, r25
    1b04:	a0 93 b7 00 	sts	0x00B7, r26
    1b08:	b0 93 b8 00 	sts	0x00B8, r27
}
    1b0c:	08 95       	ret

00001b0e <init_color_sensor>:
  * Example Call: init_color_sensor()
  */ 

void init_color_sensor(void)
{
 cli();          //Clears the global interrupts
    1b0e:	f8 94       	cli
 timer1_init_color();
    1b10:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <timer1_init_color>
 TIMSK = TIMSK | 0x20;   //timer1 interrupt sources
    1b14:	89 b7       	in	r24, 0x39	; 57
    1b16:	80 62       	ori	r24, 0x20	; 32
    1b18:	89 bf       	out	0x39, r24	; 57
 sei();          //Enables the global interrupts
    1b1a:	78 94       	sei
 color_sensor_scaling_2();
    1b1c:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <color_sensor_scaling_2>
}
    1b20:	08 95       	ret

00001b22 <color_check>:
  * Example Call: color_check()
  */ 

void color_check(void)
{
	init_color_sensor();
    1b22:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <init_color_sensor>
	
	red_read(); 
    1b26:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <red_read>
    1b2a:	8f ef       	ldi	r24, 0xFF	; 255
    1b2c:	9f e3       	ldi	r25, 0x3F	; 63
    1b2e:	ab e0       	ldi	r26, 0x0B	; 11
    1b30:	81 50       	subi	r24, 0x01	; 1
    1b32:	90 40       	sbci	r25, 0x00	; 0
    1b34:	a0 40       	sbci	r26, 0x00	; 0
    1b36:	e1 f7       	brne	.-8      	; 0x1b30 <color_check+0xe>
    1b38:	00 c0       	rjmp	.+0      	; 0x1b3a <color_check+0x18>
    1b3a:	00 00       	nop
	_delay_ms(500);
	green_read(); 
    1b3c:	0e 94 3f 0d 	call	0x1a7e	; 0x1a7e <green_read>
    1b40:	8f ef       	ldi	r24, 0xFF	; 255
    1b42:	9f e3       	ldi	r25, 0x3F	; 63
    1b44:	ab e0       	ldi	r26, 0x0B	; 11
    1b46:	81 50       	subi	r24, 0x01	; 1
    1b48:	90 40       	sbci	r25, 0x00	; 0
    1b4a:	a0 40       	sbci	r26, 0x00	; 0
    1b4c:	e1 f7       	brne	.-8      	; 0x1b46 <color_check+0x24>
    1b4e:	00 c0       	rjmp	.+0      	; 0x1b50 <color_check+0x2e>
    1b50:	00 00       	nop
	_delay_ms(500);
	blue_read(); 
    1b52:	0e 94 63 0d 	call	0x1ac6	; 0x1ac6 <blue_read>
    1b56:	8f ef       	ldi	r24, 0xFF	; 255
    1b58:	9f e3       	ldi	r25, 0x3F	; 63
    1b5a:	ab e0       	ldi	r26, 0x0B	; 11
    1b5c:	81 50       	subi	r24, 0x01	; 1
    1b5e:	90 40       	sbci	r25, 0x00	; 0
    1b60:	a0 40       	sbci	r26, 0x00	; 0
    1b62:	e1 f7       	brne	.-8      	; 0x1b5c <color_check+0x3a>
    1b64:	00 c0       	rjmp	.+0      	; 0x1b66 <color_check+0x44>
    1b66:	00 00       	nop
	_delay_ms(500);
	
	cli();
    1b68:	f8 94       	cli
	timer1_init();
    1b6a:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <timer1_init>
	sei();
    1b6e:	78 94       	sei
	
	if((red>green) && (red>blue))  color_result = 0;
    1b70:	40 91 e7 00 	lds	r20, 0x00E7
    1b74:	50 91 e8 00 	lds	r21, 0x00E8
    1b78:	60 91 e9 00 	lds	r22, 0x00E9
    1b7c:	70 91 ea 00 	lds	r23, 0x00EA
    1b80:	80 91 e3 00 	lds	r24, 0x00E3
    1b84:	90 91 e4 00 	lds	r25, 0x00E4
    1b88:	a0 91 e5 00 	lds	r26, 0x00E5
    1b8c:	b0 91 e6 00 	lds	r27, 0x00E6
    1b90:	84 17       	cp	r24, r20
    1b92:	95 07       	cpc	r25, r21
    1b94:	a6 07       	cpc	r26, r22
    1b96:	b7 07       	cpc	r27, r23
    1b98:	d0 f4       	brcc	.+52     	; 0x1bce <color_check+0xac>
    1b9a:	40 91 e7 00 	lds	r20, 0x00E7
    1b9e:	50 91 e8 00 	lds	r21, 0x00E8
    1ba2:	60 91 e9 00 	lds	r22, 0x00E9
    1ba6:	70 91 ea 00 	lds	r23, 0x00EA
    1baa:	80 91 b5 00 	lds	r24, 0x00B5
    1bae:	90 91 b6 00 	lds	r25, 0x00B6
    1bb2:	a0 91 b7 00 	lds	r26, 0x00B7
    1bb6:	b0 91 b8 00 	lds	r27, 0x00B8
    1bba:	84 17       	cp	r24, r20
    1bbc:	95 07       	cpc	r25, r21
    1bbe:	a6 07       	cpc	r26, r22
    1bc0:	b7 07       	cpc	r27, r23
    1bc2:	28 f4       	brcc	.+10     	; 0x1bce <color_check+0xac>
    1bc4:	10 92 1a 01 	sts	0x011A, r1
    1bc8:	10 92 19 01 	sts	0x0119, r1
    1bcc:	08 95       	ret
	else if(green>blue)            color_result = 1;
    1bce:	40 91 e3 00 	lds	r20, 0x00E3
    1bd2:	50 91 e4 00 	lds	r21, 0x00E4
    1bd6:	60 91 e5 00 	lds	r22, 0x00E5
    1bda:	70 91 e6 00 	lds	r23, 0x00E6
    1bde:	80 91 b5 00 	lds	r24, 0x00B5
    1be2:	90 91 b6 00 	lds	r25, 0x00B6
    1be6:	a0 91 b7 00 	lds	r26, 0x00B7
    1bea:	b0 91 b8 00 	lds	r27, 0x00B8
    1bee:	84 17       	cp	r24, r20
    1bf0:	95 07       	cpc	r25, r21
    1bf2:	a6 07       	cpc	r26, r22
    1bf4:	b7 07       	cpc	r27, r23
    1bf6:	38 f4       	brcc	.+14     	; 0x1c06 <color_check+0xe4>
    1bf8:	81 e0       	ldi	r24, 0x01	; 1
    1bfa:	90 e0       	ldi	r25, 0x00	; 0
    1bfc:	90 93 1a 01 	sts	0x011A, r25
    1c00:	80 93 19 01 	sts	0x0119, r24
    1c04:	08 95       	ret
	else                           color_result = 2;
    1c06:	82 e0       	ldi	r24, 0x02	; 2
    1c08:	90 e0       	ldi	r25, 0x00	; 0
    1c0a:	90 93 1a 01 	sts	0x011A, r25
    1c0e:	80 93 19 01 	sts	0x0119, r24
    1c12:	08 95       	ret

00001c14 <convert_rowcol_to_seq>:

unsigned int convert_rowcol_to_seq(unsigned char x1,unsigned char x2)
{
	unsigned int x;
	x=0;
	if((x1 == 0x02) || (x1 == '2'))
    1c14:	82 30       	cpi	r24, 0x02	; 2
    1c16:	c9 f0       	breq	.+50     	; 0x1c4a <convert_rowcol_to_seq+0x36>
    1c18:	82 33       	cpi	r24, 0x32	; 50
    1c1a:	d1 f0       	breq	.+52     	; 0x1c50 <convert_rowcol_to_seq+0x3c>
	{
		x+=7;
	}
	else if((x1 == 0x03) || (x1 == '3'))
    1c1c:	83 30       	cpi	r24, 0x03	; 3
    1c1e:	d9 f0       	breq	.+54     	; 0x1c56 <convert_rowcol_to_seq+0x42>
    1c20:	83 33       	cpi	r24, 0x33	; 51
    1c22:	e1 f0       	breq	.+56     	; 0x1c5c <convert_rowcol_to_seq+0x48>
	{
		x+=14;
	}
	else if((x1 == 0x04) || (x1 == '4'))
    1c24:	84 30       	cpi	r24, 0x04	; 4
    1c26:	e9 f0       	breq	.+58     	; 0x1c62 <convert_rowcol_to_seq+0x4e>
    1c28:	84 33       	cpi	r24, 0x34	; 52
    1c2a:	f1 f0       	breq	.+60     	; 0x1c68 <convert_rowcol_to_seq+0x54>
	{
		x+=21;
	}
	else if((x1 == 0x05) || (x1 == '5'))
    1c2c:	85 30       	cpi	r24, 0x05	; 5
    1c2e:	f9 f0       	breq	.+62     	; 0x1c6e <convert_rowcol_to_seq+0x5a>
    1c30:	85 33       	cpi	r24, 0x35	; 53
    1c32:	01 f1       	breq	.+64     	; 0x1c74 <convert_rowcol_to_seq+0x60>
	{
		x+=28;
	}
	else if((x1 == 0x06) || (x1 == '6'))
    1c34:	86 30       	cpi	r24, 0x06	; 6
    1c36:	09 f1       	breq	.+66     	; 0x1c7a <convert_rowcol_to_seq+0x66>
    1c38:	86 33       	cpi	r24, 0x36	; 54
    1c3a:	11 f1       	breq	.+68     	; 0x1c80 <convert_rowcol_to_seq+0x6c>
	{
		x+=35;
	}
	else if((x1 == 0x07) || (x1 == '7'))
    1c3c:	87 30       	cpi	r24, 0x07	; 7
    1c3e:	19 f1       	breq	.+70     	; 0x1c86 <convert_rowcol_to_seq+0x72>
    1c40:	87 33       	cpi	r24, 0x37	; 55
    1c42:	21 f1       	breq	.+72     	; 0x1c8c <convert_rowcol_to_seq+0x78>
unsigned int checker;

unsigned int convert_rowcol_to_seq(unsigned char x1,unsigned char x2)
{
	unsigned int x;
	x=0;
    1c44:	80 e0       	ldi	r24, 0x00	; 0
    1c46:	90 e0       	ldi	r25, 0x00	; 0
    1c48:	23 c0       	rjmp	.+70     	; 0x1c90 <convert_rowcol_to_seq+0x7c>
	if((x1 == 0x02) || (x1 == '2'))
	{
		x+=7;
    1c4a:	87 e0       	ldi	r24, 0x07	; 7
    1c4c:	90 e0       	ldi	r25, 0x00	; 0
    1c4e:	20 c0       	rjmp	.+64     	; 0x1c90 <convert_rowcol_to_seq+0x7c>
    1c50:	87 e0       	ldi	r24, 0x07	; 7
    1c52:	90 e0       	ldi	r25, 0x00	; 0
    1c54:	1d c0       	rjmp	.+58     	; 0x1c90 <convert_rowcol_to_seq+0x7c>
	}
	else if((x1 == 0x03) || (x1 == '3'))
	{
		x+=14;
    1c56:	8e e0       	ldi	r24, 0x0E	; 14
    1c58:	90 e0       	ldi	r25, 0x00	; 0
    1c5a:	1a c0       	rjmp	.+52     	; 0x1c90 <convert_rowcol_to_seq+0x7c>
    1c5c:	8e e0       	ldi	r24, 0x0E	; 14
    1c5e:	90 e0       	ldi	r25, 0x00	; 0
    1c60:	17 c0       	rjmp	.+46     	; 0x1c90 <convert_rowcol_to_seq+0x7c>
	}
	else if((x1 == 0x04) || (x1 == '4'))
	{
		x+=21;
    1c62:	85 e1       	ldi	r24, 0x15	; 21
    1c64:	90 e0       	ldi	r25, 0x00	; 0
    1c66:	14 c0       	rjmp	.+40     	; 0x1c90 <convert_rowcol_to_seq+0x7c>
    1c68:	85 e1       	ldi	r24, 0x15	; 21
    1c6a:	90 e0       	ldi	r25, 0x00	; 0
    1c6c:	11 c0       	rjmp	.+34     	; 0x1c90 <convert_rowcol_to_seq+0x7c>
	}
	else if((x1 == 0x05) || (x1 == '5'))
	{
		x+=28;
    1c6e:	8c e1       	ldi	r24, 0x1C	; 28
    1c70:	90 e0       	ldi	r25, 0x00	; 0
    1c72:	0e c0       	rjmp	.+28     	; 0x1c90 <convert_rowcol_to_seq+0x7c>
    1c74:	8c e1       	ldi	r24, 0x1C	; 28
    1c76:	90 e0       	ldi	r25, 0x00	; 0
    1c78:	0b c0       	rjmp	.+22     	; 0x1c90 <convert_rowcol_to_seq+0x7c>
	}
	else if((x1 == 0x06) || (x1 == '6'))
	{
		x+=35;
    1c7a:	83 e2       	ldi	r24, 0x23	; 35
    1c7c:	90 e0       	ldi	r25, 0x00	; 0
    1c7e:	08 c0       	rjmp	.+16     	; 0x1c90 <convert_rowcol_to_seq+0x7c>
    1c80:	83 e2       	ldi	r24, 0x23	; 35
    1c82:	90 e0       	ldi	r25, 0x00	; 0
    1c84:	05 c0       	rjmp	.+10     	; 0x1c90 <convert_rowcol_to_seq+0x7c>
	}
	else if((x1 == 0x07) || (x1 == '7'))
	{
		x+=42;
    1c86:	8a e2       	ldi	r24, 0x2A	; 42
    1c88:	90 e0       	ldi	r25, 0x00	; 0
    1c8a:	02 c0       	rjmp	.+4      	; 0x1c90 <convert_rowcol_to_seq+0x7c>
    1c8c:	8a e2       	ldi	r24, 0x2A	; 42
    1c8e:	90 e0       	ldi	r25, 0x00	; 0
	}
	if((x2 == 0x10) || (x2 == 'B'))
    1c90:	60 31       	cpi	r22, 0x10	; 16
    1c92:	11 f0       	breq	.+4      	; 0x1c98 <convert_rowcol_to_seq+0x84>
    1c94:	62 34       	cpi	r22, 0x42	; 66
    1c96:	11 f4       	brne	.+4      	; 0x1c9c <convert_rowcol_to_seq+0x88>
	{
		x+=1;
    1c98:	01 96       	adiw	r24, 0x01	; 1
    1c9a:	08 95       	ret
	}
	else if((x2 == 0x18) || (x2 == 'C'))
    1c9c:	68 31       	cpi	r22, 0x18	; 24
    1c9e:	11 f0       	breq	.+4      	; 0x1ca4 <convert_rowcol_to_seq+0x90>
    1ca0:	63 34       	cpi	r22, 0x43	; 67
    1ca2:	11 f4       	brne	.+4      	; 0x1ca8 <convert_rowcol_to_seq+0x94>
	{
		x+=2;
    1ca4:	02 96       	adiw	r24, 0x02	; 2
    1ca6:	08 95       	ret
	}
	else if((x2 == 0x20) || (x2 == 'D'))
    1ca8:	60 32       	cpi	r22, 0x20	; 32
    1caa:	11 f0       	breq	.+4      	; 0x1cb0 <convert_rowcol_to_seq+0x9c>
    1cac:	64 34       	cpi	r22, 0x44	; 68
    1cae:	11 f4       	brne	.+4      	; 0x1cb4 <convert_rowcol_to_seq+0xa0>
	{
		x+=3;
    1cb0:	03 96       	adiw	r24, 0x03	; 3
    1cb2:	08 95       	ret
	}
	else if((x2 == 0x28) || (x2 == 'E'))
    1cb4:	68 32       	cpi	r22, 0x28	; 40
    1cb6:	11 f0       	breq	.+4      	; 0x1cbc <convert_rowcol_to_seq+0xa8>
    1cb8:	65 34       	cpi	r22, 0x45	; 69
    1cba:	11 f4       	brne	.+4      	; 0x1cc0 <convert_rowcol_to_seq+0xac>
	{
		x+=4;
    1cbc:	04 96       	adiw	r24, 0x04	; 4
    1cbe:	08 95       	ret
	}
	else if((x2 == 0x30) || (x2 == 'F'))
    1cc0:	60 33       	cpi	r22, 0x30	; 48
    1cc2:	11 f0       	breq	.+4      	; 0x1cc8 <convert_rowcol_to_seq+0xb4>
    1cc4:	66 34       	cpi	r22, 0x46	; 70
    1cc6:	11 f4       	brne	.+4      	; 0x1ccc <convert_rowcol_to_seq+0xb8>
	{
		x+=5;
    1cc8:	05 96       	adiw	r24, 0x05	; 5
    1cca:	08 95       	ret
	}
	else if((x2 == 0x38) || (x2 == 'G'))
    1ccc:	68 33       	cpi	r22, 0x38	; 56
    1cce:	11 f0       	breq	.+4      	; 0x1cd4 <convert_rowcol_to_seq+0xc0>
    1cd0:	67 34       	cpi	r22, 0x47	; 71
    1cd2:	09 f4       	brne	.+2      	; 0x1cd6 <convert_rowcol_to_seq+0xc2>
	{
		x+=6;
    1cd4:	06 96       	adiw	r24, 0x06	; 6
	}
	return x;
}
    1cd6:	08 95       	ret

00001cd8 <__vector_11>:
The above arrays are used by bot to traverse directly to the plant in the other two sets instead of scanning every plant location.

*/

ISR(USART_RXC_vect)
{
    1cd8:	1f 92       	push	r1
    1cda:	0f 92       	push	r0
    1cdc:	0f b6       	in	r0, 0x3f	; 63
    1cde:	0f 92       	push	r0
    1ce0:	11 24       	eor	r1, r1
    1ce2:	2f 93       	push	r18
    1ce4:	3f 93       	push	r19
    1ce6:	4f 93       	push	r20
    1ce8:	5f 93       	push	r21
    1cea:	6f 93       	push	r22
    1cec:	7f 93       	push	r23
    1cee:	8f 93       	push	r24
    1cf0:	9f 93       	push	r25
    1cf2:	af 93       	push	r26
    1cf4:	bf 93       	push	r27
    1cf6:	cf 93       	push	r28
    1cf8:	df 93       	push	r29
    1cfa:	ef 93       	push	r30
    1cfc:	ff 93       	push	r31
	data_rec = UDR;
    1cfe:	8c b1       	in	r24, 0x0c	; 12
    1d00:	80 93 16 01 	sts	0x0116, r24
	if((data_rec == 0x00) && (green_xbee_flag == 0))
    1d04:	80 91 16 01 	lds	r24, 0x0116
    1d08:	88 23       	and	r24, r24
    1d0a:	81 f4       	brne	.+32     	; 0x1d2c <__vector_11+0x54>
    1d0c:	80 91 86 00 	lds	r24, 0x0086
    1d10:	90 91 87 00 	lds	r25, 0x0087
    1d14:	00 97       	sbiw	r24, 0x00	; 0
    1d16:	51 f4       	brne	.+20     	; 0x1d2c <__vector_11+0x54>
	{
		home_bit[1]=1;
    1d18:	81 e0       	ldi	r24, 0x01	; 1
    1d1a:	90 e0       	ldi	r25, 0x00	; 0
    1d1c:	90 93 a5 00 	sts	0x00A5, r25
    1d20:	80 93 a4 00 	sts	0x00A4, r24
		green_xbee_flag = 1;
    1d24:	90 93 87 00 	sts	0x0087, r25
    1d28:	80 93 86 00 	sts	0x0086, r24
	}		
	if((data_rec == 0x40) && (red_xbee_flag == 0)) 
    1d2c:	80 91 16 01 	lds	r24, 0x0116
    1d30:	80 34       	cpi	r24, 0x40	; 64
    1d32:	81 f4       	brne	.+32     	; 0x1d54 <__vector_11+0x7c>
    1d34:	80 91 88 00 	lds	r24, 0x0088
    1d38:	90 91 89 00 	lds	r25, 0x0089
    1d3c:	00 97       	sbiw	r24, 0x00	; 0
    1d3e:	51 f4       	brne	.+20     	; 0x1d54 <__vector_11+0x7c>
	{
		home_bit[2]=1;
    1d40:	81 e0       	ldi	r24, 0x01	; 1
    1d42:	90 e0       	ldi	r25, 0x00	; 0
    1d44:	90 93 a7 00 	sts	0x00A7, r25
    1d48:	80 93 a6 00 	sts	0x00A6, r24
		red_xbee_flag = 1;
    1d4c:	90 93 89 00 	sts	0x0089, r25
    1d50:	80 93 88 00 	sts	0x0088, r24
	}
	if(xbee_com==0)
    1d54:	80 91 96 00 	lds	r24, 0x0096
    1d58:	88 23       	and	r24, r24
    1d5a:	81 f5       	brne	.+96     	; 0x1dbc <__vector_11+0xe4>
	{
		data_temp = data_rec & 0xC0;
    1d5c:	80 91 16 01 	lds	r24, 0x0116
    1d60:	80 7c       	andi	r24, 0xC0	; 192
    1d62:	80 93 15 01 	sts	0x0115, r24
		
		if(data_temp == 0x80)
    1d66:	80 91 15 01 	lds	r24, 0x0115
    1d6a:	80 38       	cpi	r24, 0x80	; 128
    1d6c:	09 f0       	breq	.+2      	; 0x1d70 <__vector_11+0x98>
    1d6e:	ae c0       	rjmp	.+348    	; 0x1ecc <__vector_11+0x1f4>
		{  
			data_temp_s1 = data_rec & 0x07;
    1d70:	80 91 16 01 	lds	r24, 0x0116
    1d74:	87 70       	andi	r24, 0x07	; 7
    1d76:	80 93 06 01 	sts	0x0106, r24
			data_temp_s2 = data_rec & 0x38;
    1d7a:	80 91 16 01 	lds	r24, 0x0116
    1d7e:	88 73       	andi	r24, 0x38	; 56
    1d80:	80 93 14 01 	sts	0x0114, r24
			initial_home_run[node_count]=convert_rowcol_to_seq(data_temp_s1,data_temp_s2);
    1d84:	c0 91 94 00 	lds	r28, 0x0094
    1d88:	d0 91 95 00 	lds	r29, 0x0095
    1d8c:	80 91 06 01 	lds	r24, 0x0106
    1d90:	60 91 14 01 	lds	r22, 0x0114
    1d94:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <convert_rowcol_to_seq>
    1d98:	28 2f       	mov	r18, r24
    1d9a:	39 2f       	mov	r19, r25
    1d9c:	cc 0f       	add	r28, r28
    1d9e:	dd 1f       	adc	r29, r29
    1da0:	c5 54       	subi	r28, 0x45	; 69
    1da2:	df 4f       	sbci	r29, 0xFF	; 255
    1da4:	39 83       	std	Y+1, r19	; 0x01
    1da6:	28 83       	st	Y, r18
			++node_count;
    1da8:	80 91 94 00 	lds	r24, 0x0094
    1dac:	90 91 95 00 	lds	r25, 0x0095
    1db0:	01 96       	adiw	r24, 0x01	; 1
    1db2:	90 93 95 00 	sts	0x0095, r25
    1db6:	80 93 94 00 	sts	0x0094, r24
    1dba:	88 c0       	rjmp	.+272    	; 0x1ecc <__vector_11+0x1f4>
		}
	}
	else if(xbee_com==1)
    1dbc:	80 91 96 00 	lds	r24, 0x0096
    1dc0:	81 30       	cpi	r24, 0x01	; 1
    1dc2:	09 f0       	breq	.+2      	; 0x1dc6 <__vector_11+0xee>
    1dc4:	83 c0       	rjmp	.+262    	; 0x1ecc <__vector_11+0x1f4>
	{
		data_temp = data_rec & 0xC0;
    1dc6:	80 91 16 01 	lds	r24, 0x0116
    1dca:	80 7c       	andi	r24, 0xC0	; 192
    1dcc:	80 93 15 01 	sts	0x0115, r24
		uint8_t temp;
		
		if(data_temp == 0x80)
    1dd0:	80 91 15 01 	lds	r24, 0x0115
    1dd4:	80 38       	cpi	r24, 0x80	; 128
    1dd6:	09 f0       	breq	.+2      	; 0x1dda <__vector_11+0x102>
    1dd8:	79 c0       	rjmp	.+242    	; 0x1ecc <__vector_11+0x1f4>
		{
			data_temp_s1 = data_rec & 0x07;
    1dda:	80 91 16 01 	lds	r24, 0x0116
    1dde:	87 70       	andi	r24, 0x07	; 7
    1de0:	80 93 06 01 	sts	0x0106, r24
			data_temp_s2 = data_rec & 0x38;
    1de4:	80 91 16 01 	lds	r24, 0x0116
    1de8:	88 73       	andi	r24, 0x38	; 56
    1dea:	80 93 14 01 	sts	0x0114, r24
			temp=convert_rowcol_to_seq(data_temp_s1,data_temp_s2);
    1dee:	80 91 06 01 	lds	r24, 0x0106
    1df2:	60 91 14 01 	lds	r22, 0x0114
    1df6:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <convert_rowcol_to_seq>
			if(set_cover==0)
    1dfa:	20 91 9c 00 	lds	r18, 0x009C
    1dfe:	30 91 9d 00 	lds	r19, 0x009D
    1e02:	21 15       	cp	r18, r1
    1e04:	31 05       	cpc	r19, r1
    1e06:	71 f5       	brne	.+92     	; 0x1e64 <__vector_11+0x18c>
			{
				if((temp>6) && (temp<14))
    1e08:	98 2f       	mov	r25, r24
    1e0a:	97 50       	subi	r25, 0x07	; 7
    1e0c:	97 30       	cpi	r25, 0x07	; 7
    1e0e:	a8 f4       	brcc	.+42     	; 0x1e3a <__vector_11+0x162>
				{
					right_plant_set1[right_plant_set1_count]=temp;
    1e10:	e0 91 92 00 	lds	r30, 0x0092
    1e14:	f0 91 93 00 	lds	r31, 0x0093
    1e18:	90 e0       	ldi	r25, 0x00	; 0
    1e1a:	ee 0f       	add	r30, r30
    1e1c:	ff 1f       	adc	r31, r31
    1e1e:	e8 55       	subi	r30, 0x58	; 88
    1e20:	ff 4f       	sbci	r31, 0xFF	; 255
    1e22:	91 83       	std	Z+1, r25	; 0x01
    1e24:	80 83       	st	Z, r24
					++right_plant_set1_count;
    1e26:	80 91 92 00 	lds	r24, 0x0092
    1e2a:	90 91 93 00 	lds	r25, 0x0093
    1e2e:	01 96       	adiw	r24, 0x01	; 1
    1e30:	90 93 93 00 	sts	0x0093, r25
    1e34:	80 93 92 00 	sts	0x0092, r24
    1e38:	49 c0       	rjmp	.+146    	; 0x1ecc <__vector_11+0x1f4>
				}
				else
				{
					right_plant_set2[right_plant_set2_count]=temp;
    1e3a:	e0 91 8e 00 	lds	r30, 0x008E
    1e3e:	f0 91 8f 00 	lds	r31, 0x008F
    1e42:	90 e0       	ldi	r25, 0x00	; 0
    1e44:	ee 0f       	add	r30, r30
    1e46:	ff 1f       	adc	r31, r31
    1e48:	e4 51       	subi	r30, 0x14	; 20
    1e4a:	ff 4f       	sbci	r31, 0xFF	; 255
    1e4c:	91 83       	std	Z+1, r25	; 0x01
    1e4e:	80 83       	st	Z, r24
					++right_plant_set2_count;
    1e50:	80 91 8e 00 	lds	r24, 0x008E
    1e54:	90 91 8f 00 	lds	r25, 0x008F
    1e58:	01 96       	adiw	r24, 0x01	; 1
    1e5a:	90 93 8f 00 	sts	0x008F, r25
    1e5e:	80 93 8e 00 	sts	0x008E, r24
    1e62:	34 c0       	rjmp	.+104    	; 0x1ecc <__vector_11+0x1f4>
				}
			}
			else
			{
				if(set_cover==50)
    1e64:	20 91 9c 00 	lds	r18, 0x009C
    1e68:	30 91 9d 00 	lds	r19, 0x009D
    1e6c:	22 33       	cpi	r18, 0x32	; 50
    1e6e:	31 05       	cpc	r19, r1
    1e70:	69 f5       	brne	.+90     	; 0x1ecc <__vector_11+0x1f4>
				{
					if((temp>6) && (temp<14))
    1e72:	98 2f       	mov	r25, r24
    1e74:	97 50       	subi	r25, 0x07	; 7
    1e76:	97 30       	cpi	r25, 0x07	; 7
    1e78:	a8 f4       	brcc	.+42     	; 0x1ea4 <__vector_11+0x1cc>
					{
						left_plant_set1[left_plant_set1_count]=temp;
    1e7a:	e0 91 90 00 	lds	r30, 0x0090
    1e7e:	f0 91 91 00 	lds	r31, 0x0091
    1e82:	90 e0       	ldi	r25, 0x00	; 0
    1e84:	ee 0f       	add	r30, r30
    1e86:	ff 1f       	adc	r31, r31
    1e88:	e6 50       	subi	r30, 0x06	; 6
    1e8a:	ff 4f       	sbci	r31, 0xFF	; 255
    1e8c:	91 83       	std	Z+1, r25	; 0x01
    1e8e:	80 83       	st	Z, r24
						++left_plant_set1_count;
    1e90:	80 91 90 00 	lds	r24, 0x0090
    1e94:	90 91 91 00 	lds	r25, 0x0091
    1e98:	01 96       	adiw	r24, 0x01	; 1
    1e9a:	90 93 91 00 	sts	0x0091, r25
    1e9e:	80 93 90 00 	sts	0x0090, r24
    1ea2:	14 c0       	rjmp	.+40     	; 0x1ecc <__vector_11+0x1f4>
					}
					else
					{
						left_plant_set2[left_plant_set2_count]=temp;
    1ea4:	e0 91 8c 00 	lds	r30, 0x008C
    1ea8:	f0 91 8d 00 	lds	r31, 0x008D
    1eac:	90 e0       	ldi	r25, 0x00	; 0
    1eae:	ee 0f       	add	r30, r30
    1eb0:	ff 1f       	adc	r31, r31
    1eb2:	e9 5f       	subi	r30, 0xF9	; 249
    1eb4:	fe 4f       	sbci	r31, 0xFE	; 254
    1eb6:	91 83       	std	Z+1, r25	; 0x01
    1eb8:	80 83       	st	Z, r24
						++left_plant_set2_count;
    1eba:	80 91 8c 00 	lds	r24, 0x008C
    1ebe:	90 91 8d 00 	lds	r25, 0x008D
    1ec2:	01 96       	adiw	r24, 0x01	; 1
    1ec4:	90 93 8d 00 	sts	0x008D, r25
    1ec8:	80 93 8c 00 	sts	0x008C, r24
					}
				}
			}
		}
	}
}
    1ecc:	ff 91       	pop	r31
    1ece:	ef 91       	pop	r30
    1ed0:	df 91       	pop	r29
    1ed2:	cf 91       	pop	r28
    1ed4:	bf 91       	pop	r27
    1ed6:	af 91       	pop	r26
    1ed8:	9f 91       	pop	r25
    1eda:	8f 91       	pop	r24
    1edc:	7f 91       	pop	r23
    1ede:	6f 91       	pop	r22
    1ee0:	5f 91       	pop	r21
    1ee2:	4f 91       	pop	r20
    1ee4:	3f 91       	pop	r19
    1ee6:	2f 91       	pop	r18
    1ee8:	0f 90       	pop	r0
    1eea:	0f be       	out	0x3f, r0	; 63
    1eec:	0f 90       	pop	r0
    1eee:	1f 90       	pop	r1
    1ef0:	18 95       	reti

00001ef2 <xbee_seq_node_transfer>:
  * Logic: This function sends the data containing the sequential node position to the respective bot over xbee.
  * Example Call: xbee_seq_node_transfer(22 , 0)
  */

void xbee_seq_node_transfer(unsigned int node_tx, unsigned int send_flag)
{
    1ef2:	9c 01       	movw	r18, r24
    1ef4:	fb 01       	movw	r30, r22
	data = 0x00;
    1ef6:	10 92 97 00 	sts	0x0097, r1
	    if(node_tx < 7)
    1efa:	87 30       	cpi	r24, 0x07	; 7
    1efc:	91 05       	cpc	r25, r1
    1efe:	08 f0       	brcs	.+2      	; 0x1f02 <xbee_seq_node_transfer+0x10>
    1f00:	82 c0       	rjmp	.+260    	; 0x2006 <xbee_seq_node_transfer+0x114>
		{
			flag_switch = 0;
    1f02:	10 92 99 00 	sts	0x0099, r1
    1f06:	10 92 98 00 	sts	0x0098, r1
			switch(node_tx)
    1f0a:	83 30       	cpi	r24, 0x03	; 3
    1f0c:	91 05       	cpc	r25, r1
    1f0e:	e9 f1       	breq	.+122    	; 0x1f8a <xbee_seq_node_transfer+0x98>
    1f10:	84 30       	cpi	r24, 0x04	; 4
    1f12:	91 05       	cpc	r25, r1
    1f14:	38 f4       	brcc	.+14     	; 0x1f24 <xbee_seq_node_transfer+0x32>
    1f16:	81 30       	cpi	r24, 0x01	; 1
    1f18:	91 05       	cpc	r25, r1
    1f1a:	c9 f0       	breq	.+50     	; 0x1f4e <xbee_seq_node_transfer+0x5c>
    1f1c:	82 30       	cpi	r24, 0x02	; 2
    1f1e:	91 05       	cpc	r25, r1
    1f20:	28 f5       	brcc	.+74     	; 0x1f6c <xbee_seq_node_transfer+0x7a>
    1f22:	0c c0       	rjmp	.+24     	; 0x1f3c <xbee_seq_node_transfer+0x4a>
    1f24:	85 30       	cpi	r24, 0x05	; 5
    1f26:	91 05       	cpc	r25, r1
    1f28:	09 f4       	brne	.+2      	; 0x1f2c <xbee_seq_node_transfer+0x3a>
    1f2a:	4d c0       	rjmp	.+154    	; 0x1fc6 <xbee_seq_node_transfer+0xd4>
    1f2c:	85 30       	cpi	r24, 0x05	; 5
    1f2e:	91 05       	cpc	r25, r1
    1f30:	d8 f1       	brcs	.+118    	; 0x1fa8 <xbee_seq_node_transfer+0xb6>
    1f32:	86 30       	cpi	r24, 0x06	; 6
    1f34:	91 05       	cpc	r25, r1
    1f36:	09 f0       	breq	.+2      	; 0x1f3a <xbee_seq_node_transfer+0x48>
    1f38:	99 c1       	rjmp	.+818    	; 0x226c <xbee_seq_node_transfer+0x37a>
    1f3a:	54 c0       	rjmp	.+168    	; 0x1fe4 <xbee_seq_node_transfer+0xf2>
			{
				case 0: data = 0x09; flag_switch = 1;
    1f3c:	89 e0       	ldi	r24, 0x09	; 9
    1f3e:	80 93 97 00 	sts	0x0097, r24
    1f42:	81 e0       	ldi	r24, 0x01	; 1
    1f44:	90 e0       	ldi	r25, 0x00	; 0
    1f46:	90 93 99 00 	sts	0x0099, r25
    1f4a:	80 93 98 00 	sts	0x0098, r24
				case 1: if(flag_switch==0)
    1f4e:	80 91 98 00 	lds	r24, 0x0098
    1f52:	90 91 99 00 	lds	r25, 0x0099
    1f56:	00 97       	sbiw	r24, 0x00	; 0
    1f58:	49 f4       	brne	.+18     	; 0x1f6c <xbee_seq_node_transfer+0x7a>
				{
					data = 0x11;
    1f5a:	81 e1       	ldi	r24, 0x11	; 17
    1f5c:	80 93 97 00 	sts	0x0097, r24
					flag_switch=1;
    1f60:	81 e0       	ldi	r24, 0x01	; 1
    1f62:	90 e0       	ldi	r25, 0x00	; 0
    1f64:	90 93 99 00 	sts	0x0099, r25
    1f68:	80 93 98 00 	sts	0x0098, r24
				}
				case 2:if(flag_switch==0)
    1f6c:	80 91 98 00 	lds	r24, 0x0098
    1f70:	90 91 99 00 	lds	r25, 0x0099
    1f74:	00 97       	sbiw	r24, 0x00	; 0
    1f76:	49 f4       	brne	.+18     	; 0x1f8a <xbee_seq_node_transfer+0x98>
				{
					data = 0x19;
    1f78:	89 e1       	ldi	r24, 0x19	; 25
    1f7a:	80 93 97 00 	sts	0x0097, r24
					flag_switch=1;
    1f7e:	81 e0       	ldi	r24, 0x01	; 1
    1f80:	90 e0       	ldi	r25, 0x00	; 0
    1f82:	90 93 99 00 	sts	0x0099, r25
    1f86:	80 93 98 00 	sts	0x0098, r24
				}
				case 3:if(flag_switch==0)
    1f8a:	80 91 98 00 	lds	r24, 0x0098
    1f8e:	90 91 99 00 	lds	r25, 0x0099
    1f92:	00 97       	sbiw	r24, 0x00	; 0
    1f94:	49 f4       	brne	.+18     	; 0x1fa8 <xbee_seq_node_transfer+0xb6>
				{
					data = 0x21;
    1f96:	81 e2       	ldi	r24, 0x21	; 33
    1f98:	80 93 97 00 	sts	0x0097, r24
					flag_switch=1;
    1f9c:	81 e0       	ldi	r24, 0x01	; 1
    1f9e:	90 e0       	ldi	r25, 0x00	; 0
    1fa0:	90 93 99 00 	sts	0x0099, r25
    1fa4:	80 93 98 00 	sts	0x0098, r24
				}
				case 4:if(flag_switch==0)
    1fa8:	80 91 98 00 	lds	r24, 0x0098
    1fac:	90 91 99 00 	lds	r25, 0x0099
    1fb0:	00 97       	sbiw	r24, 0x00	; 0
    1fb2:	49 f4       	brne	.+18     	; 0x1fc6 <xbee_seq_node_transfer+0xd4>
				{
					data = 0x29;
    1fb4:	89 e2       	ldi	r24, 0x29	; 41
    1fb6:	80 93 97 00 	sts	0x0097, r24
					flag_switch=1;
    1fba:	81 e0       	ldi	r24, 0x01	; 1
    1fbc:	90 e0       	ldi	r25, 0x00	; 0
    1fbe:	90 93 99 00 	sts	0x0099, r25
    1fc2:	80 93 98 00 	sts	0x0098, r24
				}
				case 5:if(flag_switch==0)
    1fc6:	80 91 98 00 	lds	r24, 0x0098
    1fca:	90 91 99 00 	lds	r25, 0x0099
    1fce:	00 97       	sbiw	r24, 0x00	; 0
    1fd0:	49 f4       	brne	.+18     	; 0x1fe4 <xbee_seq_node_transfer+0xf2>
				{
					data = 0x31;
    1fd2:	81 e3       	ldi	r24, 0x31	; 49
    1fd4:	80 93 97 00 	sts	0x0097, r24
					flag_switch=1;
    1fd8:	81 e0       	ldi	r24, 0x01	; 1
    1fda:	90 e0       	ldi	r25, 0x00	; 0
    1fdc:	90 93 99 00 	sts	0x0099, r25
    1fe0:	80 93 98 00 	sts	0x0098, r24
				}
				case 6:if(flag_switch==0)
    1fe4:	80 91 98 00 	lds	r24, 0x0098
    1fe8:	90 91 99 00 	lds	r25, 0x0099
    1fec:	00 97       	sbiw	r24, 0x00	; 0
    1fee:	09 f0       	breq	.+2      	; 0x1ff2 <xbee_seq_node_transfer+0x100>
    1ff0:	3d c1       	rjmp	.+634    	; 0x226c <xbee_seq_node_transfer+0x37a>
				{
					data = 0x39;
    1ff2:	89 e3       	ldi	r24, 0x39	; 57
    1ff4:	80 93 97 00 	sts	0x0097, r24
					flag_switch=1;
    1ff8:	81 e0       	ldi	r24, 0x01	; 1
    1ffa:	90 e0       	ldi	r25, 0x00	; 0
    1ffc:	90 93 99 00 	sts	0x0099, r25
    2000:	80 93 98 00 	sts	0x0098, r24
    2004:	33 c1       	rjmp	.+614    	; 0x226c <xbee_seq_node_transfer+0x37a>
				}
			}
		}
		else
		{
				flag_switch=0;
    2006:	10 92 99 00 	sts	0x0099, r1
    200a:	10 92 98 00 	sts	0x0098, r1
				switch(node_tx%7)
    200e:	67 e0       	ldi	r22, 0x07	; 7
    2010:	70 e0       	ldi	r23, 0x00	; 0
    2012:	0e 94 c4 1a 	call	0x3588	; 0x3588 <__udivmodhi4>
    2016:	83 30       	cpi	r24, 0x03	; 3
    2018:	91 05       	cpc	r25, r1
    201a:	09 f4       	brne	.+2      	; 0x201e <xbee_seq_node_transfer+0x12c>
    201c:	44 c0       	rjmp	.+136    	; 0x20a6 <xbee_seq_node_transfer+0x1b4>
    201e:	84 30       	cpi	r24, 0x04	; 4
    2020:	91 05       	cpc	r25, r1
    2022:	38 f4       	brcc	.+14     	; 0x2032 <xbee_seq_node_transfer+0x140>
    2024:	81 30       	cpi	r24, 0x01	; 1
    2026:	91 05       	cpc	r25, r1
    2028:	e1 f0       	breq	.+56     	; 0x2062 <xbee_seq_node_transfer+0x170>
    202a:	82 30       	cpi	r24, 0x02	; 2
    202c:	91 05       	cpc	r25, r1
    202e:	50 f5       	brcc	.+84     	; 0x2084 <xbee_seq_node_transfer+0x192>
    2030:	0d c0       	rjmp	.+26     	; 0x204c <xbee_seq_node_transfer+0x15a>
    2032:	85 30       	cpi	r24, 0x05	; 5
    2034:	91 05       	cpc	r25, r1
    2036:	09 f4       	brne	.+2      	; 0x203a <xbee_seq_node_transfer+0x148>
    2038:	58 c0       	rjmp	.+176    	; 0x20ea <xbee_seq_node_transfer+0x1f8>
    203a:	85 30       	cpi	r24, 0x05	; 5
    203c:	91 05       	cpc	r25, r1
    203e:	08 f4       	brcc	.+2      	; 0x2042 <xbee_seq_node_transfer+0x150>
    2040:	43 c0       	rjmp	.+134    	; 0x20c8 <xbee_seq_node_transfer+0x1d6>
    2042:	86 30       	cpi	r24, 0x06	; 6
    2044:	91 05       	cpc	r25, r1
    2046:	09 f0       	breq	.+2      	; 0x204a <xbee_seq_node_transfer+0x158>
    2048:	72 c0       	rjmp	.+228    	; 0x212e <xbee_seq_node_transfer+0x23c>
    204a:	60 c0       	rjmp	.+192    	; 0x210c <xbee_seq_node_transfer+0x21a>
				{
					case 0:data = data | 0x08; flag_switch=1;
    204c:	80 91 97 00 	lds	r24, 0x0097
    2050:	88 60       	ori	r24, 0x08	; 8
    2052:	80 93 97 00 	sts	0x0097, r24
    2056:	81 e0       	ldi	r24, 0x01	; 1
    2058:	90 e0       	ldi	r25, 0x00	; 0
    205a:	90 93 99 00 	sts	0x0099, r25
    205e:	80 93 98 00 	sts	0x0098, r24
					case 1:if(flag_switch==0)
    2062:	80 91 98 00 	lds	r24, 0x0098
    2066:	90 91 99 00 	lds	r25, 0x0099
    206a:	00 97       	sbiw	r24, 0x00	; 0
    206c:	59 f4       	brne	.+22     	; 0x2084 <xbee_seq_node_transfer+0x192>
					{
						data = data | 0x10;
    206e:	80 91 97 00 	lds	r24, 0x0097
    2072:	80 61       	ori	r24, 0x10	; 16
    2074:	80 93 97 00 	sts	0x0097, r24
						flag_switch=1;
    2078:	81 e0       	ldi	r24, 0x01	; 1
    207a:	90 e0       	ldi	r25, 0x00	; 0
    207c:	90 93 99 00 	sts	0x0099, r25
    2080:	80 93 98 00 	sts	0x0098, r24
					}
					case 2:if(flag_switch==0)
    2084:	80 91 98 00 	lds	r24, 0x0098
    2088:	90 91 99 00 	lds	r25, 0x0099
    208c:	00 97       	sbiw	r24, 0x00	; 0
    208e:	59 f4       	brne	.+22     	; 0x20a6 <xbee_seq_node_transfer+0x1b4>
					{
						data = data | 0x18;
    2090:	80 91 97 00 	lds	r24, 0x0097
    2094:	88 61       	ori	r24, 0x18	; 24
    2096:	80 93 97 00 	sts	0x0097, r24
						flag_switch=1;
    209a:	81 e0       	ldi	r24, 0x01	; 1
    209c:	90 e0       	ldi	r25, 0x00	; 0
    209e:	90 93 99 00 	sts	0x0099, r25
    20a2:	80 93 98 00 	sts	0x0098, r24
					}
					case 3:if(flag_switch==0)
    20a6:	80 91 98 00 	lds	r24, 0x0098
    20aa:	90 91 99 00 	lds	r25, 0x0099
    20ae:	00 97       	sbiw	r24, 0x00	; 0
    20b0:	59 f4       	brne	.+22     	; 0x20c8 <xbee_seq_node_transfer+0x1d6>
					{
						data = data | 0x20;
    20b2:	80 91 97 00 	lds	r24, 0x0097
    20b6:	80 62       	ori	r24, 0x20	; 32
    20b8:	80 93 97 00 	sts	0x0097, r24
						flag_switch=1;
    20bc:	81 e0       	ldi	r24, 0x01	; 1
    20be:	90 e0       	ldi	r25, 0x00	; 0
    20c0:	90 93 99 00 	sts	0x0099, r25
    20c4:	80 93 98 00 	sts	0x0098, r24
					}
					case 4:if(flag_switch==0)
    20c8:	80 91 98 00 	lds	r24, 0x0098
    20cc:	90 91 99 00 	lds	r25, 0x0099
    20d0:	00 97       	sbiw	r24, 0x00	; 0
    20d2:	59 f4       	brne	.+22     	; 0x20ea <xbee_seq_node_transfer+0x1f8>
					{
						data = data | 0x28;
    20d4:	80 91 97 00 	lds	r24, 0x0097
    20d8:	88 62       	ori	r24, 0x28	; 40
    20da:	80 93 97 00 	sts	0x0097, r24
						flag_switch=1;
    20de:	81 e0       	ldi	r24, 0x01	; 1
    20e0:	90 e0       	ldi	r25, 0x00	; 0
    20e2:	90 93 99 00 	sts	0x0099, r25
    20e6:	80 93 98 00 	sts	0x0098, r24
					}
					case 5:if(flag_switch==0)
    20ea:	80 91 98 00 	lds	r24, 0x0098
    20ee:	90 91 99 00 	lds	r25, 0x0099
    20f2:	00 97       	sbiw	r24, 0x00	; 0
    20f4:	59 f4       	brne	.+22     	; 0x210c <xbee_seq_node_transfer+0x21a>
					{
						data = data | 0x30;
    20f6:	80 91 97 00 	lds	r24, 0x0097
    20fa:	80 63       	ori	r24, 0x30	; 48
    20fc:	80 93 97 00 	sts	0x0097, r24
						flag_switch=1;
    2100:	81 e0       	ldi	r24, 0x01	; 1
    2102:	90 e0       	ldi	r25, 0x00	; 0
    2104:	90 93 99 00 	sts	0x0099, r25
    2108:	80 93 98 00 	sts	0x0098, r24
					}
					case 6:if(flag_switch==0)
    210c:	80 91 98 00 	lds	r24, 0x0098
    2110:	90 91 99 00 	lds	r25, 0x0099
    2114:	00 97       	sbiw	r24, 0x00	; 0
    2116:	59 f4       	brne	.+22     	; 0x212e <xbee_seq_node_transfer+0x23c>
					{
						data = data | 0x38;
    2118:	80 91 97 00 	lds	r24, 0x0097
    211c:	88 63       	ori	r24, 0x38	; 56
    211e:	80 93 97 00 	sts	0x0097, r24
						flag_switch=1;
    2122:	81 e0       	ldi	r24, 0x01	; 1
    2124:	90 e0       	ldi	r25, 0x00	; 0
    2126:	90 93 99 00 	sts	0x0099, r25
    212a:	80 93 98 00 	sts	0x0098, r24
					}
				}
				flag_switch=0;
    212e:	10 92 99 00 	sts	0x0099, r1
    2132:	10 92 98 00 	sts	0x0098, r1
				switch((node_tx/7)+1)
    2136:	c9 01       	movw	r24, r18
    2138:	67 e0       	ldi	r22, 0x07	; 7
    213a:	70 e0       	ldi	r23, 0x00	; 0
    213c:	0e 94 c4 1a 	call	0x3588	; 0x3588 <__udivmodhi4>
    2140:	6f 5f       	subi	r22, 0xFF	; 255
    2142:	7f 4f       	sbci	r23, 0xFF	; 255
    2144:	64 30       	cpi	r22, 0x04	; 4
    2146:	71 05       	cpc	r23, r1
    2148:	09 f4       	brne	.+2      	; 0x214c <xbee_seq_node_transfer+0x25a>
    214a:	48 c0       	rjmp	.+144    	; 0x21dc <xbee_seq_node_transfer+0x2ea>
    214c:	65 30       	cpi	r22, 0x05	; 5
    214e:	71 05       	cpc	r23, r1
    2150:	58 f4       	brcc	.+22     	; 0x2168 <xbee_seq_node_transfer+0x276>
    2152:	62 30       	cpi	r22, 0x02	; 2
    2154:	71 05       	cpc	r23, r1
    2156:	01 f1       	breq	.+64     	; 0x2198 <xbee_seq_node_transfer+0x2a6>
    2158:	63 30       	cpi	r22, 0x03	; 3
    215a:	71 05       	cpc	r23, r1
    215c:	70 f5       	brcc	.+92     	; 0x21ba <xbee_seq_node_transfer+0x2c8>
    215e:	61 30       	cpi	r22, 0x01	; 1
    2160:	71 05       	cpc	r23, r1
    2162:	09 f0       	breq	.+2      	; 0x2166 <xbee_seq_node_transfer+0x274>
    2164:	7f c0       	rjmp	.+254    	; 0x2264 <xbee_seq_node_transfer+0x372>
    2166:	0d c0       	rjmp	.+26     	; 0x2182 <xbee_seq_node_transfer+0x290>
    2168:	66 30       	cpi	r22, 0x06	; 6
    216a:	71 05       	cpc	r23, r1
    216c:	09 f4       	brne	.+2      	; 0x2170 <xbee_seq_node_transfer+0x27e>
    216e:	58 c0       	rjmp	.+176    	; 0x2220 <xbee_seq_node_transfer+0x32e>
    2170:	66 30       	cpi	r22, 0x06	; 6
    2172:	71 05       	cpc	r23, r1
    2174:	08 f4       	brcc	.+2      	; 0x2178 <xbee_seq_node_transfer+0x286>
    2176:	43 c0       	rjmp	.+134    	; 0x21fe <xbee_seq_node_transfer+0x30c>
    2178:	67 30       	cpi	r22, 0x07	; 7
    217a:	71 05       	cpc	r23, r1
    217c:	09 f0       	breq	.+2      	; 0x2180 <xbee_seq_node_transfer+0x28e>
    217e:	72 c0       	rjmp	.+228    	; 0x2264 <xbee_seq_node_transfer+0x372>
    2180:	60 c0       	rjmp	.+192    	; 0x2242 <xbee_seq_node_transfer+0x350>
				{
					case 1:data = data | 0x01; flag_switch=1;
    2182:	80 91 97 00 	lds	r24, 0x0097
    2186:	81 60       	ori	r24, 0x01	; 1
    2188:	80 93 97 00 	sts	0x0097, r24
    218c:	81 e0       	ldi	r24, 0x01	; 1
    218e:	90 e0       	ldi	r25, 0x00	; 0
    2190:	90 93 99 00 	sts	0x0099, r25
    2194:	80 93 98 00 	sts	0x0098, r24
					case 2:if(flag_switch==0)
    2198:	80 91 98 00 	lds	r24, 0x0098
    219c:	90 91 99 00 	lds	r25, 0x0099
    21a0:	00 97       	sbiw	r24, 0x00	; 0
    21a2:	59 f4       	brne	.+22     	; 0x21ba <xbee_seq_node_transfer+0x2c8>
					{
						data = data | 0x02;
    21a4:	80 91 97 00 	lds	r24, 0x0097
    21a8:	82 60       	ori	r24, 0x02	; 2
    21aa:	80 93 97 00 	sts	0x0097, r24
						flag_switch=1;
    21ae:	81 e0       	ldi	r24, 0x01	; 1
    21b0:	90 e0       	ldi	r25, 0x00	; 0
    21b2:	90 93 99 00 	sts	0x0099, r25
    21b6:	80 93 98 00 	sts	0x0098, r24
					}
					case 3:if(flag_switch==0)
    21ba:	80 91 98 00 	lds	r24, 0x0098
    21be:	90 91 99 00 	lds	r25, 0x0099
    21c2:	00 97       	sbiw	r24, 0x00	; 0
    21c4:	59 f4       	brne	.+22     	; 0x21dc <xbee_seq_node_transfer+0x2ea>
					{
						data = data | 0x03;
    21c6:	80 91 97 00 	lds	r24, 0x0097
    21ca:	83 60       	ori	r24, 0x03	; 3
    21cc:	80 93 97 00 	sts	0x0097, r24
						flag_switch=1;
    21d0:	81 e0       	ldi	r24, 0x01	; 1
    21d2:	90 e0       	ldi	r25, 0x00	; 0
    21d4:	90 93 99 00 	sts	0x0099, r25
    21d8:	80 93 98 00 	sts	0x0098, r24
					}
					case 4:if(flag_switch==0)
    21dc:	80 91 98 00 	lds	r24, 0x0098
    21e0:	90 91 99 00 	lds	r25, 0x0099
    21e4:	00 97       	sbiw	r24, 0x00	; 0
    21e6:	59 f4       	brne	.+22     	; 0x21fe <xbee_seq_node_transfer+0x30c>
					{
						data = data | 0x04;
    21e8:	80 91 97 00 	lds	r24, 0x0097
    21ec:	84 60       	ori	r24, 0x04	; 4
    21ee:	80 93 97 00 	sts	0x0097, r24
						flag_switch=1;
    21f2:	81 e0       	ldi	r24, 0x01	; 1
    21f4:	90 e0       	ldi	r25, 0x00	; 0
    21f6:	90 93 99 00 	sts	0x0099, r25
    21fa:	80 93 98 00 	sts	0x0098, r24
					}
					case 5:if(flag_switch==0)
    21fe:	80 91 98 00 	lds	r24, 0x0098
    2202:	90 91 99 00 	lds	r25, 0x0099
    2206:	00 97       	sbiw	r24, 0x00	; 0
    2208:	59 f4       	brne	.+22     	; 0x2220 <xbee_seq_node_transfer+0x32e>
					{
						data = data | 0x05;
    220a:	80 91 97 00 	lds	r24, 0x0097
    220e:	85 60       	ori	r24, 0x05	; 5
    2210:	80 93 97 00 	sts	0x0097, r24
						flag_switch=1;
    2214:	81 e0       	ldi	r24, 0x01	; 1
    2216:	90 e0       	ldi	r25, 0x00	; 0
    2218:	90 93 99 00 	sts	0x0099, r25
    221c:	80 93 98 00 	sts	0x0098, r24
					}
					case 6:if(flag_switch==0)
    2220:	80 91 98 00 	lds	r24, 0x0098
    2224:	90 91 99 00 	lds	r25, 0x0099
    2228:	00 97       	sbiw	r24, 0x00	; 0
    222a:	59 f4       	brne	.+22     	; 0x2242 <xbee_seq_node_transfer+0x350>
					{
						data = data | 0x06;
    222c:	80 91 97 00 	lds	r24, 0x0097
    2230:	86 60       	ori	r24, 0x06	; 6
    2232:	80 93 97 00 	sts	0x0097, r24
						flag_switch=1;
    2236:	81 e0       	ldi	r24, 0x01	; 1
    2238:	90 e0       	ldi	r25, 0x00	; 0
    223a:	90 93 99 00 	sts	0x0099, r25
    223e:	80 93 98 00 	sts	0x0098, r24
					}
					case 7:if(flag_switch==0)
    2242:	80 91 98 00 	lds	r24, 0x0098
    2246:	90 91 99 00 	lds	r25, 0x0099
    224a:	00 97       	sbiw	r24, 0x00	; 0
    224c:	59 f4       	brne	.+22     	; 0x2264 <xbee_seq_node_transfer+0x372>
					{
						data = data | 0x07;
    224e:	80 91 97 00 	lds	r24, 0x0097
    2252:	87 60       	ori	r24, 0x07	; 7
    2254:	80 93 97 00 	sts	0x0097, r24
						flag_switch=1;
    2258:	81 e0       	ldi	r24, 0x01	; 1
    225a:	90 e0       	ldi	r25, 0x00	; 0
    225c:	90 93 99 00 	sts	0x0099, r25
    2260:	80 93 98 00 	sts	0x0098, r24
					}
				}
				flag_switch=0;
    2264:	10 92 99 00 	sts	0x0099, r1
    2268:	10 92 98 00 	sts	0x0098, r1
		}			
	    
	
        
		if(send_flag == 0)
    226c:	30 97       	sbiw	r30, 0x00	; 0
    226e:	31 f4       	brne	.+12     	; 0x227c <xbee_seq_node_transfer+0x38a>
		data = data | 0x80;
    2270:	80 91 97 00 	lds	r24, 0x0097
    2274:	80 68       	ori	r24, 0x80	; 128
    2276:	80 93 97 00 	sts	0x0097, r24
    227a:	10 c0       	rjmp	.+32     	; 0x229c <xbee_seq_node_transfer+0x3aa>
		else if(send_flag == 1)
    227c:	e1 30       	cpi	r30, 0x01	; 1
    227e:	f1 05       	cpc	r31, r1
    2280:	29 f4       	brne	.+10     	; 0x228c <xbee_seq_node_transfer+0x39a>
		data = data | 0x00;
    2282:	80 91 97 00 	lds	r24, 0x0097
    2286:	80 93 97 00 	sts	0x0097, r24
    228a:	08 c0       	rjmp	.+16     	; 0x229c <xbee_seq_node_transfer+0x3aa>
		else if(send_flag == 2)
    228c:	e2 30       	cpi	r30, 0x02	; 2
    228e:	f1 05       	cpc	r31, r1
    2290:	29 f4       	brne	.+10     	; 0x229c <xbee_seq_node_transfer+0x3aa>
		data = data | 0x40;
    2292:	80 91 97 00 	lds	r24, 0x0097
    2296:	80 64       	ori	r24, 0x40	; 64
    2298:	80 93 97 00 	sts	0x0097, r24

		UDR = data ;
    229c:	80 91 97 00 	lds	r24, 0x0097
    22a0:	8c b9       	out	0x0c, r24	; 12
}
    22a2:	08 95       	ret

000022a4 <glow_red>:
  */

void glow_red()
{
	unsigned char PortCRestore = 0;
	PortCRestore = PORTC ;
    22a4:	85 b3       	in	r24, 0x15	; 21
	PortCRestore = PortCRestore & 0xF8;
    22a6:	88 7f       	andi	r24, 0xF8	; 248
	PortCRestore = PortCRestore | 0x01;
    22a8:	81 60       	ori	r24, 0x01	; 1
	PORTC = PortCRestore;
    22aa:	85 bb       	out	0x15, r24	; 21
}
    22ac:	08 95       	ret

000022ae <glow_green>:
  */

void glow_green()
{
	unsigned char PortCRestore = 0;
	PortCRestore = PORTC ;
    22ae:	85 b3       	in	r24, 0x15	; 21
	PortCRestore = PortCRestore & 0xF8;
    22b0:	88 7f       	andi	r24, 0xF8	; 248
	PortCRestore = PortCRestore | 0x02;
    22b2:	82 60       	ori	r24, 0x02	; 2
	PORTC = PortCRestore;
    22b4:	85 bb       	out	0x15, r24	; 21
}
    22b6:	08 95       	ret

000022b8 <glow_blue>:
  */

void glow_blue()
{
	unsigned char PortCRestore = 0;
	PortCRestore = PORTC ;
    22b8:	85 b3       	in	r24, 0x15	; 21
	PortCRestore = PortCRestore & 0xF8;
    22ba:	88 7f       	andi	r24, 0xF8	; 248
	PortCRestore = PortCRestore | 0x04;
    22bc:	84 60       	ori	r24, 0x04	; 4
	PORTC = PortCRestore;
    22be:	85 bb       	out	0x15, r24	; 21
}
    22c0:	08 95       	ret

000022c2 <rgb_off>:
  */

void rgb_off()
{
	unsigned char PortCRestore = 0;
	PortCRestore = PORTC ;
    22c2:	85 b3       	in	r24, 0x15	; 21
	PortCRestore = PortCRestore & 0xF8;
    22c4:	88 7f       	andi	r24, 0xF8	; 248
	PORTC = PortCRestore;
    22c6:	85 bb       	out	0x15, r24	; 21
}
    22c8:	08 95       	ret

000022ca <glow>:
  * Example Call: glow(1)
  */

void glow(unsigned int rgb_color)
{
	if(rgb_color == 0) 
    22ca:	00 97       	sbiw	r24, 0x00	; 0
    22cc:	71 f4       	brne	.+28     	; 0x22ea <glow+0x20>
	{
		glow_red();
    22ce:	0e 94 52 11 	call	0x22a4	; 0x22a4 <glow_red>
    22d2:	8f ef       	ldi	r24, 0xFF	; 255
    22d4:	9f e7       	ldi	r25, 0x7F	; 127
    22d6:	a6 e1       	ldi	r26, 0x16	; 22
    22d8:	81 50       	subi	r24, 0x01	; 1
    22da:	90 40       	sbci	r25, 0x00	; 0
    22dc:	a0 40       	sbci	r26, 0x00	; 0
    22de:	e1 f7       	brne	.-8      	; 0x22d8 <glow+0xe>
    22e0:	00 c0       	rjmp	.+0      	; 0x22e2 <glow+0x18>
    22e2:	00 00       	nop
		_delay_ms(1000);
		rgb_off();
    22e4:	0e 94 61 11 	call	0x22c2	; 0x22c2 <rgb_off>
    22e8:	08 95       	ret
	}
	else if(rgb_color == 1)
    22ea:	81 30       	cpi	r24, 0x01	; 1
    22ec:	91 05       	cpc	r25, r1
    22ee:	71 f4       	brne	.+28     	; 0x230c <glow+0x42>
	{
		glow_green();
    22f0:	0e 94 57 11 	call	0x22ae	; 0x22ae <glow_green>
    22f4:	8f ef       	ldi	r24, 0xFF	; 255
    22f6:	9f e7       	ldi	r25, 0x7F	; 127
    22f8:	a6 e1       	ldi	r26, 0x16	; 22
    22fa:	81 50       	subi	r24, 0x01	; 1
    22fc:	90 40       	sbci	r25, 0x00	; 0
    22fe:	a0 40       	sbci	r26, 0x00	; 0
    2300:	e1 f7       	brne	.-8      	; 0x22fa <glow+0x30>
    2302:	00 c0       	rjmp	.+0      	; 0x2304 <glow+0x3a>
    2304:	00 00       	nop
		_delay_ms(1000);
		rgb_off();
    2306:	0e 94 61 11 	call	0x22c2	; 0x22c2 <rgb_off>
    230a:	08 95       	ret
	}
	else if(rgb_color == 2)
    230c:	82 30       	cpi	r24, 0x02	; 2
    230e:	91 05       	cpc	r25, r1
    2310:	69 f4       	brne	.+26     	; 0x232c <glow+0x62>
	{
		glow_blue();
    2312:	0e 94 5c 11 	call	0x22b8	; 0x22b8 <glow_blue>
    2316:	8f ef       	ldi	r24, 0xFF	; 255
    2318:	9f e7       	ldi	r25, 0x7F	; 127
    231a:	a6 e1       	ldi	r26, 0x16	; 22
    231c:	81 50       	subi	r24, 0x01	; 1
    231e:	90 40       	sbci	r25, 0x00	; 0
    2320:	a0 40       	sbci	r26, 0x00	; 0
    2322:	e1 f7       	brne	.-8      	; 0x231c <glow+0x52>
    2324:	00 c0       	rjmp	.+0      	; 0x2326 <glow+0x5c>
    2326:	00 00       	nop
		_delay_ms(1000);
		rgb_off();
    2328:	0e 94 61 11 	call	0x22c2	; 0x22c2 <rgb_off>
    232c:	08 95       	ret

0000232e <__vector_9>:
  * Logic: This interrupt service routine is called on timer overflow.
  * Example Call: N.A
  */

ISR(_VECTOR(9))
{
    232e:	1f 92       	push	r1
    2330:	0f 92       	push	r0
    2332:	0f b6       	in	r0, 0x3f	; 63
    2334:	0f 92       	push	r0
    2336:	11 24       	eor	r1, r1
    2338:	8f 93       	push	r24
    233a:	9f 93       	push	r25
	TIFR=0X01;
    233c:	81 e0       	ldi	r24, 0x01	; 1
    233e:	88 bf       	out	0x38, r24	; 56
	Timer_Count++;
    2340:	80 91 11 01 	lds	r24, 0x0111
    2344:	8f 5f       	subi	r24, 0xFF	; 255
    2346:	80 93 11 01 	sts	0x0111, r24

	if( Timer_Count < 125 )
    234a:	80 91 11 01 	lds	r24, 0x0111
    234e:	8d 37       	cpi	r24, 0x7D	; 125
    2350:	10 f4       	brcc	.+4      	; 0x2356 <__vector_9+0x28>
	TCNT0=0XEB;
    2352:	8b ee       	ldi	r24, 0xEB	; 235
    2354:	82 bf       	out	0x32, r24	; 50

	if( Timer_Count == Servo_Value )
    2356:	90 91 11 01 	lds	r25, 0x0111
    235a:	80 91 6e 00 	lds	r24, 0x006E
    235e:	98 17       	cp	r25, r24
    2360:	09 f4       	brne	.+2      	; 0x2364 <__vector_9+0x36>
	PORTD &=~(1<<7);
    2362:	97 98       	cbi	0x12, 7	; 18

	if( Timer_Count >= 125 )
    2364:	80 91 11 01 	lds	r24, 0x0111
    2368:	8d 37       	cpi	r24, 0x7D	; 125
    236a:	20 f0       	brcs	.+8      	; 0x2374 <__vector_9+0x46>
	{
		TCNT0=0X97;
    236c:	87 e9       	ldi	r24, 0x97	; 151
    236e:	82 bf       	out	0x32, r24	; 50
		TCCR0=0X04;
    2370:	84 e0       	ldi	r24, 0x04	; 4
    2372:	83 bf       	out	0x33, r24	; 51
	}

	if( Timer_Count == 130 )
    2374:	80 91 11 01 	lds	r24, 0x0111
    2378:	82 38       	cpi	r24, 0x82	; 130
    237a:	41 f4       	brne	.+16     	; 0x238c <__vector_9+0x5e>
	{
		PORTD = 0X80;
    237c:	80 e8       	ldi	r24, 0x80	; 128
    237e:	82 bb       	out	0x12, r24	; 18
		TCCR0 = 0X02;
    2380:	82 e0       	ldi	r24, 0x02	; 2
    2382:	83 bf       	out	0x33, r24	; 51
		TCNT0 = 0XEB;
    2384:	8b ee       	ldi	r24, 0xEB	; 235
    2386:	82 bf       	out	0x32, r24	; 50
		Timer_Count = 0;
    2388:	10 92 11 01 	sts	0x0111, r1
	}
}
    238c:	9f 91       	pop	r25
    238e:	8f 91       	pop	r24
    2390:	0f 90       	pop	r0
    2392:	0f be       	out	0x3f, r0	; 63
    2394:	0f 90       	pop	r0
    2396:	1f 90       	pop	r1
    2398:	18 95       	reti

0000239a <Convert_Angle>:

unsigned char  Convert_Angle(unsigned char  k)
{
	unsigned char timer_value;
	int temp;
	temp = k*5;
    239a:	90 e0       	ldi	r25, 0x00	; 0
    239c:	9c 01       	movw	r18, r24
    239e:	22 0f       	add	r18, r18
    23a0:	33 1f       	adc	r19, r19
    23a2:	22 0f       	add	r18, r18
    23a4:	33 1f       	adc	r19, r19
    23a6:	82 0f       	add	r24, r18
    23a8:	93 1f       	adc	r25, r19
	timer_value = temp/9;
    23aa:	69 e0       	ldi	r22, 0x09	; 9
    23ac:	70 e0       	ldi	r23, 0x00	; 0
    23ae:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <__divmodhi4>
    23b2:	86 2f       	mov	r24, r22
    23b4:	e9 e9       	ldi	r30, 0x99	; 153
    23b6:	f5 e1       	ldi	r31, 0x15	; 21
    23b8:	31 97       	sbiw	r30, 0x01	; 1
    23ba:	f1 f7       	brne	.-4      	; 0x23b8 <Convert_Angle+0x1e>
    23bc:	00 c0       	rjmp	.+0      	; 0x23be <Convert_Angle+0x24>
	timer_value = timer_value+25;
	_delay_ms(3);
	return timer_value;
}
    23be:	87 5e       	subi	r24, 0xE7	; 231
    23c0:	08 95       	ret

000023c2 <feedOut>:
  * Example Call: feedOut()
  */

void feedOut()
{
	Servo_Value=Convert_Angle(100);
    23c2:	84 e6       	ldi	r24, 0x64	; 100
    23c4:	0e 94 cd 11 	call	0x239a	; 0x239a <Convert_Angle>
    23c8:	80 93 6e 00 	sts	0x006E, r24
    23cc:	8f ef       	ldi	r24, 0xFF	; 255
    23ce:	9f ea       	ldi	r25, 0xAF	; 175
    23d0:	a1 e0       	ldi	r26, 0x01	; 1
    23d2:	81 50       	subi	r24, 0x01	; 1
    23d4:	90 40       	sbci	r25, 0x00	; 0
    23d6:	a0 40       	sbci	r26, 0x00	; 0
    23d8:	e1 f7       	brne	.-8      	; 0x23d2 <feedOut+0x10>
    23da:	00 c0       	rjmp	.+0      	; 0x23dc <feedOut+0x1a>
    23dc:	00 00       	nop
	_delay_ms(75);
	Servo_Value=Convert_Angle(0);
    23de:	80 e0       	ldi	r24, 0x00	; 0
    23e0:	0e 94 cd 11 	call	0x239a	; 0x239a <Convert_Angle>
    23e4:	80 93 6e 00 	sts	0x006E, r24
    23e8:	8f ef       	ldi	r24, 0xFF	; 255
    23ea:	9f ef       	ldi	r25, 0xFF	; 255
    23ec:	a8 e0       	ldi	r26, 0x08	; 8
    23ee:	81 50       	subi	r24, 0x01	; 1
    23f0:	90 40       	sbci	r25, 0x00	; 0
    23f2:	a0 40       	sbci	r26, 0x00	; 0
    23f4:	e1 f7       	brne	.-8      	; 0x23ee <feedOut+0x2c>
    23f6:	00 c0       	rjmp	.+0      	; 0x23f8 <feedOut+0x36>
    23f8:	00 00       	nop
	_delay_ms(400);

}
    23fa:	08 95       	ret

000023fc <Sharp_GP2D12_estimation>:
#define F_CPU 7372800
unsigned char sharp=0;
unsigned int value;

unsigned int Sharp_GP2D12_estimation(unsigned char adc_reading)
{
    23fc:	0f 93       	push	r16
    23fe:	1f 93       	push	r17
	float distance;
	unsigned int distanceInt;
	distance = (int)(10.00*(2799.6*(1.00/(pow(adc_reading,1.1546)))));
    2400:	68 2f       	mov	r22, r24
    2402:	70 e0       	ldi	r23, 0x00	; 0
    2404:	80 e0       	ldi	r24, 0x00	; 0
    2406:	90 e0       	ldi	r25, 0x00	; 0
    2408:	0e 94 6e 18 	call	0x30dc	; 0x30dc <__floatunsisf>
    240c:	2f ee       	ldi	r18, 0xEF	; 239
    240e:	39 ec       	ldi	r19, 0xC9	; 201
    2410:	43 e9       	ldi	r20, 0x93	; 147
    2412:	5f e3       	ldi	r21, 0x3F	; 63
    2414:	0e 94 5f 19 	call	0x32be	; 0x32be <pow>
    2418:	b6 2f       	mov	r27, r22
    241a:	a7 2f       	mov	r26, r23
    241c:	38 2f       	mov	r19, r24
    241e:	29 2f       	mov	r18, r25
    2420:	60 e0       	ldi	r22, 0x00	; 0
    2422:	70 e0       	ldi	r23, 0x00	; 0
    2424:	80 e8       	ldi	r24, 0x80	; 128
    2426:	9f e3       	ldi	r25, 0x3F	; 63
    2428:	42 2f       	mov	r20, r18
    242a:	0b 2f       	mov	r16, r27
    242c:	1a 2f       	mov	r17, r26
    242e:	23 2f       	mov	r18, r19
    2430:	34 2f       	mov	r19, r20
    2432:	a9 01       	movw	r20, r18
    2434:	98 01       	movw	r18, r16
    2436:	0e 94 d5 17 	call	0x2faa	; 0x2faa <__divsf3>
    243a:	2a e9       	ldi	r18, 0x9A	; 154
    243c:	39 ef       	ldi	r19, 0xF9	; 249
    243e:	4e e2       	ldi	r20, 0x2E	; 46
    2440:	55 e4       	ldi	r21, 0x45	; 69
    2442:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <__mulsf3>
    2446:	20 e0       	ldi	r18, 0x00	; 0
    2448:	30 e0       	ldi	r19, 0x00	; 0
    244a:	40 e2       	ldi	r20, 0x20	; 32
    244c:	51 e4       	ldi	r21, 0x41	; 65
    244e:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <__mulsf3>
    2452:	0e 94 3d 18 	call	0x307a	; 0x307a <__fixsfsi>
    2456:	88 27       	eor	r24, r24
    2458:	77 fd       	sbrc	r23, 7
    245a:	80 95       	com	r24
    245c:	98 2f       	mov	r25, r24
    245e:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__floatsisf>
	distanceInt = (int)distance;
    2462:	0e 94 3d 18 	call	0x307a	; 0x307a <__fixsfsi>
	if(distanceInt>800)
	{
		distanceInt=800;
	}
	return distanceInt;
    2466:	86 2f       	mov	r24, r22
    2468:	97 2f       	mov	r25, r23
    246a:	23 e0       	ldi	r18, 0x03	; 3
    246c:	81 32       	cpi	r24, 0x21	; 33
    246e:	92 07       	cpc	r25, r18
    2470:	10 f0       	brcs	.+4      	; 0x2476 <Sharp_GP2D12_estimation+0x7a>
    2472:	80 e2       	ldi	r24, 0x20	; 32
    2474:	93 e0       	ldi	r25, 0x03	; 3
}
    2476:	1f 91       	pop	r17
    2478:	0f 91       	pop	r16
    247a:	08 95       	ret

0000247c <sharp_check>:

unsigned int sharp_check(void)
{
    sharp=ADC_Conversion(7);
    247c:	87 e0       	ldi	r24, 0x07	; 7
    247e:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    2482:	80 93 6c 00 	sts	0x006C, r24
    value= Sharp_GP2D12_estimation(sharp);
    2486:	0e 94 fe 11 	call	0x23fc	; 0x23fc <Sharp_GP2D12_estimation>
    248a:	90 93 1c 01 	sts	0x011C, r25
    248e:	80 93 1b 01 	sts	0x011B, r24
    2492:	2f ef       	ldi	r18, 0xFF	; 255
    2494:	3f eb       	ldi	r19, 0xBF	; 191
    2496:	46 e0       	ldi	r20, 0x06	; 6
    2498:	21 50       	subi	r18, 0x01	; 1
    249a:	30 40       	sbci	r19, 0x00	; 0
    249c:	40 40       	sbci	r20, 0x00	; 0
    249e:	e1 f7       	brne	.-8      	; 0x2498 <sharp_check+0x1c>
    24a0:	00 c0       	rjmp	.+0      	; 0x24a2 <sharp_check+0x26>
    24a2:	00 00       	nop
	_delay_ms(300);
	if(value<150)
	 {
	   return 1;
    24a4:	21 e0       	ldi	r18, 0x01	; 1
    24a6:	30 e0       	ldi	r19, 0x00	; 0
    24a8:	86 39       	cpi	r24, 0x96	; 150
    24aa:	91 05       	cpc	r25, r1
    24ac:	10 f0       	brcs	.+4      	; 0x24b2 <sharp_check+0x36>
    24ae:	20 e0       	ldi	r18, 0x00	; 0
    24b0:	30 e0       	ldi	r19, 0x00	; 0
	 }
	 return 0;
}
    24b2:	82 2f       	mov	r24, r18
    24b4:	93 2f       	mov	r25, r19
    24b6:	08 95       	ret

000024b8 <set_path_to_99>:
  * Example Call: set_path_to_99()
  */

void set_path_to_99()
{   
	for(j=0;j<20;++j)
    24b8:	10 92 b4 00 	sts	0x00B4, r1
    24bc:	80 91 b4 00 	lds	r24, 0x00B4
    24c0:	84 31       	cpi	r24, 0x14	; 20
    24c2:	b0 f4       	brcc	.+44     	; 0x24f0 <set_path_to_99+0x38>
	initial_home_run[j]=99;
    24c4:	8b eb       	ldi	r24, 0xBB	; 187
    24c6:	90 e0       	ldi	r25, 0x00	; 0
    24c8:	23 e6       	ldi	r18, 0x63	; 99
    24ca:	30 e0       	ldi	r19, 0x00	; 0
    24cc:	e0 91 b4 00 	lds	r30, 0x00B4
    24d0:	f0 e0       	ldi	r31, 0x00	; 0
    24d2:	ee 0f       	add	r30, r30
    24d4:	ff 1f       	adc	r31, r31
    24d6:	e8 0f       	add	r30, r24
    24d8:	f9 1f       	adc	r31, r25
    24da:	31 83       	std	Z+1, r19	; 0x01
    24dc:	20 83       	st	Z, r18
  * Example Call: set_path_to_99()
  */

void set_path_to_99()
{   
	for(j=0;j<20;++j)
    24de:	40 91 b4 00 	lds	r20, 0x00B4
    24e2:	4f 5f       	subi	r20, 0xFF	; 255
    24e4:	40 93 b4 00 	sts	0x00B4, r20
    24e8:	40 91 b4 00 	lds	r20, 0x00B4
    24ec:	44 31       	cpi	r20, 0x14	; 20
    24ee:	70 f3       	brcs	.-36     	; 0x24cc <set_path_to_99+0x14>
    24f0:	08 95       	ret

000024f2 <reach_destination>:
           It also transfers the the starting position to firebird V via xbee module so that firebird can calculate its Dijkstra path right at start and send the same back to it. 
  * Example Call: reach_destination(4,'A',0)
  */

void reach_destination(unsigned char s1, unsigned char s2 , unsigned int ini_orient)
{  
    24f2:	0f 93       	push	r16
    24f4:	1f 93       	push	r17
    24f6:	cf 93       	push	r28
    24f8:	df 93       	push	r29
    24fa:	08 2f       	mov	r16, r24
    24fc:	16 2f       	mov	r17, r22
    24fe:	ea 01       	movw	r28, r20
    set_path_to_99();
    2500:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <set_path_to_99>
	
	orient=ini_orient;
    2504:	d0 93 f7 00 	sts	0x00F7, r29
    2508:	c0 93 f6 00 	sts	0x00F6, r28
	
	curr_pos = convert_rowcol_to_seq(s1,s2);
    250c:	80 2f       	mov	r24, r16
    250e:	61 2f       	mov	r22, r17
    2510:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <convert_rowcol_to_seq>
    2514:	90 93 b3 00 	sts	0x00B3, r25
    2518:	80 93 b2 00 	sts	0x00B2, r24
	
	xbee_seq_node_transfer(curr_pos,0);
    251c:	80 91 b2 00 	lds	r24, 0x00B2
    2520:	90 91 b3 00 	lds	r25, 0x00B3
    2524:	60 e0       	ldi	r22, 0x00	; 0
    2526:	70 e0       	ldi	r23, 0x00	; 0
    2528:	0e 94 79 0f 	call	0x1ef2	; 0x1ef2 <xbee_seq_node_transfer>
}
    252c:	df 91       	pop	r29
    252e:	cf 91       	pop	r28
    2530:	1f 91       	pop	r17
    2532:	0f 91       	pop	r16
    2534:	08 95       	ret

00002536 <check_path_rec>:
  * Example Call: check_path_rec()
  */

void check_path_rec()
{
	if((initial_home_run[node_count-1]==41) && (home_bit[0]==0))
    2536:	e0 91 94 00 	lds	r30, 0x0094
    253a:	f0 91 95 00 	lds	r31, 0x0095
    253e:	ee 0f       	add	r30, r30
    2540:	ff 1f       	adc	r31, r31
    2542:	e7 54       	subi	r30, 0x47	; 71
    2544:	ff 4f       	sbci	r31, 0xFF	; 255
    2546:	80 81       	ld	r24, Z
    2548:	91 81       	ldd	r25, Z+1	; 0x01
    254a:	89 32       	cpi	r24, 0x29	; 41
    254c:	91 05       	cpc	r25, r1
    254e:	71 f4       	brne	.+28     	; 0x256c <check_path_rec+0x36>
    2550:	80 91 a2 00 	lds	r24, 0x00A2
    2554:	90 91 a3 00 	lds	r25, 0x00A3
    2558:	00 97       	sbiw	r24, 0x00	; 0
    255a:	41 f4       	brne	.+16     	; 0x256c <check_path_rec+0x36>
	{
		UDR = 0x80;
    255c:	80 e8       	ldi	r24, 0x80	; 128
    255e:	8c b9       	out	0x0c, r24	; 12
		home_bit[0]=1;
    2560:	81 e0       	ldi	r24, 0x01	; 1
    2562:	90 e0       	ldi	r25, 0x00	; 0
    2564:	90 93 a3 00 	sts	0x00A3, r25
    2568:	80 93 a2 00 	sts	0x00A2, r24
    256c:	08 95       	ret

0000256e <all_bot_ready>:
  * Example Call: all_bot_ready()
  */ 

int all_bot_ready()
{
 	if((home_bit[0]==1) && (home_bit[1]==1) && (home_bit[2]==1)) return 1; 
    256e:	80 91 a2 00 	lds	r24, 0x00A2
    2572:	90 91 a3 00 	lds	r25, 0x00A3
    2576:	81 30       	cpi	r24, 0x01	; 1
    2578:	91 05       	cpc	r25, r1
    257a:	99 f4       	brne	.+38     	; 0x25a2 <all_bot_ready+0x34>
    257c:	80 91 a4 00 	lds	r24, 0x00A4
    2580:	90 91 a5 00 	lds	r25, 0x00A5
    2584:	81 30       	cpi	r24, 0x01	; 1
    2586:	91 05       	cpc	r25, r1
    2588:	79 f4       	brne	.+30     	; 0x25a8 <all_bot_ready+0x3a>
    258a:	20 91 a6 00 	lds	r18, 0x00A6
    258e:	30 91 a7 00 	lds	r19, 0x00A7
  * Output: None
  * Logic: This function  checks whether all the bots have finished their set/cycle/navigation and returns 1 or 0 accordingly
  * Example Call: all_bot_ready()
  */ 

int all_bot_ready()
    2592:	81 e0       	ldi	r24, 0x01	; 1
    2594:	90 e0       	ldi	r25, 0x00	; 0
    2596:	21 30       	cpi	r18, 0x01	; 1
    2598:	31 05       	cpc	r19, r1
    259a:	41 f0       	breq	.+16     	; 0x25ac <all_bot_ready+0x3e>
    259c:	80 e0       	ldi	r24, 0x00	; 0
    259e:	90 e0       	ldi	r25, 0x00	; 0
    25a0:	08 95       	ret
{
 	if((home_bit[0]==1) && (home_bit[1]==1) && (home_bit[2]==1)) return 1; 
	return 0;
    25a2:	80 e0       	ldi	r24, 0x00	; 0
    25a4:	90 e0       	ldi	r25, 0x00	; 0
    25a6:	08 95       	ret
    25a8:	80 e0       	ldi	r24, 0x00	; 0
    25aa:	90 e0       	ldi	r25, 0x00	; 0
}
    25ac:	08 95       	ret

000025ae <line_follow_set0>:
           
  * Example Call: line_follow_set0()
  */ 

void line_follow_set0(void)
{
    25ae:	8f 92       	push	r8
    25b0:	9f 92       	push	r9
    25b2:	af 92       	push	r10
    25b4:	bf 92       	push	r11
    25b6:	cf 92       	push	r12
    25b8:	df 92       	push	r13
    25ba:	ef 92       	push	r14
    25bc:	ff 92       	push	r15
    25be:	0f 93       	push	r16
    25c0:	1f 93       	push	r17
    25c2:	cf 93       	push	r28
    25c4:	df 93       	push	r29
	
	Left_white_line = ADC_Conversion(3);
    25c6:	83 e0       	ldi	r24, 0x03	; 3
    25c8:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    25cc:	80 93 77 00 	sts	0x0077, r24
	Center_white_line = ADC_Conversion(4);
    25d0:	84 e0       	ldi	r24, 0x04	; 4
    25d2:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    25d6:	80 93 76 00 	sts	0x0076, r24
	Right_white_line = ADC_Conversion(5);
    25da:	85 e0       	ldi	r24, 0x05	; 5
    25dc:	0e 94 f1 01 	call	0x3e2	; 0x3e2 <ADC_Conversion>
    25e0:	80 93 75 00 	sts	0x0075, r24
	error = Right_white_line - Left_white_line;
    25e4:	90 e0       	ldi	r25, 0x00	; 0
    25e6:	20 91 77 00 	lds	r18, 0x0077
    25ea:	82 1b       	sub	r24, r18
    25ec:	91 09       	sbc	r25, r1
    25ee:	90 93 13 01 	sts	0x0113, r25
    25f2:	80 93 12 01 	sts	0x0112, r24
	int motorSpeed = Kp * error + Kd * (error - lastError);
    25f6:	60 91 12 01 	lds	r22, 0x0112
    25fa:	70 91 13 01 	lds	r23, 0x0113
    25fe:	c0 90 67 00 	lds	r12, 0x0067
    2602:	d0 90 68 00 	lds	r13, 0x0068
    2606:	e0 90 69 00 	lds	r14, 0x0069
    260a:	f0 90 6a 00 	lds	r15, 0x006A
    260e:	c0 91 12 01 	lds	r28, 0x0112
    2612:	d0 91 13 01 	lds	r29, 0x0113
    2616:	00 91 78 00 	lds	r16, 0x0078
    261a:	10 91 79 00 	lds	r17, 0x0079
    261e:	80 90 63 00 	lds	r8, 0x0063
    2622:	90 90 64 00 	lds	r9, 0x0064
    2626:	a0 90 65 00 	lds	r10, 0x0065
    262a:	b0 90 66 00 	lds	r11, 0x0066
    262e:	88 27       	eor	r24, r24
    2630:	77 fd       	sbrc	r23, 7
    2632:	80 95       	com	r24
    2634:	98 2f       	mov	r25, r24
    2636:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__floatsisf>
    263a:	a7 01       	movw	r20, r14
    263c:	96 01       	movw	r18, r12
    263e:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <__mulsf3>
    2642:	6b 01       	movw	r12, r22
    2644:	7c 01       	movw	r14, r24
    2646:	be 01       	movw	r22, r28
    2648:	60 1b       	sub	r22, r16
    264a:	71 0b       	sbc	r23, r17
    264c:	88 27       	eor	r24, r24
    264e:	77 fd       	sbrc	r23, 7
    2650:	80 95       	com	r24
    2652:	98 2f       	mov	r25, r24
    2654:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__floatsisf>
    2658:	a5 01       	movw	r20, r10
    265a:	94 01       	movw	r18, r8
    265c:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <__mulsf3>
    2660:	9b 01       	movw	r18, r22
    2662:	ac 01       	movw	r20, r24
    2664:	c7 01       	movw	r24, r14
    2666:	b6 01       	movw	r22, r12
    2668:	0e 94 71 17 	call	0x2ee2	; 0x2ee2 <__addsf3>
    266c:	0e 94 3d 18 	call	0x307a	; 0x307a <__fixsfsi>
	lastError = error;
    2670:	80 91 12 01 	lds	r24, 0x0112
    2674:	90 91 13 01 	lds	r25, 0x0113
    2678:	90 93 79 00 	sts	0x0079, r25
    267c:	80 93 78 00 	sts	0x0078, r24
	int rightMotorSpeed = rightBaseSpeed - motorSpeed;
    2680:	00 91 62 00 	lds	r16, 0x0062
    2684:	10 e0       	ldi	r17, 0x00	; 0
	int leftMotorSpeed = leftBaseSpeed + motorSpeed;
    2686:	80 91 61 00 	lds	r24, 0x0061
    268a:	eb 01       	movw	r28, r22
    268c:	c8 0f       	add	r28, r24
    268e:	d1 1d       	adc	r29, r1
    2690:	06 1b       	sub	r16, r22
    2692:	17 0b       	sbc	r17, r23
    2694:	0e 32       	cpi	r16, 0x2E	; 46
    2696:	11 05       	cpc	r17, r1
    2698:	14 f0       	brlt	.+4      	; 0x269e <line_follow_set0+0xf0>
    269a:	0d e2       	ldi	r16, 0x2D	; 45
    269c:	10 e0       	ldi	r17, 0x00	; 0
    269e:	ce 32       	cpi	r28, 0x2E	; 46
    26a0:	d1 05       	cpc	r29, r1
    26a2:	14 f0       	brlt	.+4      	; 0x26a8 <line_follow_set0+0xfa>
    26a4:	cd e2       	ldi	r28, 0x2D	; 45
    26a6:	d0 e0       	ldi	r29, 0x00	; 0
	if (rightMotorSpeed > rightMaxSpeed ) rightMotorSpeed = rightMaxSpeed;
	if (leftMotorSpeed > leftMaxSpeed ) leftMotorSpeed = leftMaxSpeed;
	if (rightMotorSpeed < 0) rightMotorSpeed = 0;
	if (leftMotorSpeed < 0) leftMotorSpeed = 0;

	forward();
    26a8:	0e 94 28 0b 	call	0x1650	; 0x1650 <forward>
	velocity(leftMotorSpeed,rightMotorSpeed);
    26ac:	ce 01       	movw	r24, r28
    26ae:	dd 23       	and	r29, r29
    26b0:	14 f4       	brge	.+4      	; 0x26b6 <line_follow_set0+0x108>
    26b2:	80 e0       	ldi	r24, 0x00	; 0
    26b4:	90 e0       	ldi	r25, 0x00	; 0
    26b6:	b8 01       	movw	r22, r16
    26b8:	11 23       	and	r17, r17
    26ba:	14 f4       	brge	.+4      	; 0x26c0 <line_follow_set0+0x112>
    26bc:	60 e0       	ldi	r22, 0x00	; 0
    26be:	70 e0       	ldi	r23, 0x00	; 0
    26c0:	0e 94 8a 00 	call	0x114	; 0x114 <velocity>

	if(Center_white_line>40 && Left_white_line>40 && Right_white_line>40)
    26c4:	80 91 76 00 	lds	r24, 0x0076
    26c8:	89 32       	cpi	r24, 0x29	; 41
    26ca:	08 f4       	brcc	.+2      	; 0x26ce <line_follow_set0+0x120>
    26cc:	a3 c0       	rjmp	.+326    	; 0x2814 <line_follow_set0+0x266>
    26ce:	80 91 77 00 	lds	r24, 0x0077
    26d2:	89 32       	cpi	r24, 0x29	; 41
    26d4:	08 f4       	brcc	.+2      	; 0x26d8 <line_follow_set0+0x12a>
    26d6:	9e c0       	rjmp	.+316    	; 0x2814 <line_follow_set0+0x266>
    26d8:	80 91 75 00 	lds	r24, 0x0075
    26dc:	89 32       	cpi	r24, 0x29	; 41
    26de:	08 f4       	brcc	.+2      	; 0x26e2 <line_follow_set0+0x134>
    26e0:	99 c0       	rjmp	.+306    	; 0x2814 <line_follow_set0+0x266>
	{	
		update_curr_pos();
    26e2:	0e 94 8f 00 	call	0x11e	; 0x11e <update_curr_pos>
		
	//	velocity(40,40);
		//_delay_ms(300);
		//just_forward();
		stop();
    26e6:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <stop>
		buzz();
    26ea:	0e 94 02 02 	call	0x404	; 0x404 <buzz>
		
       if(curr_pos == 35)
    26ee:	80 91 b2 00 	lds	r24, 0x00B2
    26f2:	90 91 b3 00 	lds	r25, 0x00B3
    26f6:	83 32       	cpi	r24, 0x23	; 35
    26f8:	91 05       	cpc	r25, r1
    26fa:	b9 f5       	brne	.+110    	; 0x276a <line_follow_set0+0x1bc>
		{
			ensure_orient(1);
    26fc:	81 e0       	ldi	r24, 0x01	; 1
    26fe:	90 e0       	ldi	r25, 0x00	; 0
    2700:	0e 94 03 0b 	call	0x1606	; 0x1606 <ensure_orient>
			UDR = 0x80;
    2704:	80 e8       	ldi	r24, 0x80	; 128
    2706:	8c b9       	out	0x0c, r24	; 12
    2708:	2f ef       	ldi	r18, 0xFF	; 255
    270a:	3f e3       	ldi	r19, 0x3F	; 63
    270c:	42 e0       	ldi	r20, 0x02	; 2
    270e:	21 50       	subi	r18, 0x01	; 1
    2710:	30 40       	sbci	r19, 0x00	; 0
    2712:	40 40       	sbci	r20, 0x00	; 0
    2714:	e1 f7       	brne	.-8      	; 0x270e <line_follow_set0+0x160>
    2716:	00 c0       	rjmp	.+0      	; 0x2718 <line_follow_set0+0x16a>
    2718:	00 00       	nop
			_delay_ms(100);
			UDR = 0x80;
    271a:	8c b9       	out	0x0c, r24	; 12
    271c:	2f ef       	ldi	r18, 0xFF	; 255
    271e:	3f e3       	ldi	r19, 0x3F	; 63
    2720:	42 e0       	ldi	r20, 0x02	; 2
    2722:	21 50       	subi	r18, 0x01	; 1
    2724:	30 40       	sbci	r19, 0x00	; 0
    2726:	40 40       	sbci	r20, 0x00	; 0
    2728:	e1 f7       	brne	.-8      	; 0x2722 <line_follow_set0+0x174>
    272a:	00 c0       	rjmp	.+0      	; 0x272c <line_follow_set0+0x17e>
    272c:	00 00       	nop
			_delay_ms(100);
			UDR = 0x80;
    272e:	8c b9       	out	0x0c, r24	; 12
			home_bit[0] = 1;
    2730:	81 e0       	ldi	r24, 0x01	; 1
    2732:	90 e0       	ldi	r25, 0x00	; 0
    2734:	90 93 a3 00 	sts	0x00A3, r25
    2738:	80 93 a2 00 	sts	0x00A2, r24
			while(all_bot_ready() == 0);
    273c:	0e 94 b7 12 	call	0x256e	; 0x256e <all_bot_ready>
    2740:	00 97       	sbiw	r24, 0x00	; 0
    2742:	e1 f3       	breq	.-8      	; 0x273c <line_follow_set0+0x18e>
			all_bot_clear();
    2744:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <all_bot_clear>
			event = 0;
    2748:	10 92 9b 00 	sts	0x009B, r1
    274c:	10 92 9a 00 	sts	0x009A, r1
			cycle = 1;
    2750:	81 e0       	ldi	r24, 0x01	; 1
    2752:	90 e0       	ldi	r25, 0x00	; 0
    2754:	90 93 a1 00 	sts	0x00A1, r25
    2758:	80 93 a0 00 	sts	0x00A0, r24
			set_cover=50;
    275c:	82 e3       	ldi	r24, 0x32	; 50
    275e:	90 e0       	ldi	r25, 0x00	; 0
    2760:	90 93 9d 00 	sts	0x009D, r25
    2764:	80 93 9c 00 	sts	0x009C, r24
    2768:	36 c0       	rjmp	.+108    	; 0x27d6 <line_follow_set0+0x228>
		}
		else if(curr_pos==41)
    276a:	80 91 b2 00 	lds	r24, 0x00B2
    276e:	90 91 b3 00 	lds	r25, 0x00B3
    2772:	89 32       	cpi	r24, 0x29	; 41
    2774:	91 05       	cpc	r25, r1
    2776:	49 f5       	brne	.+82     	; 0x27ca <line_follow_set0+0x21c>
		{
			event=3;
    2778:	83 e0       	ldi	r24, 0x03	; 3
    277a:	90 e0       	ldi	r25, 0x00	; 0
    277c:	90 93 9b 00 	sts	0x009B, r25
    2780:	80 93 9a 00 	sts	0x009A, r24
			cycle = 1;
    2784:	c1 e0       	ldi	r28, 0x01	; 1
    2786:	d0 e0       	ldi	r29, 0x00	; 0
    2788:	d0 93 a1 00 	sts	0x00A1, r29
    278c:	c0 93 a0 00 	sts	0x00A0, r28
			ensure_orient(3);
    2790:	0e 94 03 0b 	call	0x1606	; 0x1606 <ensure_orient>
			home_bit[0]=1;
    2794:	d0 93 a3 00 	sts	0x00A3, r29
    2798:	c0 93 a2 00 	sts	0x00A2, r28
			UDR = 0x80;
    279c:	80 e8       	ldi	r24, 0x80	; 128
    279e:	8c b9       	out	0x0c, r24	; 12
    27a0:	2f ef       	ldi	r18, 0xFF	; 255
    27a2:	3f e3       	ldi	r19, 0x3F	; 63
    27a4:	42 e0       	ldi	r20, 0x02	; 2
    27a6:	21 50       	subi	r18, 0x01	; 1
    27a8:	30 40       	sbci	r19, 0x00	; 0
    27aa:	40 40       	sbci	r20, 0x00	; 0
    27ac:	e1 f7       	brne	.-8      	; 0x27a6 <line_follow_set0+0x1f8>
    27ae:	00 c0       	rjmp	.+0      	; 0x27b0 <line_follow_set0+0x202>
    27b0:	00 00       	nop
			_delay_ms(100);
			UDR = 0x80;
    27b2:	8c b9       	out	0x0c, r24	; 12
    27b4:	2f ef       	ldi	r18, 0xFF	; 255
    27b6:	3f e3       	ldi	r19, 0x3F	; 63
    27b8:	42 e0       	ldi	r20, 0x02	; 2
    27ba:	21 50       	subi	r18, 0x01	; 1
    27bc:	30 40       	sbci	r19, 0x00	; 0
    27be:	40 40       	sbci	r20, 0x00	; 0
    27c0:	e1 f7       	brne	.-8      	; 0x27ba <line_follow_set0+0x20c>
    27c2:	00 c0       	rjmp	.+0      	; 0x27c4 <line_follow_set0+0x216>
    27c4:	00 00       	nop
			_delay_ms(100);
			UDR = 0x80;
    27c6:	8c b9       	out	0x0c, r24	; 12
    27c8:	06 c0       	rjmp	.+12     	; 0x27d6 <line_follow_set0+0x228>
		}
		else
		{
			event=0;
    27ca:	10 92 9b 00 	sts	0x009B, r1
    27ce:	10 92 9a 00 	sts	0x009A, r1
			//forward();
			//velocity(100,100);
			//_delay_ms(300);
			just_forward();
    27d2:	0e 94 15 01 	call	0x22a	; 0x22a <just_forward>
		}
		if((curr_pos == 39) && (set_cover == 0))
    27d6:	80 91 b2 00 	lds	r24, 0x00B2
    27da:	90 91 b3 00 	lds	r25, 0x00B3
    27de:	87 32       	cpi	r24, 0x27	; 39
    27e0:	91 05       	cpc	r25, r1
    27e2:	41 f4       	brne	.+16     	; 0x27f4 <line_follow_set0+0x246>
    27e4:	80 91 9c 00 	lds	r24, 0x009C
    27e8:	90 91 9d 00 	lds	r25, 0x009D
    27ec:	00 97       	sbiw	r24, 0x00	; 0
    27ee:	11 f4       	brne	.+4      	; 0x27f4 <line_follow_set0+0x246>
		{
			all_xbee_clear();
    27f0:	0e 94 df 00 	call	0x1be	; 0x1be <all_xbee_clear>
		}
		if((curr_pos == 37) && (set_cover == 50))
    27f4:	80 91 b2 00 	lds	r24, 0x00B2
    27f8:	90 91 b3 00 	lds	r25, 0x00B3
    27fc:	85 32       	cpi	r24, 0x25	; 37
    27fe:	91 05       	cpc	r25, r1
    2800:	49 f4       	brne	.+18     	; 0x2814 <line_follow_set0+0x266>
    2802:	80 91 9c 00 	lds	r24, 0x009C
    2806:	90 91 9d 00 	lds	r25, 0x009D
    280a:	82 33       	cpi	r24, 0x32	; 50
    280c:	91 05       	cpc	r25, r1
    280e:	11 f4       	brne	.+4      	; 0x2814 <line_follow_set0+0x266>
		{
			all_xbee_clear();
    2810:	0e 94 df 00 	call	0x1be	; 0x1be <all_xbee_clear>
		}
	}	 
}
    2814:	df 91       	pop	r29
    2816:	cf 91       	pop	r28
    2818:	1f 91       	pop	r17
    281a:	0f 91       	pop	r16
    281c:	ff 90       	pop	r15
    281e:	ef 90       	pop	r14
    2820:	df 90       	pop	r13
    2822:	cf 90       	pop	r12
    2824:	bf 90       	pop	r11
    2826:	af 90       	pop	r10
    2828:	9f 90       	pop	r9
    282a:	8f 90       	pop	r8
    282c:	08 95       	ret

0000282e <main>:
 cycle 5: This cycle marks the end of task.		  		  

*/

void main()
{
    282e:	2f 92       	push	r2
    2830:	3f 92       	push	r3
    2832:	4f 92       	push	r4
    2834:	5f 92       	push	r5
    2836:	6f 92       	push	r6
    2838:	7f 92       	push	r7
    283a:	8f 92       	push	r8
    283c:	9f 92       	push	r9
    283e:	af 92       	push	r10
    2840:	bf 92       	push	r11
    2842:	cf 92       	push	r12
    2844:	df 92       	push	r13
    2846:	ef 92       	push	r14
    2848:	ff 92       	push	r15
    284a:	0f 93       	push	r16
    284c:	1f 93       	push	r17
    284e:	cf 93       	push	r28
    2850:	df 93       	push	r29
   init_devices();
    2852:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <init_devices>
    2856:	8f ef       	ldi	r24, 0xFF	; 255
    2858:	9f e3       	ldi	r25, 0x3F	; 63
    285a:	ab e0       	ldi	r26, 0x0B	; 11
    285c:	81 50       	subi	r24, 0x01	; 1
    285e:	90 40       	sbci	r25, 0x00	; 0
    2860:	a0 40       	sbci	r26, 0x00	; 0
    2862:	e1 f7       	brne	.-8      	; 0x285c <main+0x2e>
    2864:	00 c0       	rjmp	.+0      	; 0x2866 <main+0x38>
    2866:	00 00       	nop
   _delay_ms(500);
   reach_destination('2','B',1);
    2868:	82 e3       	ldi	r24, 0x32	; 50
    286a:	62 e4       	ldi	r22, 0x42	; 66
    286c:	41 e0       	ldi	r20, 0x01	; 1
    286e:	50 e0       	ldi	r21, 0x00	; 0
    2870:	0e 94 79 12 	call	0x24f2	; 0x24f2 <reach_destination>
		  }
		  if(event == 2)
		  {
			  if(all_bot_ready() == 1)
			  {
				  cycle = 1;
    2874:	ee 24       	eor	r14, r14
    2876:	ff 24       	eor	r15, r15
    2878:	e3 94       	inc	r14
				  event = 0;
				  all_bot_clear();
				  xbee_com = 1;
    287a:	99 24       	eor	r9, r9
    287c:	93 94       	inc	r9
			  }
		  }
		  if(event == 1)
		  {
			  run_home();
			  event = 2;
    287e:	c2 e0       	ldi	r28, 0x02	; 2
    2880:	d0 e0       	ldi	r29, 0x00	; 0
			  
			  if(all_bot_ready() == 1)
			  {
				  all_bot_clear();
				  all_xbee_clear();
				  xbee_com = -1;
    2882:	88 24       	eor	r8, r8
    2884:	8a 94       	dec	r8
			  else if(set_cover==50)
			  {
				  if(left_plant_set2_count==0)line_follow_till_2(27);
				  else
				  {
					  line_follow_till_2(left_plant_set2[array_index]);
    2886:	0f 2e       	mov	r0, r31
    2888:	f7 e0       	ldi	r31, 0x07	; 7
    288a:	2f 2e       	mov	r2, r31
    288c:	f1 e0       	ldi	r31, 0x01	; 1
    288e:	3f 2e       	mov	r3, r31
    2890:	f0 2d       	mov	r31, r0
			  if(set_cover==0)
			  {
				  if(right_plant_set2_count==0)line_follow_till_2(21);
				  else
				  {
					  line_follow_till_2(right_plant_set2[array_index]);
    2892:	0f 2e       	mov	r0, r31
    2894:	fc ee       	ldi	r31, 0xEC	; 236
    2896:	af 2e       	mov	r10, r31
    2898:	f0 e0       	ldi	r31, 0x00	; 0
    289a:	bf 2e       	mov	r11, r31
    289c:	f0 2d       	mov	r31, r0
		  UDR = 0x80;
		  _delay_ms(100);
		  UDR = 0x80;
		  _delay_ms(100);
		  UDR = 0x80;
		  home_bit[0] = 1;
    289e:	0f 2e       	mov	r0, r31
    28a0:	f2 ea       	ldi	r31, 0xA2	; 162
    28a2:	4f 2e       	mov	r4, r31
    28a4:	f0 e0       	ldi	r31, 0x00	; 0
    28a6:	5f 2e       	mov	r5, r31
    28a8:	f0 2d       	mov	r31, r0
			  else if(set_cover==50)
			  {
				  if(left_plant_set1_count==0)line_follow_till_1(13);
				  else
				  {
					  line_follow_till_1(left_plant_set1[array_index]);
    28aa:	0f 2e       	mov	r0, r31
    28ac:	fa ef       	ldi	r31, 0xFA	; 250
    28ae:	6f 2e       	mov	r6, r31
    28b0:	f0 e0       	ldi	r31, 0x00	; 0
    28b2:	7f 2e       	mov	r7, r31
    28b4:	f0 2d       	mov	r31, r0
			  if(set_cover==0)
			  {
				  if(right_plant_set1_count==0)line_follow_till_1(7);
				  else
				  {
					  line_follow_till_1(right_plant_set1[array_index]);
    28b6:	0f 2e       	mov	r0, r31
    28b8:	f8 ea       	ldi	r31, 0xA8	; 168
    28ba:	cf 2e       	mov	r12, r31
    28bc:	f0 e0       	ldi	r31, 0x00	; 0
    28be:	df 2e       	mov	r13, r31
    28c0:	f0 2d       	mov	r31, r0
			  line_follow_set0();
		  }
		  if(event == 3)
		  {
			  xbee_com = 1;
			  set_cover = 50;
    28c2:	02 e3       	ldi	r16, 0x32	; 50
    28c4:	10 e0       	ldi	r17, 0x00	; 0
   _delay_ms(500);
   reach_destination('2','B',1);
  while(1)
  {
	  
	  if(cycle == 0)
    28c6:	80 91 a0 00 	lds	r24, 0x00A0
    28ca:	90 91 a1 00 	lds	r25, 0x00A1
    28ce:	00 97       	sbiw	r24, 0x00	; 0
    28d0:	09 f0       	breq	.+2      	; 0x28d4 <main+0xa6>
    28d2:	45 c0       	rjmp	.+138    	; 0x295e <main+0x130>
	  {
		  if(event == 0)
    28d4:	80 91 9a 00 	lds	r24, 0x009A
    28d8:	90 91 9b 00 	lds	r25, 0x009B
    28dc:	00 97       	sbiw	r24, 0x00	; 0
    28de:	b1 f4       	brne	.+44     	; 0x290c <main+0xde>
		  {
			  check_path_rec();
    28e0:	0e 94 9b 12 	call	0x2536	; 0x2536 <check_path_rec>
			  
			  if(all_bot_ready() == 1)
    28e4:	0e 94 b7 12 	call	0x256e	; 0x256e <all_bot_ready>
    28e8:	81 30       	cpi	r24, 0x01	; 1
    28ea:	91 05       	cpc	r25, r1
    28ec:	79 f4       	brne	.+30     	; 0x290c <main+0xde>
			  {
				  all_bot_clear();
    28ee:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <all_bot_clear>
				  all_xbee_clear();
    28f2:	0e 94 df 00 	call	0x1be	; 0x1be <all_xbee_clear>
				  xbee_com = -1;
    28f6:	80 92 96 00 	sts	0x0096, r8
				  event++;
    28fa:	80 91 9a 00 	lds	r24, 0x009A
    28fe:	90 91 9b 00 	lds	r25, 0x009B
    2902:	01 96       	adiw	r24, 0x01	; 1
    2904:	90 93 9b 00 	sts	0x009B, r25
    2908:	80 93 9a 00 	sts	0x009A, r24
			  }
		  }
		  if(event == 1)
    290c:	80 91 9a 00 	lds	r24, 0x009A
    2910:	90 91 9b 00 	lds	r25, 0x009B
    2914:	81 30       	cpi	r24, 0x01	; 1
    2916:	91 05       	cpc	r25, r1
    2918:	51 f4       	brne	.+20     	; 0x292e <main+0x100>
		  {
			  run_home();
    291a:	0e 94 10 02 	call	0x420	; 0x420 <run_home>
			  event = 2;
    291e:	d0 93 9b 00 	sts	0x009B, r29
    2922:	c0 93 9a 00 	sts	0x009A, r28
			  cycle = 0;
    2926:	10 92 a1 00 	sts	0x00A1, r1
    292a:	10 92 a0 00 	sts	0x00A0, r1
		  }
		  if(event == 2)
    292e:	80 91 9a 00 	lds	r24, 0x009A
    2932:	90 91 9b 00 	lds	r25, 0x009B
    2936:	82 30       	cpi	r24, 0x02	; 2
    2938:	91 05       	cpc	r25, r1
    293a:	89 f4       	brne	.+34     	; 0x295e <main+0x130>
		  {
			  if(all_bot_ready() == 1)
    293c:	0e 94 b7 12 	call	0x256e	; 0x256e <all_bot_ready>
    2940:	81 30       	cpi	r24, 0x01	; 1
    2942:	91 05       	cpc	r25, r1
    2944:	61 f4       	brne	.+24     	; 0x295e <main+0x130>
			  {
				  cycle = 1;
    2946:	f0 92 a1 00 	sts	0x00A1, r15
    294a:	e0 92 a0 00 	sts	0x00A0, r14
				  event = 0;
    294e:	10 92 9b 00 	sts	0x009B, r1
    2952:	10 92 9a 00 	sts	0x009A, r1
				  all_bot_clear();
    2956:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <all_bot_clear>
				  xbee_com = 1;
    295a:	90 92 96 00 	sts	0x0096, r9
			  }
		  }
		  
	  }
	  if(cycle == 1)
    295e:	80 91 a0 00 	lds	r24, 0x00A0
    2962:	90 91 a1 00 	lds	r25, 0x00A1
    2966:	81 30       	cpi	r24, 0x01	; 1
    2968:	91 05       	cpc	r25, r1
    296a:	09 f0       	breq	.+2      	; 0x296e <main+0x140>
    296c:	d2 c0       	rjmp	.+420    	; 0x2b12 <main+0x2e4>
	  {
		  if(event == 0)
    296e:	80 91 9a 00 	lds	r24, 0x009A
    2972:	90 91 9b 00 	lds	r25, 0x009B
    2976:	00 97       	sbiw	r24, 0x00	; 0
    2978:	19 f5       	brne	.+70     	; 0x29c0 <main+0x192>
		  {
			  forward_mm(110);
    297a:	8e e6       	ldi	r24, 0x6E	; 110
    297c:	90 e0       	ldi	r25, 0x00	; 0
    297e:	0e 94 a5 0b 	call	0x174a	; 0x174a <forward_mm>
			  stop();
    2982:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <stop>
			  
			  
			  if(sharp_check() == 1)
    2986:	0e 94 3e 12 	call	0x247c	; 0x247c <sharp_check>
    298a:	81 30       	cpi	r24, 0x01	; 1
    298c:	91 05       	cpc	r25, r1
    298e:	a1 f4       	brne	.+40     	; 0x29b8 <main+0x18a>
			  {
				  event = 1;
    2990:	f0 92 9b 00 	sts	0x009B, r15
    2994:	e0 92 9a 00 	sts	0x009A, r14
				  forward_mm(40);
    2998:	88 e2       	ldi	r24, 0x28	; 40
    299a:	90 e0       	ldi	r25, 0x00	; 0
    299c:	0e 94 a5 0b 	call	0x174a	; 0x174a <forward_mm>
				  stop();
    29a0:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <stop>
    29a4:	8f ef       	ldi	r24, 0xFF	; 255
    29a6:	9f e7       	ldi	r25, 0x7F	; 127
    29a8:	a4 e0       	ldi	r26, 0x04	; 4
    29aa:	81 50       	subi	r24, 0x01	; 1
    29ac:	90 40       	sbci	r25, 0x00	; 0
    29ae:	a0 40       	sbci	r26, 0x00	; 0
    29b0:	e1 f7       	brne	.-8      	; 0x29aa <main+0x17c>
    29b2:	00 c0       	rjmp	.+0      	; 0x29b4 <main+0x186>
    29b4:	00 00       	nop
    29b6:	04 c0       	rjmp	.+8      	; 0x29c0 <main+0x192>
				  _delay_ms(200);
				  
			  }
			  else
			  event = 2;
    29b8:	d0 93 9b 00 	sts	0x009B, r29
    29bc:	c0 93 9a 00 	sts	0x009A, r28
		  }
		  if(event == 1)
    29c0:	80 91 9a 00 	lds	r24, 0x009A
    29c4:	90 91 9b 00 	lds	r25, 0x009B
    29c8:	81 30       	cpi	r24, 0x01	; 1
    29ca:	91 05       	cpc	r25, r1
    29cc:	09 f0       	breq	.+2      	; 0x29d0 <main+0x1a2>
    29ce:	53 c0       	rjmp	.+166    	; 0x2a76 <main+0x248>
		  {
			  color_check();
    29d0:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <color_check>
			  if(color_result == 2)
    29d4:	80 91 19 01 	lds	r24, 0x0119
    29d8:	90 91 1a 01 	lds	r25, 0x011A
    29dc:	82 30       	cpi	r24, 0x02	; 2
    29de:	91 05       	cpc	r25, r1
    29e0:	81 f4       	brne	.+32     	; 0x2a02 <main+0x1d4>
			  {
				  glow_blue();
    29e2:	0e 94 5c 11 	call	0x22b8	; 0x22b8 <glow_blue>
				  feedOut();
    29e6:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <feedOut>
    29ea:	8f ef       	ldi	r24, 0xFF	; 255
    29ec:	9f ef       	ldi	r25, 0xFF	; 255
    29ee:	ac e2       	ldi	r26, 0x2C	; 44
    29f0:	81 50       	subi	r24, 0x01	; 1
    29f2:	90 40       	sbci	r25, 0x00	; 0
    29f4:	a0 40       	sbci	r26, 0x00	; 0
    29f6:	e1 f7       	brne	.-8      	; 0x29f0 <main+0x1c2>
    29f8:	00 c0       	rjmp	.+0      	; 0x29fa <main+0x1cc>
    29fa:	00 00       	nop
				  _delay_ms(2000);
				  rgb_off();
    29fc:	0e 94 61 11 	call	0x22c2	; 0x22c2 <rgb_off>
    2a00:	36 c0       	rjmp	.+108    	; 0x2a6e <main+0x240>
			  }
			  else
			  {
				  if(color_result == 1)
    2a02:	80 91 19 01 	lds	r24, 0x0119
    2a06:	90 91 1a 01 	lds	r25, 0x011A
    2a0a:	81 30       	cpi	r24, 0x01	; 1
    2a0c:	91 05       	cpc	r25, r1
    2a0e:	a9 f4       	brne	.+42     	; 0x2a3a <main+0x20c>
				  {
					  glow_green();
    2a10:	0e 94 57 11 	call	0x22ae	; 0x22ae <glow_green>
					  xbee_seq_node_transfer(curr_pos, 1);
    2a14:	80 91 b2 00 	lds	r24, 0x00B2
    2a18:	90 91 b3 00 	lds	r25, 0x00B3
    2a1c:	b7 01       	movw	r22, r14
    2a1e:	0e 94 79 0f 	call	0x1ef2	; 0x1ef2 <xbee_seq_node_transfer>
    2a22:	8f ef       	ldi	r24, 0xFF	; 255
    2a24:	9f ef       	ldi	r25, 0xFF	; 255
    2a26:	ac e2       	ldi	r26, 0x2C	; 44
    2a28:	81 50       	subi	r24, 0x01	; 1
    2a2a:	90 40       	sbci	r25, 0x00	; 0
    2a2c:	a0 40       	sbci	r26, 0x00	; 0
    2a2e:	e1 f7       	brne	.-8      	; 0x2a28 <main+0x1fa>
    2a30:	00 c0       	rjmp	.+0      	; 0x2a32 <main+0x204>
    2a32:	00 00       	nop
					  _delay_ms(2000);
					  rgb_off();
    2a34:	0e 94 61 11 	call	0x22c2	; 0x22c2 <rgb_off>
    2a38:	1a c0       	rjmp	.+52     	; 0x2a6e <main+0x240>
				  }
				  else if(color_result == 0)
    2a3a:	80 91 19 01 	lds	r24, 0x0119
    2a3e:	90 91 1a 01 	lds	r25, 0x011A
    2a42:	00 97       	sbiw	r24, 0x00	; 0
    2a44:	a1 f4       	brne	.+40     	; 0x2a6e <main+0x240>
				  {
					  glow_red();
    2a46:	0e 94 52 11 	call	0x22a4	; 0x22a4 <glow_red>
					  xbee_seq_node_transfer(curr_pos, 2);
    2a4a:	80 91 b2 00 	lds	r24, 0x00B2
    2a4e:	90 91 b3 00 	lds	r25, 0x00B3
    2a52:	be 01       	movw	r22, r28
    2a54:	0e 94 79 0f 	call	0x1ef2	; 0x1ef2 <xbee_seq_node_transfer>
    2a58:	8f ef       	ldi	r24, 0xFF	; 255
    2a5a:	9f ef       	ldi	r25, 0xFF	; 255
    2a5c:	ac e2       	ldi	r26, 0x2C	; 44
    2a5e:	81 50       	subi	r24, 0x01	; 1
    2a60:	90 40       	sbci	r25, 0x00	; 0
    2a62:	a0 40       	sbci	r26, 0x00	; 0
    2a64:	e1 f7       	brne	.-8      	; 0x2a5e <main+0x230>
    2a66:	00 c0       	rjmp	.+0      	; 0x2a68 <main+0x23a>
    2a68:	00 00       	nop
					  _delay_ms(2000);
					  rgb_off();
    2a6a:	0e 94 61 11 	call	0x22c2	; 0x22c2 <rgb_off>
				  }
			  }
			  event = 2;
    2a6e:	d0 93 9b 00 	sts	0x009B, r29
    2a72:	c0 93 9a 00 	sts	0x009A, r28
		  }
		  if(event == 2)
    2a76:	80 91 9a 00 	lds	r24, 0x009A
    2a7a:	90 91 9b 00 	lds	r25, 0x009B
    2a7e:	82 30       	cpi	r24, 0x02	; 2
    2a80:	91 05       	cpc	r25, r1
    2a82:	11 f4       	brne	.+4      	; 0x2a88 <main+0x25a>
		  {
			  line_follow_set0();
    2a84:	0e 94 d7 12 	call	0x25ae	; 0x25ae <line_follow_set0>
		  }
		  if(event == 3)
    2a88:	80 91 9a 00 	lds	r24, 0x009A
    2a8c:	90 91 9b 00 	lds	r25, 0x009B
    2a90:	83 30       	cpi	r24, 0x03	; 3
    2a92:	91 05       	cpc	r25, r1
    2a94:	09 f0       	breq	.+2      	; 0x2a98 <main+0x26a>
    2a96:	17 cf       	rjmp	.-466    	; 0x28c6 <main+0x98>
		  {
			  xbee_com = 1;
    2a98:	90 92 96 00 	sts	0x0096, r9
			  set_cover = 50;
    2a9c:	10 93 9d 00 	sts	0x009D, r17
    2aa0:	00 93 9c 00 	sts	0x009C, r16
			  if(all_bot_ready()==1)
    2aa4:	0e 94 b7 12 	call	0x256e	; 0x256e <all_bot_ready>
    2aa8:	81 30       	cpi	r24, 0x01	; 1
    2aaa:	91 05       	cpc	r25, r1
    2aac:	09 f0       	breq	.+2      	; 0x2ab0 <main+0x282>
    2aae:	0b cf       	rjmp	.-490    	; 0x28c6 <main+0x98>
			  {
				  all_bot_clear();
    2ab0:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <all_bot_clear>
				  cycle = 2;
    2ab4:	d0 93 a1 00 	sts	0x00A1, r29
    2ab8:	c0 93 a0 00 	sts	0x00A0, r28
				  navigate_0();
    2abc:	0e 94 6f 05 	call	0xade	; 0xade <navigate_0>
				  stop();
    2ac0:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <stop>
				  UDR = 0x80;
    2ac4:	90 e8       	ldi	r25, 0x80	; 128
    2ac6:	9c b9       	out	0x0c, r25	; 12
    2ac8:	8f ef       	ldi	r24, 0xFF	; 255
    2aca:	9f e3       	ldi	r25, 0x3F	; 63
    2acc:	a2 e0       	ldi	r26, 0x02	; 2
    2ace:	81 50       	subi	r24, 0x01	; 1
    2ad0:	90 40       	sbci	r25, 0x00	; 0
    2ad2:	a0 40       	sbci	r26, 0x00	; 0
    2ad4:	e1 f7       	brne	.-8      	; 0x2ace <main+0x2a0>
    2ad6:	00 c0       	rjmp	.+0      	; 0x2ad8 <main+0x2aa>
    2ad8:	00 00       	nop
				  _delay_ms(100);
				  UDR = 0x80;
    2ada:	90 e8       	ldi	r25, 0x80	; 128
    2adc:	9c b9       	out	0x0c, r25	; 12
    2ade:	8f ef       	ldi	r24, 0xFF	; 255
    2ae0:	9f e3       	ldi	r25, 0x3F	; 63
    2ae2:	a2 e0       	ldi	r26, 0x02	; 2
    2ae4:	81 50       	subi	r24, 0x01	; 1
    2ae6:	90 40       	sbci	r25, 0x00	; 0
    2ae8:	a0 40       	sbci	r26, 0x00	; 0
    2aea:	e1 f7       	brne	.-8      	; 0x2ae4 <main+0x2b6>
    2aec:	00 c0       	rjmp	.+0      	; 0x2aee <main+0x2c0>
    2aee:	00 00       	nop
				  _delay_ms(100);
				  UDR = 0x80;
    2af0:	90 e8       	ldi	r25, 0x80	; 128
    2af2:	9c b9       	out	0x0c, r25	; 12
				  home_bit[0] = 1;
    2af4:	d2 01       	movw	r26, r4
    2af6:	11 96       	adiw	r26, 0x01	; 1
    2af8:	fc 92       	st	X, r15
    2afa:	ee 92       	st	-X, r14
				  while(all_bot_ready() == 0);
    2afc:	0e 94 b7 12 	call	0x256e	; 0x256e <all_bot_ready>
    2b00:	00 97       	sbiw	r24, 0x00	; 0
    2b02:	e1 f3       	breq	.-8      	; 0x2afc <main+0x2ce>
				  all_bot_clear();
    2b04:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <all_bot_clear>
				  start_flag = 1;
    2b08:	f0 92 18 01 	sts	0x0118, r15
    2b0c:	e0 92 17 01 	sts	0x0117, r14
    2b10:	da ce       	rjmp	.-588    	; 0x28c6 <main+0x98>
			  }
		  }
	  }
	  else if(cycle == 2)
    2b12:	80 91 a0 00 	lds	r24, 0x00A0
    2b16:	90 91 a1 00 	lds	r25, 0x00A1
    2b1a:	82 30       	cpi	r24, 0x02	; 2
    2b1c:	91 05       	cpc	r25, r1
    2b1e:	09 f0       	breq	.+2      	; 0x2b22 <main+0x2f4>
    2b20:	e1 c0       	rjmp	.+450    	; 0x2ce4 <main+0x4b6>
	  {
		  if(event==0)
    2b22:	80 91 9a 00 	lds	r24, 0x009A
    2b26:	90 91 9b 00 	lds	r25, 0x009B
    2b2a:	00 97       	sbiw	r24, 0x00	; 0
    2b2c:	09 f0       	breq	.+2      	; 0x2b30 <main+0x302>
    2b2e:	40 c0       	rjmp	.+128    	; 0x2bb0 <main+0x382>
		  {
			  if(set_cover==0)
    2b30:	80 91 9c 00 	lds	r24, 0x009C
    2b34:	90 91 9d 00 	lds	r25, 0x009D
    2b38:	00 97       	sbiw	r24, 0x00	; 0
    2b3a:	c9 f4       	brne	.+50     	; 0x2b6e <main+0x340>
			  {
				  if(right_plant_set1_count==0)line_follow_till_1(7);
    2b3c:	80 91 92 00 	lds	r24, 0x0092
    2b40:	90 91 93 00 	lds	r25, 0x0093
    2b44:	00 97       	sbiw	r24, 0x00	; 0
    2b46:	29 f4       	brne	.+10     	; 0x2b52 <main+0x324>
    2b48:	87 e0       	ldi	r24, 0x07	; 7
    2b4a:	90 e0       	ldi	r25, 0x00	; 0
    2b4c:	0e 94 68 07 	call	0xed0	; 0xed0 <line_follow_till_1>
    2b50:	ba ce       	rjmp	.-652    	; 0x28c6 <main+0x98>
				  else
				  {
					  line_follow_till_1(right_plant_set1[array_index]);
    2b52:	80 91 8a 00 	lds	r24, 0x008A
    2b56:	90 91 8b 00 	lds	r25, 0x008B
    2b5a:	88 0f       	add	r24, r24
    2b5c:	99 1f       	adc	r25, r25
    2b5e:	8c 0d       	add	r24, r12
    2b60:	9d 1d       	adc	r25, r13
    2b62:	fc 01       	movw	r30, r24
    2b64:	80 81       	ld	r24, Z
    2b66:	91 81       	ldd	r25, Z+1	; 0x01
    2b68:	0e 94 68 07 	call	0xed0	; 0xed0 <line_follow_till_1>
    2b6c:	ac ce       	rjmp	.-680    	; 0x28c6 <main+0x98>
				  }
				  
			  }
			  else if(set_cover==50)
    2b6e:	80 91 9c 00 	lds	r24, 0x009C
    2b72:	90 91 9d 00 	lds	r25, 0x009D
    2b76:	82 33       	cpi	r24, 0x32	; 50
    2b78:	91 05       	cpc	r25, r1
    2b7a:	09 f0       	breq	.+2      	; 0x2b7e <main+0x350>
    2b7c:	a4 ce       	rjmp	.-696    	; 0x28c6 <main+0x98>
			  {
				  if(left_plant_set1_count==0)line_follow_till_1(13);
    2b7e:	80 91 90 00 	lds	r24, 0x0090
    2b82:	90 91 91 00 	lds	r25, 0x0091
    2b86:	00 97       	sbiw	r24, 0x00	; 0
    2b88:	29 f4       	brne	.+10     	; 0x2b94 <main+0x366>
    2b8a:	8d e0       	ldi	r24, 0x0D	; 13
    2b8c:	90 e0       	ldi	r25, 0x00	; 0
    2b8e:	0e 94 68 07 	call	0xed0	; 0xed0 <line_follow_till_1>
    2b92:	99 ce       	rjmp	.-718    	; 0x28c6 <main+0x98>
				  else
				  {
					  line_follow_till_1(left_plant_set1[array_index]);
    2b94:	80 91 8a 00 	lds	r24, 0x008A
    2b98:	90 91 8b 00 	lds	r25, 0x008B
    2b9c:	88 0f       	add	r24, r24
    2b9e:	99 1f       	adc	r25, r25
    2ba0:	86 0d       	add	r24, r6
    2ba2:	97 1d       	adc	r25, r7
    2ba4:	dc 01       	movw	r26, r24
    2ba6:	8d 91       	ld	r24, X+
    2ba8:	9c 91       	ld	r25, X
    2baa:	0e 94 68 07 	call	0xed0	; 0xed0 <line_follow_till_1>
    2bae:	8b ce       	rjmp	.-746    	; 0x28c6 <main+0x98>
				  }
			  }
		  }
		  else if(event==1)
    2bb0:	80 91 9a 00 	lds	r24, 0x009A
    2bb4:	90 91 9b 00 	lds	r25, 0x009B
    2bb8:	81 30       	cpi	r24, 0x01	; 1
    2bba:	91 05       	cpc	r25, r1
    2bbc:	f1 f5       	brne	.+124    	; 0x2c3a <main+0x40c>
		  {
			  glow_blue();
    2bbe:	0e 94 5c 11 	call	0x22b8	; 0x22b8 <glow_blue>
			  feedOut();
    2bc2:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <feedOut>
			  rgb_off();
    2bc6:	0e 94 61 11 	call	0x22c2	; 0x22c2 <rgb_off>
			  event=0;
    2bca:	10 92 9b 00 	sts	0x009B, r1
    2bce:	10 92 9a 00 	sts	0x009A, r1
		      if(set_cover==0)                 {--right_plant_set1_count;  ++array_index; }
    2bd2:	80 91 9c 00 	lds	r24, 0x009C
    2bd6:	90 91 9d 00 	lds	r25, 0x009D
    2bda:	00 97       	sbiw	r24, 0x00	; 0
    2bdc:	99 f4       	brne	.+38     	; 0x2c04 <main+0x3d6>
    2bde:	80 91 92 00 	lds	r24, 0x0092
    2be2:	90 91 93 00 	lds	r25, 0x0093
    2be6:	01 97       	sbiw	r24, 0x01	; 1
    2be8:	90 93 93 00 	sts	0x0093, r25
    2bec:	80 93 92 00 	sts	0x0092, r24
    2bf0:	80 91 8a 00 	lds	r24, 0x008A
    2bf4:	90 91 8b 00 	lds	r25, 0x008B
    2bf8:	01 96       	adiw	r24, 0x01	; 1
    2bfa:	90 93 8b 00 	sts	0x008B, r25
    2bfe:	80 93 8a 00 	sts	0x008A, r24
    2c02:	61 ce       	rjmp	.-830    	; 0x28c6 <main+0x98>
	          else if(set_cover==50)           {--left_plant_set1_count;   ++array_index; }
    2c04:	80 91 9c 00 	lds	r24, 0x009C
    2c08:	90 91 9d 00 	lds	r25, 0x009D
    2c0c:	82 33       	cpi	r24, 0x32	; 50
    2c0e:	91 05       	cpc	r25, r1
    2c10:	09 f0       	breq	.+2      	; 0x2c14 <main+0x3e6>
    2c12:	59 ce       	rjmp	.-846    	; 0x28c6 <main+0x98>
    2c14:	80 91 90 00 	lds	r24, 0x0090
    2c18:	90 91 91 00 	lds	r25, 0x0091
    2c1c:	01 97       	sbiw	r24, 0x01	; 1
    2c1e:	90 93 91 00 	sts	0x0091, r25
    2c22:	80 93 90 00 	sts	0x0090, r24
    2c26:	80 91 8a 00 	lds	r24, 0x008A
    2c2a:	90 91 8b 00 	lds	r25, 0x008B
    2c2e:	01 96       	adiw	r24, 0x01	; 1
    2c30:	90 93 8b 00 	sts	0x008B, r25
    2c34:	80 93 8a 00 	sts	0x008A, r24
    2c38:	46 ce       	rjmp	.-884    	; 0x28c6 <main+0x98>
          }
  else if(event == 2)       // will wait for all bots to complete the whole set and hence start navigation to next step
    2c3a:	80 91 9a 00 	lds	r24, 0x009A
    2c3e:	90 91 9b 00 	lds	r25, 0x009B
    2c42:	82 30       	cpi	r24, 0x02	; 2
    2c44:	91 05       	cpc	r25, r1
    2c46:	09 f0       	breq	.+2      	; 0x2c4a <main+0x41c>
    2c48:	3e ce       	rjmp	.-900    	; 0x28c6 <main+0x98>
  {
	  if(all_bot_ready()==1)
    2c4a:	0e 94 b7 12 	call	0x256e	; 0x256e <all_bot_ready>
    2c4e:	81 30       	cpi	r24, 0x01	; 1
    2c50:	91 05       	cpc	r25, r1
    2c52:	09 f0       	breq	.+2      	; 0x2c56 <main+0x428>
    2c54:	38 ce       	rjmp	.-912    	; 0x28c6 <main+0x98>
	  {
		  all_bot_clear();
    2c56:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <all_bot_clear>
		  navigate_1();
    2c5a:	0e 94 7f 06 	call	0xcfe	; 0xcfe <navigate_1>
		  ++set;
    2c5e:	80 91 9e 00 	lds	r24, 0x009E
    2c62:	90 91 9f 00 	lds	r25, 0x009F
    2c66:	01 96       	adiw	r24, 0x01	; 1
    2c68:	90 93 9f 00 	sts	0x009F, r25
    2c6c:	80 93 9e 00 	sts	0x009E, r24
		  set_cover=0;
    2c70:	10 92 9d 00 	sts	0x009D, r1
    2c74:	10 92 9c 00 	sts	0x009C, r1
		  array_index=0;
    2c78:	10 92 8b 00 	sts	0x008B, r1
    2c7c:	10 92 8a 00 	sts	0x008A, r1
		  event=0;
    2c80:	10 92 9b 00 	sts	0x009B, r1
    2c84:	10 92 9a 00 	sts	0x009A, r1
		  ++cycle;
    2c88:	80 91 a0 00 	lds	r24, 0x00A0
    2c8c:	90 91 a1 00 	lds	r25, 0x00A1
    2c90:	01 96       	adiw	r24, 0x01	; 1
    2c92:	90 93 a1 00 	sts	0x00A1, r25
    2c96:	80 93 a0 00 	sts	0x00A0, r24
		  stop();
    2c9a:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <stop>
		  UDR = 0x80;
    2c9e:	b0 e8       	ldi	r27, 0x80	; 128
    2ca0:	bc b9       	out	0x0c, r27	; 12
    2ca2:	8f ef       	ldi	r24, 0xFF	; 255
    2ca4:	9f e3       	ldi	r25, 0x3F	; 63
    2ca6:	a2 e0       	ldi	r26, 0x02	; 2
    2ca8:	81 50       	subi	r24, 0x01	; 1
    2caa:	90 40       	sbci	r25, 0x00	; 0
    2cac:	a0 40       	sbci	r26, 0x00	; 0
    2cae:	e1 f7       	brne	.-8      	; 0x2ca8 <main+0x47a>
    2cb0:	00 c0       	rjmp	.+0      	; 0x2cb2 <main+0x484>
    2cb2:	00 00       	nop
		  _delay_ms(100);
		  UDR = 0x80;
    2cb4:	90 e8       	ldi	r25, 0x80	; 128
    2cb6:	9c b9       	out	0x0c, r25	; 12
    2cb8:	8f ef       	ldi	r24, 0xFF	; 255
    2cba:	9f e3       	ldi	r25, 0x3F	; 63
    2cbc:	a2 e0       	ldi	r26, 0x02	; 2
    2cbe:	81 50       	subi	r24, 0x01	; 1
    2cc0:	90 40       	sbci	r25, 0x00	; 0
    2cc2:	a0 40       	sbci	r26, 0x00	; 0
    2cc4:	e1 f7       	brne	.-8      	; 0x2cbe <main+0x490>
    2cc6:	00 c0       	rjmp	.+0      	; 0x2cc8 <main+0x49a>
    2cc8:	00 00       	nop
		  _delay_ms(100);
		  UDR = 0x80;
    2cca:	90 e8       	ldi	r25, 0x80	; 128
    2ccc:	9c b9       	out	0x0c, r25	; 12
		  home_bit[0] = 1;
    2cce:	d2 01       	movw	r26, r4
    2cd0:	11 96       	adiw	r26, 0x01	; 1
    2cd2:	fc 92       	st	X, r15
    2cd4:	ee 92       	st	-X, r14
		  while(all_bot_ready() == 0);
    2cd6:	0e 94 b7 12 	call	0x256e	; 0x256e <all_bot_ready>
    2cda:	00 97       	sbiw	r24, 0x00	; 0
    2cdc:	e1 f3       	breq	.-8      	; 0x2cd6 <main+0x4a8>
		  all_bot_clear();
    2cde:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <all_bot_clear>
    2ce2:	f1 cd       	rjmp	.-1054   	; 0x28c6 <main+0x98>
		  
	  }
  }
	   }
	  else if(cycle == 3)
    2ce4:	80 91 a0 00 	lds	r24, 0x00A0
    2ce8:	90 91 a1 00 	lds	r25, 0x00A1
    2cec:	83 30       	cpi	r24, 0x03	; 3
    2cee:	91 05       	cpc	r25, r1
    2cf0:	09 f0       	breq	.+2      	; 0x2cf4 <main+0x4c6>
    2cf2:	bb c0       	rjmp	.+374    	; 0x2e6a <main+0x63c>
	  {
		  if(event==0)
    2cf4:	80 91 9a 00 	lds	r24, 0x009A
    2cf8:	90 91 9b 00 	lds	r25, 0x009B
    2cfc:	00 97       	sbiw	r24, 0x00	; 0
    2cfe:	09 f0       	breq	.+2      	; 0x2d02 <main+0x4d4>
    2d00:	40 c0       	rjmp	.+128    	; 0x2d82 <main+0x554>
		  {
			  if(set_cover==0)
    2d02:	80 91 9c 00 	lds	r24, 0x009C
    2d06:	90 91 9d 00 	lds	r25, 0x009D
    2d0a:	00 97       	sbiw	r24, 0x00	; 0
    2d0c:	c9 f4       	brne	.+50     	; 0x2d40 <main+0x512>
			  {
				  if(right_plant_set2_count==0)line_follow_till_2(21);
    2d0e:	80 91 8e 00 	lds	r24, 0x008E
    2d12:	90 91 8f 00 	lds	r25, 0x008F
    2d16:	00 97       	sbiw	r24, 0x00	; 0
    2d18:	29 f4       	brne	.+10     	; 0x2d24 <main+0x4f6>
    2d1a:	85 e1       	ldi	r24, 0x15	; 21
    2d1c:	90 e0       	ldi	r25, 0x00	; 0
    2d1e:	0e 94 e5 08 	call	0x11ca	; 0x11ca <line_follow_till_2>
    2d22:	d1 cd       	rjmp	.-1118   	; 0x28c6 <main+0x98>
				  else
				  {
					  line_follow_till_2(right_plant_set2[array_index]);
    2d24:	80 91 8a 00 	lds	r24, 0x008A
    2d28:	90 91 8b 00 	lds	r25, 0x008B
    2d2c:	88 0f       	add	r24, r24
    2d2e:	99 1f       	adc	r25, r25
    2d30:	8a 0d       	add	r24, r10
    2d32:	9b 1d       	adc	r25, r11
    2d34:	fc 01       	movw	r30, r24
    2d36:	80 81       	ld	r24, Z
    2d38:	91 81       	ldd	r25, Z+1	; 0x01
    2d3a:	0e 94 e5 08 	call	0x11ca	; 0x11ca <line_follow_till_2>
    2d3e:	c3 cd       	rjmp	.-1146   	; 0x28c6 <main+0x98>
				  }
				  
			  }
			  else if(set_cover==50)
    2d40:	80 91 9c 00 	lds	r24, 0x009C
    2d44:	90 91 9d 00 	lds	r25, 0x009D
    2d48:	82 33       	cpi	r24, 0x32	; 50
    2d4a:	91 05       	cpc	r25, r1
    2d4c:	09 f0       	breq	.+2      	; 0x2d50 <main+0x522>
    2d4e:	bb cd       	rjmp	.-1162   	; 0x28c6 <main+0x98>
			  {
				  if(left_plant_set2_count==0)line_follow_till_2(27);
    2d50:	80 91 8c 00 	lds	r24, 0x008C
    2d54:	90 91 8d 00 	lds	r25, 0x008D
    2d58:	00 97       	sbiw	r24, 0x00	; 0
    2d5a:	29 f4       	brne	.+10     	; 0x2d66 <main+0x538>
    2d5c:	8b e1       	ldi	r24, 0x1B	; 27
    2d5e:	90 e0       	ldi	r25, 0x00	; 0
    2d60:	0e 94 e5 08 	call	0x11ca	; 0x11ca <line_follow_till_2>
    2d64:	b0 cd       	rjmp	.-1184   	; 0x28c6 <main+0x98>
				  else
				  {
					  line_follow_till_2(left_plant_set2[array_index]);
    2d66:	80 91 8a 00 	lds	r24, 0x008A
    2d6a:	90 91 8b 00 	lds	r25, 0x008B
    2d6e:	88 0f       	add	r24, r24
    2d70:	99 1f       	adc	r25, r25
    2d72:	82 0d       	add	r24, r2
    2d74:	93 1d       	adc	r25, r3
    2d76:	dc 01       	movw	r26, r24
    2d78:	8d 91       	ld	r24, X+
    2d7a:	9c 91       	ld	r25, X
    2d7c:	0e 94 e5 08 	call	0x11ca	; 0x11ca <line_follow_till_2>
    2d80:	a2 cd       	rjmp	.-1212   	; 0x28c6 <main+0x98>
				  }
			  }
		  }
		  else if(event==1)
    2d82:	80 91 9a 00 	lds	r24, 0x009A
    2d86:	90 91 9b 00 	lds	r25, 0x009B
    2d8a:	81 30       	cpi	r24, 0x01	; 1
    2d8c:	91 05       	cpc	r25, r1
    2d8e:	f1 f5       	brne	.+124    	; 0x2e0c <main+0x5de>
		  {
			  glow_blue();
    2d90:	0e 94 5c 11 	call	0x22b8	; 0x22b8 <glow_blue>
			  feedOut();
    2d94:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <feedOut>
			  rgb_off();
    2d98:	0e 94 61 11 	call	0x22c2	; 0x22c2 <rgb_off>
			  event=0;
    2d9c:	10 92 9b 00 	sts	0x009B, r1
    2da0:	10 92 9a 00 	sts	0x009A, r1
		      if(set_cover==0)                 {--right_plant_set2_count;  ++array_index; }
    2da4:	80 91 9c 00 	lds	r24, 0x009C
    2da8:	90 91 9d 00 	lds	r25, 0x009D
    2dac:	00 97       	sbiw	r24, 0x00	; 0
    2dae:	99 f4       	brne	.+38     	; 0x2dd6 <main+0x5a8>
    2db0:	80 91 8e 00 	lds	r24, 0x008E
    2db4:	90 91 8f 00 	lds	r25, 0x008F
    2db8:	01 97       	sbiw	r24, 0x01	; 1
    2dba:	90 93 8f 00 	sts	0x008F, r25
    2dbe:	80 93 8e 00 	sts	0x008E, r24
    2dc2:	80 91 8a 00 	lds	r24, 0x008A
    2dc6:	90 91 8b 00 	lds	r25, 0x008B
    2dca:	01 96       	adiw	r24, 0x01	; 1
    2dcc:	90 93 8b 00 	sts	0x008B, r25
    2dd0:	80 93 8a 00 	sts	0x008A, r24
    2dd4:	78 cd       	rjmp	.-1296   	; 0x28c6 <main+0x98>
	          else if(set_cover==50)           {--left_plant_set2_count;   ++array_index; }
    2dd6:	80 91 9c 00 	lds	r24, 0x009C
    2dda:	90 91 9d 00 	lds	r25, 0x009D
    2dde:	82 33       	cpi	r24, 0x32	; 50
    2de0:	91 05       	cpc	r25, r1
    2de2:	09 f0       	breq	.+2      	; 0x2de6 <main+0x5b8>
    2de4:	70 cd       	rjmp	.-1312   	; 0x28c6 <main+0x98>
    2de6:	80 91 8c 00 	lds	r24, 0x008C
    2dea:	90 91 8d 00 	lds	r25, 0x008D
    2dee:	01 97       	sbiw	r24, 0x01	; 1
    2df0:	90 93 8d 00 	sts	0x008D, r25
    2df4:	80 93 8c 00 	sts	0x008C, r24
    2df8:	80 91 8a 00 	lds	r24, 0x008A
    2dfc:	90 91 8b 00 	lds	r25, 0x008B
    2e00:	01 96       	adiw	r24, 0x01	; 1
    2e02:	90 93 8b 00 	sts	0x008B, r25
    2e06:	80 93 8a 00 	sts	0x008A, r24
    2e0a:	5d cd       	rjmp	.-1350   	; 0x28c6 <main+0x98>
          }
  else if(event==2)
    2e0c:	80 91 9a 00 	lds	r24, 0x009A
    2e10:	90 91 9b 00 	lds	r25, 0x009B
    2e14:	82 30       	cpi	r24, 0x02	; 2
    2e16:	91 05       	cpc	r25, r1
    2e18:	09 f0       	breq	.+2      	; 0x2e1c <main+0x5ee>
    2e1a:	55 cd       	rjmp	.-1366   	; 0x28c6 <main+0x98>
  {
	  if(all_bot_ready()==1)
    2e1c:	0e 94 b7 12 	call	0x256e	; 0x256e <all_bot_ready>
    2e20:	81 30       	cpi	r24, 0x01	; 1
    2e22:	91 05       	cpc	r25, r1
    2e24:	09 f0       	breq	.+2      	; 0x2e28 <main+0x5fa>
    2e26:	4f cd       	rjmp	.-1378   	; 0x28c6 <main+0x98>
	  {
		  all_bot_clear();
    2e28:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <all_bot_clear>
		  ++set;
    2e2c:	80 91 9e 00 	lds	r24, 0x009E
    2e30:	90 91 9f 00 	lds	r25, 0x009F
    2e34:	01 96       	adiw	r24, 0x01	; 1
    2e36:	90 93 9f 00 	sts	0x009F, r25
    2e3a:	80 93 9e 00 	sts	0x009E, r24
		  set_cover=0;
    2e3e:	10 92 9d 00 	sts	0x009D, r1
    2e42:	10 92 9c 00 	sts	0x009C, r1
		  array_index=0;
    2e46:	10 92 8b 00 	sts	0x008B, r1
    2e4a:	10 92 8a 00 	sts	0x008A, r1
		  event=0;
    2e4e:	10 92 9b 00 	sts	0x009B, r1
    2e52:	10 92 9a 00 	sts	0x009A, r1
		  ++cycle;
    2e56:	80 91 a0 00 	lds	r24, 0x00A0
    2e5a:	90 91 a1 00 	lds	r25, 0x00A1
    2e5e:	01 96       	adiw	r24, 0x01	; 1
    2e60:	90 93 a1 00 	sts	0x00A1, r25
    2e64:	80 93 a0 00 	sts	0x00A0, r24
    2e68:	2e cd       	rjmp	.-1444   	; 0x28c6 <main+0x98>
	  }
  }
	   }
	   else if(cycle==4)   // final home run begins
    2e6a:	80 91 a0 00 	lds	r24, 0x00A0
    2e6e:	90 91 a1 00 	lds	r25, 0x00A1
    2e72:	84 30       	cpi	r24, 0x04	; 4
    2e74:	91 05       	cpc	r25, r1
    2e76:	61 f4       	brne	.+24     	; 0x2e90 <main+0x662>
	   {
		   final_home_run();
    2e78:	0e 94 a8 04 	call	0x950	; 0x950 <final_home_run>
		   ++cycle;
    2e7c:	80 91 a0 00 	lds	r24, 0x00A0
    2e80:	90 91 a1 00 	lds	r25, 0x00A1
    2e84:	01 96       	adiw	r24, 0x01	; 1
    2e86:	90 93 a1 00 	sts	0x00A1, r25
    2e8a:	80 93 a0 00 	sts	0x00A0, r24
    2e8e:	1b cd       	rjmp	.-1482   	; 0x28c6 <main+0x98>
	   }
	   else if(cycle==5)  // come out of event loop
    2e90:	80 91 a0 00 	lds	r24, 0x00A0
    2e94:	90 91 a1 00 	lds	r25, 0x00A1
    2e98:	85 30       	cpi	r24, 0x05	; 5
    2e9a:	91 05       	cpc	r25, r1
    2e9c:	09 f0       	breq	.+2      	; 0x2ea0 <main+0x672>
    2e9e:	13 cd       	rjmp	.-1498   	; 0x28c6 <main+0x98>
	   {
		   buzzer_on();
    2ea0:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <buzzer_on>
    2ea4:	8f ef       	ldi	r24, 0xFF	; 255
    2ea6:	9f ef       	ldi	r25, 0xFF	; 255
    2ea8:	a6 e8       	ldi	r26, 0x86	; 134
    2eaa:	81 50       	subi	r24, 0x01	; 1
    2eac:	90 40       	sbci	r25, 0x00	; 0
    2eae:	a0 40       	sbci	r26, 0x00	; 0
    2eb0:	e1 f7       	brne	.-8      	; 0x2eaa <main+0x67c>
    2eb2:	00 c0       	rjmp	.+0      	; 0x2eb4 <main+0x686>
    2eb4:	00 00       	nop
		   _delay_ms(6000);
		    buzzer_off();
    2eb6:	0e 94 fe 01 	call	0x3fc	; 0x3fc <buzzer_off>
		   break;
	   }
  }	
    2eba:	df 91       	pop	r29
    2ebc:	cf 91       	pop	r28
    2ebe:	1f 91       	pop	r17
    2ec0:	0f 91       	pop	r16
    2ec2:	ff 90       	pop	r15
    2ec4:	ef 90       	pop	r14
    2ec6:	df 90       	pop	r13
    2ec8:	cf 90       	pop	r12
    2eca:	bf 90       	pop	r11
    2ecc:	af 90       	pop	r10
    2ece:	9f 90       	pop	r9
    2ed0:	8f 90       	pop	r8
    2ed2:	7f 90       	pop	r7
    2ed4:	6f 90       	pop	r6
    2ed6:	5f 90       	pop	r5
    2ed8:	4f 90       	pop	r4
    2eda:	3f 90       	pop	r3
    2edc:	2f 90       	pop	r2
    2ede:	08 95       	ret

00002ee0 <__subsf3>:
    2ee0:	50 58       	subi	r21, 0x80	; 128

00002ee2 <__addsf3>:
    2ee2:	bb 27       	eor	r27, r27
    2ee4:	aa 27       	eor	r26, r26
    2ee6:	0e d0       	rcall	.+28     	; 0x2f04 <__addsf3x>
    2ee8:	4d c1       	rjmp	.+666    	; 0x3184 <__fp_round>
    2eea:	3e d1       	rcall	.+636    	; 0x3168 <__fp_pscA>
    2eec:	30 f0       	brcs	.+12     	; 0x2efa <__addsf3+0x18>
    2eee:	43 d1       	rcall	.+646    	; 0x3176 <__fp_pscB>
    2ef0:	20 f0       	brcs	.+8      	; 0x2efa <__addsf3+0x18>
    2ef2:	31 f4       	brne	.+12     	; 0x2f00 <__addsf3+0x1e>
    2ef4:	9f 3f       	cpi	r25, 0xFF	; 255
    2ef6:	11 f4       	brne	.+4      	; 0x2efc <__addsf3+0x1a>
    2ef8:	1e f4       	brtc	.+6      	; 0x2f00 <__addsf3+0x1e>
    2efa:	33 c1       	rjmp	.+614    	; 0x3162 <__fp_nan>
    2efc:	0e f4       	brtc	.+2      	; 0x2f00 <__addsf3+0x1e>
    2efe:	e0 95       	com	r30
    2f00:	e7 fb       	bst	r30, 7
    2f02:	29 c1       	rjmp	.+594    	; 0x3156 <__fp_inf>

00002f04 <__addsf3x>:
    2f04:	e9 2f       	mov	r30, r25
    2f06:	4f d1       	rcall	.+670    	; 0x31a6 <__fp_split3>
    2f08:	80 f3       	brcs	.-32     	; 0x2eea <__addsf3+0x8>
    2f0a:	ba 17       	cp	r27, r26
    2f0c:	62 07       	cpc	r22, r18
    2f0e:	73 07       	cpc	r23, r19
    2f10:	84 07       	cpc	r24, r20
    2f12:	95 07       	cpc	r25, r21
    2f14:	18 f0       	brcs	.+6      	; 0x2f1c <__addsf3x+0x18>
    2f16:	71 f4       	brne	.+28     	; 0x2f34 <__addsf3x+0x30>
    2f18:	9e f5       	brtc	.+102    	; 0x2f80 <__addsf3x+0x7c>
    2f1a:	67 c1       	rjmp	.+718    	; 0x31ea <__fp_zero>
    2f1c:	0e f4       	brtc	.+2      	; 0x2f20 <__addsf3x+0x1c>
    2f1e:	e0 95       	com	r30
    2f20:	0b 2e       	mov	r0, r27
    2f22:	ba 2f       	mov	r27, r26
    2f24:	a0 2d       	mov	r26, r0
    2f26:	0b 01       	movw	r0, r22
    2f28:	b9 01       	movw	r22, r18
    2f2a:	90 01       	movw	r18, r0
    2f2c:	0c 01       	movw	r0, r24
    2f2e:	ca 01       	movw	r24, r20
    2f30:	a0 01       	movw	r20, r0
    2f32:	11 24       	eor	r1, r1
    2f34:	ff 27       	eor	r31, r31
    2f36:	59 1b       	sub	r21, r25
    2f38:	99 f0       	breq	.+38     	; 0x2f60 <__addsf3x+0x5c>
    2f3a:	59 3f       	cpi	r21, 0xF9	; 249
    2f3c:	50 f4       	brcc	.+20     	; 0x2f52 <__addsf3x+0x4e>
    2f3e:	50 3e       	cpi	r21, 0xE0	; 224
    2f40:	68 f1       	brcs	.+90     	; 0x2f9c <__addsf3x+0x98>
    2f42:	1a 16       	cp	r1, r26
    2f44:	f0 40       	sbci	r31, 0x00	; 0
    2f46:	a2 2f       	mov	r26, r18
    2f48:	23 2f       	mov	r18, r19
    2f4a:	34 2f       	mov	r19, r20
    2f4c:	44 27       	eor	r20, r20
    2f4e:	58 5f       	subi	r21, 0xF8	; 248
    2f50:	f3 cf       	rjmp	.-26     	; 0x2f38 <__addsf3x+0x34>
    2f52:	46 95       	lsr	r20
    2f54:	37 95       	ror	r19
    2f56:	27 95       	ror	r18
    2f58:	a7 95       	ror	r26
    2f5a:	f0 40       	sbci	r31, 0x00	; 0
    2f5c:	53 95       	inc	r21
    2f5e:	c9 f7       	brne	.-14     	; 0x2f52 <__addsf3x+0x4e>
    2f60:	7e f4       	brtc	.+30     	; 0x2f80 <__addsf3x+0x7c>
    2f62:	1f 16       	cp	r1, r31
    2f64:	ba 0b       	sbc	r27, r26
    2f66:	62 0b       	sbc	r22, r18
    2f68:	73 0b       	sbc	r23, r19
    2f6a:	84 0b       	sbc	r24, r20
    2f6c:	ba f0       	brmi	.+46     	; 0x2f9c <__addsf3x+0x98>
    2f6e:	91 50       	subi	r25, 0x01	; 1
    2f70:	a1 f0       	breq	.+40     	; 0x2f9a <__addsf3x+0x96>
    2f72:	ff 0f       	add	r31, r31
    2f74:	bb 1f       	adc	r27, r27
    2f76:	66 1f       	adc	r22, r22
    2f78:	77 1f       	adc	r23, r23
    2f7a:	88 1f       	adc	r24, r24
    2f7c:	c2 f7       	brpl	.-16     	; 0x2f6e <__addsf3x+0x6a>
    2f7e:	0e c0       	rjmp	.+28     	; 0x2f9c <__addsf3x+0x98>
    2f80:	ba 0f       	add	r27, r26
    2f82:	62 1f       	adc	r22, r18
    2f84:	73 1f       	adc	r23, r19
    2f86:	84 1f       	adc	r24, r20
    2f88:	48 f4       	brcc	.+18     	; 0x2f9c <__addsf3x+0x98>
    2f8a:	87 95       	ror	r24
    2f8c:	77 95       	ror	r23
    2f8e:	67 95       	ror	r22
    2f90:	b7 95       	ror	r27
    2f92:	f7 95       	ror	r31
    2f94:	9e 3f       	cpi	r25, 0xFE	; 254
    2f96:	08 f0       	brcs	.+2      	; 0x2f9a <__addsf3x+0x96>
    2f98:	b3 cf       	rjmp	.-154    	; 0x2f00 <__addsf3+0x1e>
    2f9a:	93 95       	inc	r25
    2f9c:	88 0f       	add	r24, r24
    2f9e:	08 f0       	brcs	.+2      	; 0x2fa2 <__addsf3x+0x9e>
    2fa0:	99 27       	eor	r25, r25
    2fa2:	ee 0f       	add	r30, r30
    2fa4:	97 95       	ror	r25
    2fa6:	87 95       	ror	r24
    2fa8:	08 95       	ret

00002faa <__divsf3>:
    2faa:	0c d0       	rcall	.+24     	; 0x2fc4 <__divsf3x>
    2fac:	eb c0       	rjmp	.+470    	; 0x3184 <__fp_round>
    2fae:	e3 d0       	rcall	.+454    	; 0x3176 <__fp_pscB>
    2fb0:	40 f0       	brcs	.+16     	; 0x2fc2 <__divsf3+0x18>
    2fb2:	da d0       	rcall	.+436    	; 0x3168 <__fp_pscA>
    2fb4:	30 f0       	brcs	.+12     	; 0x2fc2 <__divsf3+0x18>
    2fb6:	21 f4       	brne	.+8      	; 0x2fc0 <__divsf3+0x16>
    2fb8:	5f 3f       	cpi	r21, 0xFF	; 255
    2fba:	19 f0       	breq	.+6      	; 0x2fc2 <__divsf3+0x18>
    2fbc:	cc c0       	rjmp	.+408    	; 0x3156 <__fp_inf>
    2fbe:	51 11       	cpse	r21, r1
    2fc0:	15 c1       	rjmp	.+554    	; 0x31ec <__fp_szero>
    2fc2:	cf c0       	rjmp	.+414    	; 0x3162 <__fp_nan>

00002fc4 <__divsf3x>:
    2fc4:	f0 d0       	rcall	.+480    	; 0x31a6 <__fp_split3>
    2fc6:	98 f3       	brcs	.-26     	; 0x2fae <__divsf3+0x4>

00002fc8 <__divsf3_pse>:
    2fc8:	99 23       	and	r25, r25
    2fca:	c9 f3       	breq	.-14     	; 0x2fbe <__divsf3+0x14>
    2fcc:	55 23       	and	r21, r21
    2fce:	b1 f3       	breq	.-20     	; 0x2fbc <__divsf3+0x12>
    2fd0:	95 1b       	sub	r25, r21
    2fd2:	55 0b       	sbc	r21, r21
    2fd4:	bb 27       	eor	r27, r27
    2fd6:	aa 27       	eor	r26, r26
    2fd8:	62 17       	cp	r22, r18
    2fda:	73 07       	cpc	r23, r19
    2fdc:	84 07       	cpc	r24, r20
    2fde:	38 f0       	brcs	.+14     	; 0x2fee <__divsf3_pse+0x26>
    2fe0:	9f 5f       	subi	r25, 0xFF	; 255
    2fe2:	5f 4f       	sbci	r21, 0xFF	; 255
    2fe4:	22 0f       	add	r18, r18
    2fe6:	33 1f       	adc	r19, r19
    2fe8:	44 1f       	adc	r20, r20
    2fea:	aa 1f       	adc	r26, r26
    2fec:	a9 f3       	breq	.-22     	; 0x2fd8 <__divsf3_pse+0x10>
    2fee:	33 d0       	rcall	.+102    	; 0x3056 <__divsf3_pse+0x8e>
    2ff0:	0e 2e       	mov	r0, r30
    2ff2:	3a f0       	brmi	.+14     	; 0x3002 <__divsf3_pse+0x3a>
    2ff4:	e0 e8       	ldi	r30, 0x80	; 128
    2ff6:	30 d0       	rcall	.+96     	; 0x3058 <__divsf3_pse+0x90>
    2ff8:	91 50       	subi	r25, 0x01	; 1
    2ffa:	50 40       	sbci	r21, 0x00	; 0
    2ffc:	e6 95       	lsr	r30
    2ffe:	00 1c       	adc	r0, r0
    3000:	ca f7       	brpl	.-14     	; 0x2ff4 <__divsf3_pse+0x2c>
    3002:	29 d0       	rcall	.+82     	; 0x3056 <__divsf3_pse+0x8e>
    3004:	fe 2f       	mov	r31, r30
    3006:	27 d0       	rcall	.+78     	; 0x3056 <__divsf3_pse+0x8e>
    3008:	66 0f       	add	r22, r22
    300a:	77 1f       	adc	r23, r23
    300c:	88 1f       	adc	r24, r24
    300e:	bb 1f       	adc	r27, r27
    3010:	26 17       	cp	r18, r22
    3012:	37 07       	cpc	r19, r23
    3014:	48 07       	cpc	r20, r24
    3016:	ab 07       	cpc	r26, r27
    3018:	b0 e8       	ldi	r27, 0x80	; 128
    301a:	09 f0       	breq	.+2      	; 0x301e <__divsf3_pse+0x56>
    301c:	bb 0b       	sbc	r27, r27
    301e:	80 2d       	mov	r24, r0
    3020:	bf 01       	movw	r22, r30
    3022:	ff 27       	eor	r31, r31
    3024:	93 58       	subi	r25, 0x83	; 131
    3026:	5f 4f       	sbci	r21, 0xFF	; 255
    3028:	2a f0       	brmi	.+10     	; 0x3034 <__divsf3_pse+0x6c>
    302a:	9e 3f       	cpi	r25, 0xFE	; 254
    302c:	51 05       	cpc	r21, r1
    302e:	68 f0       	brcs	.+26     	; 0x304a <__divsf3_pse+0x82>
    3030:	92 c0       	rjmp	.+292    	; 0x3156 <__fp_inf>
    3032:	dc c0       	rjmp	.+440    	; 0x31ec <__fp_szero>
    3034:	5f 3f       	cpi	r21, 0xFF	; 255
    3036:	ec f3       	brlt	.-6      	; 0x3032 <__divsf3_pse+0x6a>
    3038:	98 3e       	cpi	r25, 0xE8	; 232
    303a:	dc f3       	brlt	.-10     	; 0x3032 <__divsf3_pse+0x6a>
    303c:	86 95       	lsr	r24
    303e:	77 95       	ror	r23
    3040:	67 95       	ror	r22
    3042:	b7 95       	ror	r27
    3044:	f7 95       	ror	r31
    3046:	9f 5f       	subi	r25, 0xFF	; 255
    3048:	c9 f7       	brne	.-14     	; 0x303c <__divsf3_pse+0x74>
    304a:	88 0f       	add	r24, r24
    304c:	91 1d       	adc	r25, r1
    304e:	96 95       	lsr	r25
    3050:	87 95       	ror	r24
    3052:	97 f9       	bld	r25, 7
    3054:	08 95       	ret
    3056:	e1 e0       	ldi	r30, 0x01	; 1
    3058:	66 0f       	add	r22, r22
    305a:	77 1f       	adc	r23, r23
    305c:	88 1f       	adc	r24, r24
    305e:	bb 1f       	adc	r27, r27
    3060:	62 17       	cp	r22, r18
    3062:	73 07       	cpc	r23, r19
    3064:	84 07       	cpc	r24, r20
    3066:	ba 07       	cpc	r27, r26
    3068:	20 f0       	brcs	.+8      	; 0x3072 <__divsf3_pse+0xaa>
    306a:	62 1b       	sub	r22, r18
    306c:	73 0b       	sbc	r23, r19
    306e:	84 0b       	sbc	r24, r20
    3070:	ba 0b       	sbc	r27, r26
    3072:	ee 1f       	adc	r30, r30
    3074:	88 f7       	brcc	.-30     	; 0x3058 <__divsf3_pse+0x90>
    3076:	e0 95       	com	r30
    3078:	08 95       	ret

0000307a <__fixsfsi>:
    307a:	04 d0       	rcall	.+8      	; 0x3084 <__fixunssfsi>
    307c:	68 94       	set
    307e:	b1 11       	cpse	r27, r1
    3080:	b5 c0       	rjmp	.+362    	; 0x31ec <__fp_szero>
    3082:	08 95       	ret

00003084 <__fixunssfsi>:
    3084:	98 d0       	rcall	.+304    	; 0x31b6 <__fp_splitA>
    3086:	88 f0       	brcs	.+34     	; 0x30aa <__fixunssfsi+0x26>
    3088:	9f 57       	subi	r25, 0x7F	; 127
    308a:	90 f0       	brcs	.+36     	; 0x30b0 <__fixunssfsi+0x2c>
    308c:	b9 2f       	mov	r27, r25
    308e:	99 27       	eor	r25, r25
    3090:	b7 51       	subi	r27, 0x17	; 23
    3092:	a0 f0       	brcs	.+40     	; 0x30bc <__fixunssfsi+0x38>
    3094:	d1 f0       	breq	.+52     	; 0x30ca <__fixunssfsi+0x46>
    3096:	66 0f       	add	r22, r22
    3098:	77 1f       	adc	r23, r23
    309a:	88 1f       	adc	r24, r24
    309c:	99 1f       	adc	r25, r25
    309e:	1a f0       	brmi	.+6      	; 0x30a6 <__fixunssfsi+0x22>
    30a0:	ba 95       	dec	r27
    30a2:	c9 f7       	brne	.-14     	; 0x3096 <__fixunssfsi+0x12>
    30a4:	12 c0       	rjmp	.+36     	; 0x30ca <__fixunssfsi+0x46>
    30a6:	b1 30       	cpi	r27, 0x01	; 1
    30a8:	81 f0       	breq	.+32     	; 0x30ca <__fixunssfsi+0x46>
    30aa:	9f d0       	rcall	.+318    	; 0x31ea <__fp_zero>
    30ac:	b1 e0       	ldi	r27, 0x01	; 1
    30ae:	08 95       	ret
    30b0:	9c c0       	rjmp	.+312    	; 0x31ea <__fp_zero>
    30b2:	67 2f       	mov	r22, r23
    30b4:	78 2f       	mov	r23, r24
    30b6:	88 27       	eor	r24, r24
    30b8:	b8 5f       	subi	r27, 0xF8	; 248
    30ba:	39 f0       	breq	.+14     	; 0x30ca <__fixunssfsi+0x46>
    30bc:	b9 3f       	cpi	r27, 0xF9	; 249
    30be:	cc f3       	brlt	.-14     	; 0x30b2 <__fixunssfsi+0x2e>
    30c0:	86 95       	lsr	r24
    30c2:	77 95       	ror	r23
    30c4:	67 95       	ror	r22
    30c6:	b3 95       	inc	r27
    30c8:	d9 f7       	brne	.-10     	; 0x30c0 <__fixunssfsi+0x3c>
    30ca:	3e f4       	brtc	.+14     	; 0x30da <__fixunssfsi+0x56>
    30cc:	90 95       	com	r25
    30ce:	80 95       	com	r24
    30d0:	70 95       	com	r23
    30d2:	61 95       	neg	r22
    30d4:	7f 4f       	sbci	r23, 0xFF	; 255
    30d6:	8f 4f       	sbci	r24, 0xFF	; 255
    30d8:	9f 4f       	sbci	r25, 0xFF	; 255
    30da:	08 95       	ret

000030dc <__floatunsisf>:
    30dc:	e8 94       	clt
    30de:	09 c0       	rjmp	.+18     	; 0x30f2 <__floatsisf+0x12>

000030e0 <__floatsisf>:
    30e0:	97 fb       	bst	r25, 7
    30e2:	3e f4       	brtc	.+14     	; 0x30f2 <__floatsisf+0x12>
    30e4:	90 95       	com	r25
    30e6:	80 95       	com	r24
    30e8:	70 95       	com	r23
    30ea:	61 95       	neg	r22
    30ec:	7f 4f       	sbci	r23, 0xFF	; 255
    30ee:	8f 4f       	sbci	r24, 0xFF	; 255
    30f0:	9f 4f       	sbci	r25, 0xFF	; 255
    30f2:	99 23       	and	r25, r25
    30f4:	a9 f0       	breq	.+42     	; 0x3120 <__floatsisf+0x40>
    30f6:	f9 2f       	mov	r31, r25
    30f8:	96 e9       	ldi	r25, 0x96	; 150
    30fa:	bb 27       	eor	r27, r27
    30fc:	93 95       	inc	r25
    30fe:	f6 95       	lsr	r31
    3100:	87 95       	ror	r24
    3102:	77 95       	ror	r23
    3104:	67 95       	ror	r22
    3106:	b7 95       	ror	r27
    3108:	f1 11       	cpse	r31, r1
    310a:	f8 cf       	rjmp	.-16     	; 0x30fc <__floatsisf+0x1c>
    310c:	fa f4       	brpl	.+62     	; 0x314c <__floatsisf+0x6c>
    310e:	bb 0f       	add	r27, r27
    3110:	11 f4       	brne	.+4      	; 0x3116 <__floatsisf+0x36>
    3112:	60 ff       	sbrs	r22, 0
    3114:	1b c0       	rjmp	.+54     	; 0x314c <__floatsisf+0x6c>
    3116:	6f 5f       	subi	r22, 0xFF	; 255
    3118:	7f 4f       	sbci	r23, 0xFF	; 255
    311a:	8f 4f       	sbci	r24, 0xFF	; 255
    311c:	9f 4f       	sbci	r25, 0xFF	; 255
    311e:	16 c0       	rjmp	.+44     	; 0x314c <__floatsisf+0x6c>
    3120:	88 23       	and	r24, r24
    3122:	11 f0       	breq	.+4      	; 0x3128 <__floatsisf+0x48>
    3124:	96 e9       	ldi	r25, 0x96	; 150
    3126:	11 c0       	rjmp	.+34     	; 0x314a <__floatsisf+0x6a>
    3128:	77 23       	and	r23, r23
    312a:	21 f0       	breq	.+8      	; 0x3134 <__floatsisf+0x54>
    312c:	9e e8       	ldi	r25, 0x8E	; 142
    312e:	87 2f       	mov	r24, r23
    3130:	76 2f       	mov	r23, r22
    3132:	05 c0       	rjmp	.+10     	; 0x313e <__floatsisf+0x5e>
    3134:	66 23       	and	r22, r22
    3136:	71 f0       	breq	.+28     	; 0x3154 <__floatsisf+0x74>
    3138:	96 e8       	ldi	r25, 0x86	; 134
    313a:	86 2f       	mov	r24, r22
    313c:	70 e0       	ldi	r23, 0x00	; 0
    313e:	60 e0       	ldi	r22, 0x00	; 0
    3140:	2a f0       	brmi	.+10     	; 0x314c <__floatsisf+0x6c>
    3142:	9a 95       	dec	r25
    3144:	66 0f       	add	r22, r22
    3146:	77 1f       	adc	r23, r23
    3148:	88 1f       	adc	r24, r24
    314a:	da f7       	brpl	.-10     	; 0x3142 <__floatsisf+0x62>
    314c:	88 0f       	add	r24, r24
    314e:	96 95       	lsr	r25
    3150:	87 95       	ror	r24
    3152:	97 f9       	bld	r25, 7
    3154:	08 95       	ret

00003156 <__fp_inf>:
    3156:	97 f9       	bld	r25, 7
    3158:	9f 67       	ori	r25, 0x7F	; 127
    315a:	80 e8       	ldi	r24, 0x80	; 128
    315c:	70 e0       	ldi	r23, 0x00	; 0
    315e:	60 e0       	ldi	r22, 0x00	; 0
    3160:	08 95       	ret

00003162 <__fp_nan>:
    3162:	9f ef       	ldi	r25, 0xFF	; 255
    3164:	80 ec       	ldi	r24, 0xC0	; 192
    3166:	08 95       	ret

00003168 <__fp_pscA>:
    3168:	00 24       	eor	r0, r0
    316a:	0a 94       	dec	r0
    316c:	16 16       	cp	r1, r22
    316e:	17 06       	cpc	r1, r23
    3170:	18 06       	cpc	r1, r24
    3172:	09 06       	cpc	r0, r25
    3174:	08 95       	ret

00003176 <__fp_pscB>:
    3176:	00 24       	eor	r0, r0
    3178:	0a 94       	dec	r0
    317a:	12 16       	cp	r1, r18
    317c:	13 06       	cpc	r1, r19
    317e:	14 06       	cpc	r1, r20
    3180:	05 06       	cpc	r0, r21
    3182:	08 95       	ret

00003184 <__fp_round>:
    3184:	09 2e       	mov	r0, r25
    3186:	03 94       	inc	r0
    3188:	00 0c       	add	r0, r0
    318a:	11 f4       	brne	.+4      	; 0x3190 <__fp_round+0xc>
    318c:	88 23       	and	r24, r24
    318e:	52 f0       	brmi	.+20     	; 0x31a4 <__fp_round+0x20>
    3190:	bb 0f       	add	r27, r27
    3192:	40 f4       	brcc	.+16     	; 0x31a4 <__fp_round+0x20>
    3194:	bf 2b       	or	r27, r31
    3196:	11 f4       	brne	.+4      	; 0x319c <__fp_round+0x18>
    3198:	60 ff       	sbrs	r22, 0
    319a:	04 c0       	rjmp	.+8      	; 0x31a4 <__fp_round+0x20>
    319c:	6f 5f       	subi	r22, 0xFF	; 255
    319e:	7f 4f       	sbci	r23, 0xFF	; 255
    31a0:	8f 4f       	sbci	r24, 0xFF	; 255
    31a2:	9f 4f       	sbci	r25, 0xFF	; 255
    31a4:	08 95       	ret

000031a6 <__fp_split3>:
    31a6:	57 fd       	sbrc	r21, 7
    31a8:	90 58       	subi	r25, 0x80	; 128
    31aa:	44 0f       	add	r20, r20
    31ac:	55 1f       	adc	r21, r21
    31ae:	59 f0       	breq	.+22     	; 0x31c6 <__fp_splitA+0x10>
    31b0:	5f 3f       	cpi	r21, 0xFF	; 255
    31b2:	71 f0       	breq	.+28     	; 0x31d0 <__fp_splitA+0x1a>
    31b4:	47 95       	ror	r20

000031b6 <__fp_splitA>:
    31b6:	88 0f       	add	r24, r24
    31b8:	97 fb       	bst	r25, 7
    31ba:	99 1f       	adc	r25, r25
    31bc:	61 f0       	breq	.+24     	; 0x31d6 <__fp_splitA+0x20>
    31be:	9f 3f       	cpi	r25, 0xFF	; 255
    31c0:	79 f0       	breq	.+30     	; 0x31e0 <__fp_splitA+0x2a>
    31c2:	87 95       	ror	r24
    31c4:	08 95       	ret
    31c6:	12 16       	cp	r1, r18
    31c8:	13 06       	cpc	r1, r19
    31ca:	14 06       	cpc	r1, r20
    31cc:	55 1f       	adc	r21, r21
    31ce:	f2 cf       	rjmp	.-28     	; 0x31b4 <__fp_split3+0xe>
    31d0:	46 95       	lsr	r20
    31d2:	f1 df       	rcall	.-30     	; 0x31b6 <__fp_splitA>
    31d4:	08 c0       	rjmp	.+16     	; 0x31e6 <__fp_splitA+0x30>
    31d6:	16 16       	cp	r1, r22
    31d8:	17 06       	cpc	r1, r23
    31da:	18 06       	cpc	r1, r24
    31dc:	99 1f       	adc	r25, r25
    31de:	f1 cf       	rjmp	.-30     	; 0x31c2 <__fp_splitA+0xc>
    31e0:	86 95       	lsr	r24
    31e2:	71 05       	cpc	r23, r1
    31e4:	61 05       	cpc	r22, r1
    31e6:	08 94       	sec
    31e8:	08 95       	ret

000031ea <__fp_zero>:
    31ea:	e8 94       	clt

000031ec <__fp_szero>:
    31ec:	bb 27       	eor	r27, r27
    31ee:	66 27       	eor	r22, r22
    31f0:	77 27       	eor	r23, r23
    31f2:	cb 01       	movw	r24, r22
    31f4:	97 f9       	bld	r25, 7
    31f6:	08 95       	ret

000031f8 <__mulsf3>:
    31f8:	0b d0       	rcall	.+22     	; 0x3210 <__mulsf3x>
    31fa:	c4 cf       	rjmp	.-120    	; 0x3184 <__fp_round>
    31fc:	b5 df       	rcall	.-150    	; 0x3168 <__fp_pscA>
    31fe:	28 f0       	brcs	.+10     	; 0x320a <__mulsf3+0x12>
    3200:	ba df       	rcall	.-140    	; 0x3176 <__fp_pscB>
    3202:	18 f0       	brcs	.+6      	; 0x320a <__mulsf3+0x12>
    3204:	95 23       	and	r25, r21
    3206:	09 f0       	breq	.+2      	; 0x320a <__mulsf3+0x12>
    3208:	a6 cf       	rjmp	.-180    	; 0x3156 <__fp_inf>
    320a:	ab cf       	rjmp	.-170    	; 0x3162 <__fp_nan>
    320c:	11 24       	eor	r1, r1
    320e:	ee cf       	rjmp	.-36     	; 0x31ec <__fp_szero>

00003210 <__mulsf3x>:
    3210:	ca df       	rcall	.-108    	; 0x31a6 <__fp_split3>
    3212:	a0 f3       	brcs	.-24     	; 0x31fc <__mulsf3+0x4>

00003214 <__mulsf3_pse>:
    3214:	95 9f       	mul	r25, r21
    3216:	d1 f3       	breq	.-12     	; 0x320c <__mulsf3+0x14>
    3218:	95 0f       	add	r25, r21
    321a:	50 e0       	ldi	r21, 0x00	; 0
    321c:	55 1f       	adc	r21, r21
    321e:	62 9f       	mul	r22, r18
    3220:	f0 01       	movw	r30, r0
    3222:	72 9f       	mul	r23, r18
    3224:	bb 27       	eor	r27, r27
    3226:	f0 0d       	add	r31, r0
    3228:	b1 1d       	adc	r27, r1
    322a:	63 9f       	mul	r22, r19
    322c:	aa 27       	eor	r26, r26
    322e:	f0 0d       	add	r31, r0
    3230:	b1 1d       	adc	r27, r1
    3232:	aa 1f       	adc	r26, r26
    3234:	64 9f       	mul	r22, r20
    3236:	66 27       	eor	r22, r22
    3238:	b0 0d       	add	r27, r0
    323a:	a1 1d       	adc	r26, r1
    323c:	66 1f       	adc	r22, r22
    323e:	82 9f       	mul	r24, r18
    3240:	22 27       	eor	r18, r18
    3242:	b0 0d       	add	r27, r0
    3244:	a1 1d       	adc	r26, r1
    3246:	62 1f       	adc	r22, r18
    3248:	73 9f       	mul	r23, r19
    324a:	b0 0d       	add	r27, r0
    324c:	a1 1d       	adc	r26, r1
    324e:	62 1f       	adc	r22, r18
    3250:	83 9f       	mul	r24, r19
    3252:	a0 0d       	add	r26, r0
    3254:	61 1d       	adc	r22, r1
    3256:	22 1f       	adc	r18, r18
    3258:	74 9f       	mul	r23, r20
    325a:	33 27       	eor	r19, r19
    325c:	a0 0d       	add	r26, r0
    325e:	61 1d       	adc	r22, r1
    3260:	23 1f       	adc	r18, r19
    3262:	84 9f       	mul	r24, r20
    3264:	60 0d       	add	r22, r0
    3266:	21 1d       	adc	r18, r1
    3268:	82 2f       	mov	r24, r18
    326a:	76 2f       	mov	r23, r22
    326c:	6a 2f       	mov	r22, r26
    326e:	11 24       	eor	r1, r1
    3270:	9f 57       	subi	r25, 0x7F	; 127
    3272:	50 40       	sbci	r21, 0x00	; 0
    3274:	8a f0       	brmi	.+34     	; 0x3298 <__mulsf3_pse+0x84>
    3276:	e1 f0       	breq	.+56     	; 0x32b0 <__mulsf3_pse+0x9c>
    3278:	88 23       	and	r24, r24
    327a:	4a f0       	brmi	.+18     	; 0x328e <__mulsf3_pse+0x7a>
    327c:	ee 0f       	add	r30, r30
    327e:	ff 1f       	adc	r31, r31
    3280:	bb 1f       	adc	r27, r27
    3282:	66 1f       	adc	r22, r22
    3284:	77 1f       	adc	r23, r23
    3286:	88 1f       	adc	r24, r24
    3288:	91 50       	subi	r25, 0x01	; 1
    328a:	50 40       	sbci	r21, 0x00	; 0
    328c:	a9 f7       	brne	.-22     	; 0x3278 <__mulsf3_pse+0x64>
    328e:	9e 3f       	cpi	r25, 0xFE	; 254
    3290:	51 05       	cpc	r21, r1
    3292:	70 f0       	brcs	.+28     	; 0x32b0 <__mulsf3_pse+0x9c>
    3294:	60 cf       	rjmp	.-320    	; 0x3156 <__fp_inf>
    3296:	aa cf       	rjmp	.-172    	; 0x31ec <__fp_szero>
    3298:	5f 3f       	cpi	r21, 0xFF	; 255
    329a:	ec f3       	brlt	.-6      	; 0x3296 <__mulsf3_pse+0x82>
    329c:	98 3e       	cpi	r25, 0xE8	; 232
    329e:	dc f3       	brlt	.-10     	; 0x3296 <__mulsf3_pse+0x82>
    32a0:	86 95       	lsr	r24
    32a2:	77 95       	ror	r23
    32a4:	67 95       	ror	r22
    32a6:	b7 95       	ror	r27
    32a8:	f7 95       	ror	r31
    32aa:	e7 95       	ror	r30
    32ac:	9f 5f       	subi	r25, 0xFF	; 255
    32ae:	c1 f7       	brne	.-16     	; 0x32a0 <__mulsf3_pse+0x8c>
    32b0:	fe 2b       	or	r31, r30
    32b2:	88 0f       	add	r24, r24
    32b4:	91 1d       	adc	r25, r1
    32b6:	96 95       	lsr	r25
    32b8:	87 95       	ror	r24
    32ba:	97 f9       	bld	r25, 7
    32bc:	08 95       	ret

000032be <pow>:
    32be:	fa 01       	movw	r30, r20
    32c0:	ee 0f       	add	r30, r30
    32c2:	ff 1f       	adc	r31, r31
    32c4:	30 96       	adiw	r30, 0x00	; 0
    32c6:	21 05       	cpc	r18, r1
    32c8:	31 05       	cpc	r19, r1
    32ca:	99 f1       	breq	.+102    	; 0x3332 <pow+0x74>
    32cc:	61 15       	cp	r22, r1
    32ce:	71 05       	cpc	r23, r1
    32d0:	61 f4       	brne	.+24     	; 0x32ea <pow+0x2c>
    32d2:	80 38       	cpi	r24, 0x80	; 128
    32d4:	bf e3       	ldi	r27, 0x3F	; 63
    32d6:	9b 07       	cpc	r25, r27
    32d8:	49 f1       	breq	.+82     	; 0x332c <pow+0x6e>
    32da:	68 94       	set
    32dc:	90 38       	cpi	r25, 0x80	; 128
    32de:	81 05       	cpc	r24, r1
    32e0:	61 f0       	breq	.+24     	; 0x32fa <pow+0x3c>
    32e2:	80 38       	cpi	r24, 0x80	; 128
    32e4:	bf ef       	ldi	r27, 0xFF	; 255
    32e6:	9b 07       	cpc	r25, r27
    32e8:	41 f0       	breq	.+16     	; 0x32fa <pow+0x3c>
    32ea:	99 23       	and	r25, r25
    32ec:	42 f5       	brpl	.+80     	; 0x333e <pow+0x80>
    32ee:	ff 3f       	cpi	r31, 0xFF	; 255
    32f0:	e1 05       	cpc	r30, r1
    32f2:	31 05       	cpc	r19, r1
    32f4:	21 05       	cpc	r18, r1
    32f6:	11 f1       	breq	.+68     	; 0x333c <pow+0x7e>
    32f8:	e8 94       	clt
    32fa:	08 94       	sec
    32fc:	e7 95       	ror	r30
    32fe:	d9 01       	movw	r26, r18
    3300:	aa 23       	and	r26, r26
    3302:	29 f4       	brne	.+10     	; 0x330e <pow+0x50>
    3304:	ab 2f       	mov	r26, r27
    3306:	be 2f       	mov	r27, r30
    3308:	f8 5f       	subi	r31, 0xF8	; 248
    330a:	d0 f3       	brcs	.-12     	; 0x3300 <pow+0x42>
    330c:	10 c0       	rjmp	.+32     	; 0x332e <pow+0x70>
    330e:	ff 5f       	subi	r31, 0xFF	; 255
    3310:	70 f4       	brcc	.+28     	; 0x332e <pow+0x70>
    3312:	a6 95       	lsr	r26
    3314:	e0 f7       	brcc	.-8      	; 0x330e <pow+0x50>
    3316:	f7 39       	cpi	r31, 0x97	; 151
    3318:	50 f0       	brcs	.+20     	; 0x332e <pow+0x70>
    331a:	19 f0       	breq	.+6      	; 0x3322 <pow+0x64>
    331c:	ff 3a       	cpi	r31, 0xAF	; 175
    331e:	38 f4       	brcc	.+14     	; 0x332e <pow+0x70>
    3320:	9f 77       	andi	r25, 0x7F	; 127
    3322:	9f 93       	push	r25
    3324:	0c d0       	rcall	.+24     	; 0x333e <pow+0x80>
    3326:	0f 90       	pop	r0
    3328:	07 fc       	sbrc	r0, 7
    332a:	90 58       	subi	r25, 0x80	; 128
    332c:	08 95       	ret
    332e:	3e f0       	brts	.+14     	; 0x333e <pow+0x80>
    3330:	18 cf       	rjmp	.-464    	; 0x3162 <__fp_nan>
    3332:	60 e0       	ldi	r22, 0x00	; 0
    3334:	70 e0       	ldi	r23, 0x00	; 0
    3336:	80 e8       	ldi	r24, 0x80	; 128
    3338:	9f e3       	ldi	r25, 0x3F	; 63
    333a:	08 95       	ret
    333c:	4f e7       	ldi	r20, 0x7F	; 127
    333e:	9f 77       	andi	r25, 0x7F	; 127
    3340:	5f 93       	push	r21
    3342:	4f 93       	push	r20
    3344:	3f 93       	push	r19
    3346:	2f 93       	push	r18
    3348:	9e d0       	rcall	.+316    	; 0x3486 <log>
    334a:	2f 91       	pop	r18
    334c:	3f 91       	pop	r19
    334e:	4f 91       	pop	r20
    3350:	5f 91       	pop	r21
    3352:	52 df       	rcall	.-348    	; 0x31f8 <__mulsf3>
    3354:	05 c0       	rjmp	.+10     	; 0x3360 <exp>
    3356:	19 f4       	brne	.+6      	; 0x335e <pow+0xa0>
    3358:	0e f0       	brts	.+2      	; 0x335c <pow+0x9e>
    335a:	fd ce       	rjmp	.-518    	; 0x3156 <__fp_inf>
    335c:	46 cf       	rjmp	.-372    	; 0x31ea <__fp_zero>
    335e:	01 cf       	rjmp	.-510    	; 0x3162 <__fp_nan>

00003360 <exp>:
    3360:	2a df       	rcall	.-428    	; 0x31b6 <__fp_splitA>
    3362:	c8 f3       	brcs	.-14     	; 0x3356 <pow+0x98>
    3364:	96 38       	cpi	r25, 0x86	; 134
    3366:	c0 f7       	brcc	.-16     	; 0x3358 <pow+0x9a>
    3368:	07 f8       	bld	r0, 7
    336a:	0f 92       	push	r0
    336c:	e8 94       	clt
    336e:	2b e3       	ldi	r18, 0x3B	; 59
    3370:	3a ea       	ldi	r19, 0xAA	; 170
    3372:	48 eb       	ldi	r20, 0xB8	; 184
    3374:	5f e7       	ldi	r21, 0x7F	; 127
    3376:	4e df       	rcall	.-356    	; 0x3214 <__mulsf3_pse>
    3378:	0f 92       	push	r0
    337a:	0f 92       	push	r0
    337c:	0f 92       	push	r0
    337e:	4d b7       	in	r20, 0x3d	; 61
    3380:	5e b7       	in	r21, 0x3e	; 62
    3382:	0f 92       	push	r0
    3384:	c0 d0       	rcall	.+384    	; 0x3506 <modf>
    3386:	e4 e5       	ldi	r30, 0x54	; 84
    3388:	f0 e0       	ldi	r31, 0x00	; 0
    338a:	16 d0       	rcall	.+44     	; 0x33b8 <__fp_powser>
    338c:	4f 91       	pop	r20
    338e:	5f 91       	pop	r21
    3390:	ef 91       	pop	r30
    3392:	ff 91       	pop	r31
    3394:	e5 95       	asr	r30
    3396:	ee 1f       	adc	r30, r30
    3398:	ff 1f       	adc	r31, r31
    339a:	49 f0       	breq	.+18     	; 0x33ae <exp+0x4e>
    339c:	fe 57       	subi	r31, 0x7E	; 126
    339e:	e0 68       	ori	r30, 0x80	; 128
    33a0:	44 27       	eor	r20, r20
    33a2:	ee 0f       	add	r30, r30
    33a4:	44 1f       	adc	r20, r20
    33a6:	fa 95       	dec	r31
    33a8:	e1 f7       	brne	.-8      	; 0x33a2 <exp+0x42>
    33aa:	41 95       	neg	r20
    33ac:	55 0b       	sbc	r21, r21
    33ae:	32 d0       	rcall	.+100    	; 0x3414 <ldexp>
    33b0:	0f 90       	pop	r0
    33b2:	07 fe       	sbrs	r0, 7
    33b4:	26 c0       	rjmp	.+76     	; 0x3402 <inverse>
    33b6:	08 95       	ret

000033b8 <__fp_powser>:
    33b8:	df 93       	push	r29
    33ba:	cf 93       	push	r28
    33bc:	1f 93       	push	r17
    33be:	0f 93       	push	r16
    33c0:	ff 92       	push	r15
    33c2:	ef 92       	push	r14
    33c4:	df 92       	push	r13
    33c6:	7b 01       	movw	r14, r22
    33c8:	8c 01       	movw	r16, r24
    33ca:	68 94       	set
    33cc:	05 c0       	rjmp	.+10     	; 0x33d8 <__fp_powser+0x20>
    33ce:	da 2e       	mov	r13, r26
    33d0:	ef 01       	movw	r28, r30
    33d2:	1e df       	rcall	.-452    	; 0x3210 <__mulsf3x>
    33d4:	fe 01       	movw	r30, r28
    33d6:	e8 94       	clt
    33d8:	a5 91       	lpm	r26, Z+
    33da:	25 91       	lpm	r18, Z+
    33dc:	35 91       	lpm	r19, Z+
    33de:	45 91       	lpm	r20, Z+
    33e0:	55 91       	lpm	r21, Z+
    33e2:	ae f3       	brts	.-22     	; 0x33ce <__fp_powser+0x16>
    33e4:	ef 01       	movw	r28, r30
    33e6:	8e dd       	rcall	.-1252   	; 0x2f04 <__addsf3x>
    33e8:	fe 01       	movw	r30, r28
    33ea:	97 01       	movw	r18, r14
    33ec:	a8 01       	movw	r20, r16
    33ee:	da 94       	dec	r13
    33f0:	79 f7       	brne	.-34     	; 0x33d0 <__fp_powser+0x18>
    33f2:	df 90       	pop	r13
    33f4:	ef 90       	pop	r14
    33f6:	ff 90       	pop	r15
    33f8:	0f 91       	pop	r16
    33fa:	1f 91       	pop	r17
    33fc:	cf 91       	pop	r28
    33fe:	df 91       	pop	r29
    3400:	08 95       	ret

00003402 <inverse>:
    3402:	9b 01       	movw	r18, r22
    3404:	ac 01       	movw	r20, r24
    3406:	60 e0       	ldi	r22, 0x00	; 0
    3408:	70 e0       	ldi	r23, 0x00	; 0
    340a:	80 e8       	ldi	r24, 0x80	; 128
    340c:	9f e3       	ldi	r25, 0x3F	; 63
    340e:	cd cd       	rjmp	.-1126   	; 0x2faa <__divsf3>
    3410:	a2 ce       	rjmp	.-700    	; 0x3156 <__fp_inf>
    3412:	ac c0       	rjmp	.+344    	; 0x356c <__fp_mpack>

00003414 <ldexp>:
    3414:	d0 de       	rcall	.-608    	; 0x31b6 <__fp_splitA>
    3416:	e8 f3       	brcs	.-6      	; 0x3412 <inverse+0x10>
    3418:	99 23       	and	r25, r25
    341a:	d9 f3       	breq	.-10     	; 0x3412 <inverse+0x10>
    341c:	94 0f       	add	r25, r20
    341e:	51 1d       	adc	r21, r1
    3420:	bb f3       	brvs	.-18     	; 0x3410 <inverse+0xe>
    3422:	91 50       	subi	r25, 0x01	; 1
    3424:	50 40       	sbci	r21, 0x00	; 0
    3426:	94 f0       	brlt	.+36     	; 0x344c <ldexp+0x38>
    3428:	59 f0       	breq	.+22     	; 0x3440 <ldexp+0x2c>
    342a:	88 23       	and	r24, r24
    342c:	32 f0       	brmi	.+12     	; 0x343a <ldexp+0x26>
    342e:	66 0f       	add	r22, r22
    3430:	77 1f       	adc	r23, r23
    3432:	88 1f       	adc	r24, r24
    3434:	91 50       	subi	r25, 0x01	; 1
    3436:	50 40       	sbci	r21, 0x00	; 0
    3438:	c1 f7       	brne	.-16     	; 0x342a <ldexp+0x16>
    343a:	9e 3f       	cpi	r25, 0xFE	; 254
    343c:	51 05       	cpc	r21, r1
    343e:	44 f7       	brge	.-48     	; 0x3410 <inverse+0xe>
    3440:	88 0f       	add	r24, r24
    3442:	91 1d       	adc	r25, r1
    3444:	96 95       	lsr	r25
    3446:	87 95       	ror	r24
    3448:	97 f9       	bld	r25, 7
    344a:	08 95       	ret
    344c:	5f 3f       	cpi	r21, 0xFF	; 255
    344e:	ac f0       	brlt	.+42     	; 0x347a <ldexp+0x66>
    3450:	98 3e       	cpi	r25, 0xE8	; 232
    3452:	9c f0       	brlt	.+38     	; 0x347a <ldexp+0x66>
    3454:	bb 27       	eor	r27, r27
    3456:	86 95       	lsr	r24
    3458:	77 95       	ror	r23
    345a:	67 95       	ror	r22
    345c:	b7 95       	ror	r27
    345e:	08 f4       	brcc	.+2      	; 0x3462 <ldexp+0x4e>
    3460:	b1 60       	ori	r27, 0x01	; 1
    3462:	93 95       	inc	r25
    3464:	c1 f7       	brne	.-16     	; 0x3456 <ldexp+0x42>
    3466:	bb 0f       	add	r27, r27
    3468:	58 f7       	brcc	.-42     	; 0x3440 <ldexp+0x2c>
    346a:	11 f4       	brne	.+4      	; 0x3470 <ldexp+0x5c>
    346c:	60 ff       	sbrs	r22, 0
    346e:	e8 cf       	rjmp	.-48     	; 0x3440 <ldexp+0x2c>
    3470:	6f 5f       	subi	r22, 0xFF	; 255
    3472:	7f 4f       	sbci	r23, 0xFF	; 255
    3474:	8f 4f       	sbci	r24, 0xFF	; 255
    3476:	9f 4f       	sbci	r25, 0xFF	; 255
    3478:	e3 cf       	rjmp	.-58     	; 0x3440 <ldexp+0x2c>
    347a:	b8 ce       	rjmp	.-656    	; 0x31ec <__fp_szero>
    347c:	0e f0       	brts	.+2      	; 0x3480 <ldexp+0x6c>
    347e:	76 c0       	rjmp	.+236    	; 0x356c <__fp_mpack>
    3480:	70 ce       	rjmp	.-800    	; 0x3162 <__fp_nan>
    3482:	68 94       	set
    3484:	68 ce       	rjmp	.-816    	; 0x3156 <__fp_inf>

00003486 <log>:
    3486:	97 de       	rcall	.-722    	; 0x31b6 <__fp_splitA>
    3488:	c8 f3       	brcs	.-14     	; 0x347c <ldexp+0x68>
    348a:	99 23       	and	r25, r25
    348c:	d1 f3       	breq	.-12     	; 0x3482 <ldexp+0x6e>
    348e:	c6 f3       	brts	.-16     	; 0x3480 <ldexp+0x6c>
    3490:	df 93       	push	r29
    3492:	cf 93       	push	r28
    3494:	1f 93       	push	r17
    3496:	0f 93       	push	r16
    3498:	ff 92       	push	r15
    349a:	c9 2f       	mov	r28, r25
    349c:	dd 27       	eor	r29, r29
    349e:	88 23       	and	r24, r24
    34a0:	2a f0       	brmi	.+10     	; 0x34ac <log+0x26>
    34a2:	21 97       	sbiw	r28, 0x01	; 1
    34a4:	66 0f       	add	r22, r22
    34a6:	77 1f       	adc	r23, r23
    34a8:	88 1f       	adc	r24, r24
    34aa:	da f7       	brpl	.-10     	; 0x34a2 <log+0x1c>
    34ac:	20 e0       	ldi	r18, 0x00	; 0
    34ae:	30 e0       	ldi	r19, 0x00	; 0
    34b0:	40 e8       	ldi	r20, 0x80	; 128
    34b2:	5f eb       	ldi	r21, 0xBF	; 191
    34b4:	9f e3       	ldi	r25, 0x3F	; 63
    34b6:	88 39       	cpi	r24, 0x98	; 152
    34b8:	20 f0       	brcs	.+8      	; 0x34c2 <log+0x3c>
    34ba:	80 3e       	cpi	r24, 0xE0	; 224
    34bc:	30 f0       	brcs	.+12     	; 0x34ca <log+0x44>
    34be:	21 96       	adiw	r28, 0x01	; 1
    34c0:	8f 77       	andi	r24, 0x7F	; 127
    34c2:	0f dd       	rcall	.-1506   	; 0x2ee2 <__addsf3>
    34c4:	ec e7       	ldi	r30, 0x7C	; 124
    34c6:	f0 e0       	ldi	r31, 0x00	; 0
    34c8:	03 c0       	rjmp	.+6      	; 0x34d0 <log+0x4a>
    34ca:	0b dd       	rcall	.-1514   	; 0x2ee2 <__addsf3>
    34cc:	e9 ea       	ldi	r30, 0xA9	; 169
    34ce:	f0 e0       	ldi	r31, 0x00	; 0
    34d0:	73 df       	rcall	.-282    	; 0x33b8 <__fp_powser>
    34d2:	8b 01       	movw	r16, r22
    34d4:	be 01       	movw	r22, r28
    34d6:	ec 01       	movw	r28, r24
    34d8:	fb 2e       	mov	r15, r27
    34da:	6f 57       	subi	r22, 0x7F	; 127
    34dc:	71 09       	sbc	r23, r1
    34de:	75 95       	asr	r23
    34e0:	77 1f       	adc	r23, r23
    34e2:	88 0b       	sbc	r24, r24
    34e4:	99 0b       	sbc	r25, r25
    34e6:	fc dd       	rcall	.-1032   	; 0x30e0 <__floatsisf>
    34e8:	28 e1       	ldi	r18, 0x18	; 24
    34ea:	32 e7       	ldi	r19, 0x72	; 114
    34ec:	41 e3       	ldi	r20, 0x31	; 49
    34ee:	5f e3       	ldi	r21, 0x3F	; 63
    34f0:	8f de       	rcall	.-738    	; 0x3210 <__mulsf3x>
    34f2:	af 2d       	mov	r26, r15
    34f4:	98 01       	movw	r18, r16
    34f6:	ae 01       	movw	r20, r28
    34f8:	ff 90       	pop	r15
    34fa:	0f 91       	pop	r16
    34fc:	1f 91       	pop	r17
    34fe:	cf 91       	pop	r28
    3500:	df 91       	pop	r29
    3502:	00 dd       	rcall	.-1536   	; 0x2f04 <__addsf3x>
    3504:	3f ce       	rjmp	.-898    	; 0x3184 <__fp_round>

00003506 <modf>:
    3506:	fa 01       	movw	r30, r20
    3508:	dc 01       	movw	r26, r24
    350a:	aa 0f       	add	r26, r26
    350c:	bb 1f       	adc	r27, r27
    350e:	9b 01       	movw	r18, r22
    3510:	ac 01       	movw	r20, r24
    3512:	bf 57       	subi	r27, 0x7F	; 127
    3514:	28 f4       	brcc	.+10     	; 0x3520 <modf+0x1a>
    3516:	22 27       	eor	r18, r18
    3518:	33 27       	eor	r19, r19
    351a:	44 27       	eor	r20, r20
    351c:	50 78       	andi	r21, 0x80	; 128
    351e:	1f c0       	rjmp	.+62     	; 0x355e <modf+0x58>
    3520:	b7 51       	subi	r27, 0x17	; 23
    3522:	88 f4       	brcc	.+34     	; 0x3546 <modf+0x40>
    3524:	ab 2f       	mov	r26, r27
    3526:	00 24       	eor	r0, r0
    3528:	46 95       	lsr	r20
    352a:	37 95       	ror	r19
    352c:	27 95       	ror	r18
    352e:	01 1c       	adc	r0, r1
    3530:	a3 95       	inc	r26
    3532:	d2 f3       	brmi	.-12     	; 0x3528 <modf+0x22>
    3534:	00 20       	and	r0, r0
    3536:	69 f0       	breq	.+26     	; 0x3552 <modf+0x4c>
    3538:	22 0f       	add	r18, r18
    353a:	33 1f       	adc	r19, r19
    353c:	44 1f       	adc	r20, r20
    353e:	b3 95       	inc	r27
    3540:	da f3       	brmi	.-10     	; 0x3538 <modf+0x32>
    3542:	0d d0       	rcall	.+26     	; 0x355e <modf+0x58>
    3544:	cd cc       	rjmp	.-1638   	; 0x2ee0 <__subsf3>
    3546:	61 30       	cpi	r22, 0x01	; 1
    3548:	71 05       	cpc	r23, r1
    354a:	a0 e8       	ldi	r26, 0x80	; 128
    354c:	8a 07       	cpc	r24, r26
    354e:	b9 46       	sbci	r27, 0x69	; 105
    3550:	30 f4       	brcc	.+12     	; 0x355e <modf+0x58>
    3552:	9b 01       	movw	r18, r22
    3554:	ac 01       	movw	r20, r24
    3556:	66 27       	eor	r22, r22
    3558:	77 27       	eor	r23, r23
    355a:	88 27       	eor	r24, r24
    355c:	90 78       	andi	r25, 0x80	; 128
    355e:	30 96       	adiw	r30, 0x00	; 0
    3560:	21 f0       	breq	.+8      	; 0x356a <modf+0x64>
    3562:	20 83       	st	Z, r18
    3564:	31 83       	std	Z+1, r19	; 0x01
    3566:	42 83       	std	Z+2, r20	; 0x02
    3568:	53 83       	std	Z+3, r21	; 0x03
    356a:	08 95       	ret

0000356c <__fp_mpack>:
    356c:	9f 3f       	cpi	r25, 0xFF	; 255
    356e:	31 f0       	breq	.+12     	; 0x357c <__fp_mpack_finite+0xc>

00003570 <__fp_mpack_finite>:
    3570:	91 50       	subi	r25, 0x01	; 1
    3572:	20 f4       	brcc	.+8      	; 0x357c <__fp_mpack_finite+0xc>
    3574:	87 95       	ror	r24
    3576:	77 95       	ror	r23
    3578:	67 95       	ror	r22
    357a:	b7 95       	ror	r27
    357c:	88 0f       	add	r24, r24
    357e:	91 1d       	adc	r25, r1
    3580:	96 95       	lsr	r25
    3582:	87 95       	ror	r24
    3584:	97 f9       	bld	r25, 7
    3586:	08 95       	ret

00003588 <__udivmodhi4>:
    3588:	aa 1b       	sub	r26, r26
    358a:	bb 1b       	sub	r27, r27
    358c:	51 e1       	ldi	r21, 0x11	; 17
    358e:	07 c0       	rjmp	.+14     	; 0x359e <__udivmodhi4_ep>

00003590 <__udivmodhi4_loop>:
    3590:	aa 1f       	adc	r26, r26
    3592:	bb 1f       	adc	r27, r27
    3594:	a6 17       	cp	r26, r22
    3596:	b7 07       	cpc	r27, r23
    3598:	10 f0       	brcs	.+4      	; 0x359e <__udivmodhi4_ep>
    359a:	a6 1b       	sub	r26, r22
    359c:	b7 0b       	sbc	r27, r23

0000359e <__udivmodhi4_ep>:
    359e:	88 1f       	adc	r24, r24
    35a0:	99 1f       	adc	r25, r25
    35a2:	5a 95       	dec	r21
    35a4:	a9 f7       	brne	.-22     	; 0x3590 <__udivmodhi4_loop>
    35a6:	80 95       	com	r24
    35a8:	90 95       	com	r25
    35aa:	bc 01       	movw	r22, r24
    35ac:	cd 01       	movw	r24, r26
    35ae:	08 95       	ret

000035b0 <__divmodhi4>:
    35b0:	97 fb       	bst	r25, 7
    35b2:	09 2e       	mov	r0, r25
    35b4:	07 26       	eor	r0, r23
    35b6:	0a d0       	rcall	.+20     	; 0x35cc <__divmodhi4_neg1>
    35b8:	77 fd       	sbrc	r23, 7
    35ba:	04 d0       	rcall	.+8      	; 0x35c4 <__divmodhi4_neg2>
    35bc:	e5 df       	rcall	.-54     	; 0x3588 <__udivmodhi4>
    35be:	06 d0       	rcall	.+12     	; 0x35cc <__divmodhi4_neg1>
    35c0:	00 20       	and	r0, r0
    35c2:	1a f4       	brpl	.+6      	; 0x35ca <__divmodhi4_exit>

000035c4 <__divmodhi4_neg2>:
    35c4:	70 95       	com	r23
    35c6:	61 95       	neg	r22
    35c8:	7f 4f       	sbci	r23, 0xFF	; 255

000035ca <__divmodhi4_exit>:
    35ca:	08 95       	ret

000035cc <__divmodhi4_neg1>:
    35cc:	f6 f7       	brtc	.-4      	; 0x35ca <__divmodhi4_exit>
    35ce:	90 95       	com	r25
    35d0:	81 95       	neg	r24
    35d2:	9f 4f       	sbci	r25, 0xFF	; 255
    35d4:	08 95       	ret

000035d6 <_exit>:
    35d6:	f8 94       	cli

000035d8 <__stop_program>:
    35d8:	ff cf       	rjmp	.-2      	; 0x35d8 <__stop_program>
